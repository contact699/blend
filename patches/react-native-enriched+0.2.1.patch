diff --git a/node_modules/react-native-enriched/README.md b/node_modules/react-native-enriched/README.md
index 63d0468..f2e49ea 100644
--- a/node_modules/react-native-enriched/README.md
+++ b/node_modules/react-native-enriched/README.md
@@ -1,4 +1,4 @@
-<img src="https://github.com/user-attachments/assets/abc75d3b-495b-4a76-a72f-d87ce3ca1ff9" alt="react-native-enriched by Software Mansion" width="100%">
+<img src="https://github.com/user-attachments/assets/b010571e-e4a3-4d92-a409-4f9fe614025d" alt="react-native-enriched by Software Mansion" width="100%">
 
 # react-native-enriched
 
@@ -40,7 +40,7 @@ We can help you build your next dream product â€“
 ## Prerequisites
 
 - `react-native-enriched` currently supports only Android and iOS platforms
-- It works only with [the React Native New Architecture (Fabric)](https://reactnative.dev/architecture/landing-page) and supports following React Native releases: `0.79`, `0.80`, `0.81` and `0.82`
+- It works only with [the React Native New Architecture (Fabric)](https://reactnative.dev/architecture/landing-page) and supports following React Native releases: `0.79`, `0.80`, `0.81`, `0.82` and `0.83`
 
 ## Installation
 
@@ -101,11 +101,11 @@ export default function App() {
     <View style={styles.container}>
       <EnrichedTextInput
         ref={ref}
-        onChangeState={(e) => setStylesState(e.nativeEvent)}
+        onChangeState={e => setStylesState(e.nativeEvent)}
         style={styles.input}
       />
       <Button
-        title="Toggle bold"
+        title={stylesState?.isBold ? 'Unbold' : 'Bold'}
         color={stylesState?.isBold ? 'green' : 'gray'}
         onPress={() => ref.current?.toggleBold()}
       />
@@ -152,9 +152,6 @@ Supported styles:
 - ordered list
 - unordered list
 
-> [!NOTE]
-> The iOS doesn't support codeblocks just yet, but it's planned in the near future!
-
 Each of the styles can be toggled the same way as in the example from [usage section](#usage); call a proper `toggle` function on the component ref.
 
 Each call toggles the style within the current text selection. We can still divide styles into two categories based on how they treat the selection:
@@ -212,9 +209,6 @@ You can insert an image into the input using [setImage](docs/API_REFERENCE.md#se
 
 The image will be put into a single line in the input and will affect the line's height as well as input's height. Keep in mind, that image will replace currently selected text or insert into the cursor position if there is no text selection.
 
-> [!NOTE]
-> The iOS doesn't support inline images just yet, but it's planned in the near future!
-
 ## Style Detection
 
 All of the above styles can be detected with the use of [onChangeState](docs/API_REFERENCE.md#onchangestate) event payload.
@@ -244,14 +238,10 @@ See the [API Reference](docs/API_REFERENCE.md) for a detailed overview of all th
 ## Known limitations
 
 - Only one level of lists is supported. We currently do not support nested lists.
-- Inline images are supported only on Android.
-- Codeblocks are supported only on Android.
 - iOS headings can't have the same `fontSize` in their config as input's `fontSize`. Doing so results in incorrect headings behavior.
 
 ## Future Plans
 
-- Adding Codeblocks and Inline Images to iOS input.
-- Making some optimizations around `onChangeHtml` event, maybe some imperative API to get the HTML output.
 - Creating `EnrichedText` text component that supports our HTML output format with all additional interactions like pressing links or mentions.
 - Adding API for custom link detection regex.
 - Web library implementation via `react-native-web`.
diff --git a/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerDelegate.java b/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerDelegate.java
index aba15d7..43e2e98 100644
--- a/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerDelegate.java
+++ b/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerDelegate.java
@@ -136,7 +136,7 @@ public class EnrichedTextInputViewManagerDelegate<T extends View, U extends Base
         mViewManager.addLink(view, args.getInt(0), args.getInt(1), args.getString(2), args.getString(3));
         break;
       case "addImage":
-        mViewManager.addImage(view, args.getString(0));
+        mViewManager.addImage(view, args.getString(0), (float) args.getDouble(1), (float) args.getDouble(2));
         break;
       case "startMention":
         mViewManager.startMention(view, args.getString(0));
@@ -144,6 +144,9 @@ public class EnrichedTextInputViewManagerDelegate<T extends View, U extends Base
       case "addMention":
         mViewManager.addMention(view, args.getString(0), args.getString(1), args.getString(2));
         break;
+      case "requestHTML":
+        mViewManager.requestHTML(view, args.getInt(0));
+        break;
     }
   }
 }
diff --git a/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerInterface.java b/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerInterface.java
index 5caafc5..13f0db8 100644
--- a/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerInterface.java
+++ b/node_modules/react-native-enriched/android/generated/java/com/facebook/react/viewmanagers/EnrichedTextInputViewManagerInterface.java
@@ -50,7 +50,8 @@ public interface EnrichedTextInputViewManagerInterface<T extends View> extends V
   void toggleOrderedList(T view);
   void toggleUnorderedList(T view);
   void addLink(T view, int start, int end, String text, String url);
-  void addImage(T view, String uri);
+  void addImage(T view, String uri, float width, float height);
   void startMention(T view, String indicator);
   void addMention(T view, String indicator, String text, String payload);
+  void requestHTML(T view, int requestId);
 }
diff --git a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.cpp b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.cpp
index 0433ff3..9d82a88 100644
--- a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.cpp
+++ b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.cpp
@@ -115,4 +115,14 @@ payload.setProperty(runtime, "text", event.text);
   });
 }
 
+
+void EnrichedTextInputViewEventEmitter::onRequestHtmlResult(OnRequestHtmlResult event) const {
+  dispatchEvent("requestHtmlResult", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "requestId", event.requestId);
+payload.setProperty(runtime, "html", jsi::valueFromDynamic(runtime, event.html));
+    return payload;
+  });
+}
+
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.h b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.h
index 9ec63a1..bda62b9 100644
--- a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.h
+++ b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.h
@@ -74,6 +74,11 @@ class EnrichedTextInputViewEventEmitter : public ViewEventEmitter {
     int end;
     std::string text;
     };
+
+  struct OnRequestHtmlResult {
+      int requestId;
+    folly::dynamic html;
+    };
   void onInputFocus(OnInputFocus value) const;
 
   void onInputBlur(OnInputBlur value) const;
@@ -91,5 +96,7 @@ class EnrichedTextInputViewEventEmitter : public ViewEventEmitter {
   void onMention(OnMention value) const;
 
   void onChangeSelection(OnChangeSelection value) const;
+
+  void onRequestHtmlResult(OnRequestHtmlResult value) const;
 };
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/Props.h b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/Props.h
index 365e247..142b024 100644
--- a/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/Props.h
+++ b/node_modules/react-native-enriched/android/generated/jni/react/renderer/components/RNEnrichedTextInputViewSpec/Props.h
@@ -309,45 +309,6 @@ static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleAStru
 }
 #endif
 
-struct EnrichedTextInputViewHtmlStyleImgStruct {
-  Float width{0.0};
-  Float height{0.0};
-
-#ifdef RN_SERIALIZABLE_STATE
-  bool operator==(const EnrichedTextInputViewHtmlStyleImgStruct&) const = default;
-
-  folly::dynamic toDynamic() const {
-    folly::dynamic result = folly::dynamic::object();
-    result["width"] = width;
-    result["height"] = height;
-    return result;
-  }
-#endif
-};
-
-static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleImgStruct &result) {
-  auto map = (std::unordered_map<std::string, RawValue>)value;
-
-  auto tmp_width = map.find("width");
-  if (tmp_width != map.end()) {
-    fromRawValue(context, tmp_width->second, result.width);
-  }
-  auto tmp_height = map.find("height");
-  if (tmp_height != map.end()) {
-    fromRawValue(context, tmp_height->second, result.height);
-  }
-}
-
-static inline std::string toString(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
-  return "[Object EnrichedTextInputViewHtmlStyleImgStruct]";
-}
-
-#ifdef RN_SERIALIZABLE_STATE
-static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
-  return value.toDynamic();
-}
-#endif
-
 struct EnrichedTextInputViewHtmlStyleOlStruct {
   Float gapWidth{0.0};
   Float marginLeft{0.0};
@@ -459,7 +420,6 @@ struct EnrichedTextInputViewHtmlStyleStruct {
   EnrichedTextInputViewHtmlStyleCodeStruct code{};
   EnrichedTextInputViewHtmlStyleAStruct a{};
   folly::dynamic mention{};
-  EnrichedTextInputViewHtmlStyleImgStruct img{};
   EnrichedTextInputViewHtmlStyleOlStruct ol{};
   EnrichedTextInputViewHtmlStyleUlStruct ul{};
 
@@ -476,7 +436,6 @@ struct EnrichedTextInputViewHtmlStyleStruct {
     result["code"] = ::facebook::react::toDynamic(code);
     result["a"] = ::facebook::react::toDynamic(a);
     result["mention"] = mention;
-    result["img"] = ::facebook::react::toDynamic(img);
     result["ol"] = ::facebook::react::toDynamic(ol);
     result["ul"] = ::facebook::react::toDynamic(ul);
     return result;
@@ -519,10 +478,6 @@ static inline void fromRawValue(const PropsParserContext& context, const RawValu
   if (tmp_mention != map.end()) {
     fromRawValue(context, tmp_mention->second, result.mention);
   }
-  auto tmp_img = map.find("img");
-  if (tmp_img != map.end()) {
-    fromRawValue(context, tmp_img->second, result.img);
-  }
   auto tmp_ol = map.find("ol");
   if (tmp_ol != map.end()) {
     fromRawValue(context, tmp_ol->second, result.ol);
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputView.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputView.kt
index 086b5d8..55abf94 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputView.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputView.kt
@@ -29,7 +29,13 @@ import com.facebook.react.views.text.ReactTypefaceUtils.parseFontWeight
 import com.swmansion.enriched.events.MentionHandler
 import com.swmansion.enriched.events.OnInputBlurEvent
 import com.swmansion.enriched.events.OnInputFocusEvent
+import com.swmansion.enriched.events.OnRequestHtmlResultEvent
+import com.swmansion.enriched.spans.EnrichedH1Span
+import com.swmansion.enriched.spans.EnrichedH2Span
+import com.swmansion.enriched.spans.EnrichedH3Span
+import com.swmansion.enriched.spans.EnrichedImageSpan
 import com.swmansion.enriched.spans.EnrichedSpans
+import com.swmansion.enriched.spans.interfaces.EnrichedSpan
 import com.swmansion.enriched.styles.InlineStyles
 import com.swmansion.enriched.styles.ListStyles
 import com.swmansion.enriched.styles.ParagraphStyles
@@ -58,9 +64,17 @@ class EnrichedTextInputView : AppCompatEditText {
 
   val mentionHandler: MentionHandler? = MentionHandler(this)
   var htmlStyle: HtmlStyle = HtmlStyle(this, null)
+    set(value) {
+        if (field != value) {
+            val prev = field
+            field = value
+            reApplyHtmlStyleForSpans(prev, value)
+        }
+    }
   var spanWatcher: EnrichedSpanWatcher? = null
   var layoutManager: EnrichedTextInputViewLayoutManager = EnrichedTextInputViewLayoutManager(this)
 
+  var shouldEmitHtml: Boolean = true
   var experimentalSynchronousEvents: Boolean = false
 
   var fontSize: Float? = null
@@ -254,6 +268,7 @@ class EnrichedTextInputView : AppCompatEditText {
       val newText = parseText(value)
       setText(newText)
 
+      observeAsyncImages()
       // Assign SpanWatcher one more time as our previous spannable has been replaced
       addSpanWatcher(EnrichedSpanWatcher(this))
 
@@ -262,6 +277,20 @@ class EnrichedTextInputView : AppCompatEditText {
     }
   }
 
+  /**
+   * Finds all async images in the current text and sets up listeners
+   * to redraw the text layout when they finish downloading.
+   */
+  private fun observeAsyncImages() {
+    val liveText = text ?: return
+
+    val spans = liveText.getSpans(0, liveText.length, EnrichedImageSpan::class.java)
+
+    for (span in spans) {
+      span.observeAsyncDrawableLoaded(liveText)
+    }
+  }
+
   fun setAutoFocus(autoFocus: Boolean) {
     this.autoFocus = autoFocus
   }
@@ -318,6 +347,7 @@ class EnrichedTextInputView : AppCompatEditText {
     // This ensured that newly created spans will take the new font size into account
     htmlStyle.invalidateStyles()
     layoutManager.invalidateLayout()
+    forceScrollToSelection()
   }
 
   fun setFontFamily(family: String?) {
@@ -527,11 +557,11 @@ class EnrichedTextInputView : AppCompatEditText {
     parametrizedStyles?.setLinkSpan(start, end, text, url)
   }
 
-  fun addImage(src: String) {
+  fun addImage(src: String, width: Float, height: Float) {
     val isValid = verifyStyle(EnrichedSpans.IMAGE)
     if (!isValid) return
 
-    parametrizedStyles?.setImageSpan(src)
+    parametrizedStyles?.setImageSpan(src, width, height)
     layoutManager.invalidateLayout()
   }
 
@@ -549,6 +579,19 @@ class EnrichedTextInputView : AppCompatEditText {
     parametrizedStyles?.setMentionSpan(text, indicator, attributes)
   }
 
+  fun requestHTML(requestId: Int) {
+    val html = try {
+      EnrichedParser.toHtmlWithDefault(text)
+    } catch (e: Exception) {
+      null
+    }
+
+    val reactContext = context as ReactContext
+    val surfaceId = UIManagerHelper.getSurfaceId(reactContext)
+    val dispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, id)
+    dispatcher?.dispatchEvent(OnRequestHtmlResultEvent(surfaceId, id, requestId, html, experimentalSynchronousEvents))
+  }
+
   // Sometimes setting up style triggers many changes in sequence
   // Eg. removing conflicting styles -> changing text -> applying spans
   // In such scenario we want to prevent from handling side effects (eg. onTextChanged)
@@ -561,6 +604,72 @@ class EnrichedTextInputView : AppCompatEditText {
     }
   }
 
+    private fun forceScrollToSelection() {
+      val textLayout = layout ?: return
+      val cursorOffset = selectionStart
+      if (cursorOffset <= 0) return
+
+      val selectedLineIndex = textLayout.getLineForOffset(cursorOffset)
+      val selectedLineTop = textLayout.getLineTop(selectedLineIndex)
+      val selectedLineBottom = textLayout.getLineBottom(selectedLineIndex)
+      val visibleTextHeight = height - paddingTop - paddingBottom
+
+      if (visibleTextHeight <= 0) return
+
+      val visibleTop = scrollY
+      val visibleBottom = scrollY + visibleTextHeight
+      var targetScrollY = scrollY
+
+      if (selectedLineTop < visibleTop) {
+        targetScrollY = selectedLineTop
+      } else if (selectedLineBottom > visibleBottom) {
+        targetScrollY = selectedLineBottom - visibleTextHeight
+      }
+
+      val maxScrollY = (textLayout.height - visibleTextHeight).coerceAtLeast(0)
+      targetScrollY = targetScrollY.coerceIn(0, maxScrollY)
+      scrollTo(scrollX, targetScrollY)
+    }
+
+  private fun reApplyHtmlStyleForSpans(previousHtmlStyle: HtmlStyle, nextHtmlStyle: HtmlStyle) {
+    val shouldRemoveBoldSpanFromH1Span = !previousHtmlStyle.h1Bold && nextHtmlStyle.h1Bold
+    val shouldRemoveBoldSpanFromH2Span = !previousHtmlStyle.h2Bold && nextHtmlStyle.h2Bold
+    val shouldRemoveBoldSpanFromH3Span = !previousHtmlStyle.h3Bold && nextHtmlStyle.h3Bold
+
+    val spannable = text as? Spannable ?: return
+    if (spannable.isEmpty()) return
+
+    var shouldEmitStateChange = false
+
+    runAsATransaction {
+      val spans = spannable.getSpans(0, spannable.length, EnrichedSpan::class.java)
+      for (span in spans) {
+        if (!span.dependsOnHtmlStyle) continue
+
+        val start = spannable.getSpanStart(span)
+        val end = spannable.getSpanEnd(span)
+        val flags = spannable.getSpanFlags(span)
+
+        if (start == -1 || end == -1) continue
+
+        if ((span is EnrichedH1Span && shouldRemoveBoldSpanFromH1Span) || (span is EnrichedH2Span && shouldRemoveBoldSpanFromH2Span) || (span is EnrichedH3Span && shouldRemoveBoldSpanFromH3Span)) {
+          val isRemoved = removeStyle(EnrichedSpans.BOLD, start, end)
+          if (isRemoved) shouldEmitStateChange = true
+        }
+
+        spannable.removeSpan(span)
+        val newSpan = span.rebuildWithStyle(htmlStyle)
+        spannable.setSpan(newSpan, start, end, flags)
+      }
+
+      if (shouldEmitStateChange) {
+        selection?.validateStyles()
+      }
+    }
+    layoutManager.invalidateLayout()
+    forceScrollToSelection()
+  }
+
   override fun onAttachedToWindow() {
     super.onAttachedToWindow()
 
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewManager.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewManager.kt
index 286a19b..8c629cf 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewManager.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewManager.kt
@@ -24,6 +24,7 @@ import com.swmansion.enriched.events.OnInputFocusEvent
 import com.swmansion.enriched.events.OnLinkDetectedEvent
 import com.swmansion.enriched.events.OnMentionDetectedEvent
 import com.swmansion.enriched.events.OnMentionEvent
+import com.swmansion.enriched.events.OnRequestHtmlResultEvent
 import com.swmansion.enriched.spans.EnrichedSpans
 import com.swmansion.enriched.styles.HtmlStyle
 import com.swmansion.enriched.utils.jsonStringToStringMap
@@ -71,6 +72,7 @@ class EnrichedTextInputViewManager : SimpleViewManager<EnrichedTextInputView>(),
      map.put(OnMentionDetectedEvent.EVENT_NAME, mapOf("registrationName" to OnMentionDetectedEvent.EVENT_NAME))
      map.put(OnMentionEvent.EVENT_NAME, mapOf("registrationName" to OnMentionEvent.EVENT_NAME))
      map.put(OnChangeSelectionEvent.EVENT_NAME, mapOf("registrationName" to OnChangeSelectionEvent.EVENT_NAME))
+     map.put(OnRequestHtmlResultEvent.EVENT_NAME, mapOf("registrationName" to OnRequestHtmlResultEvent.EVENT_NAME))
 
      return map
    }
@@ -177,7 +179,7 @@ class EnrichedTextInputViewManager : SimpleViewManager<EnrichedTextInputView>(),
   }
 
   override fun setIsOnChangeHtmlSet(view: EnrichedTextInputView?, value: Boolean) {
-    // this prop isn't used on Android as of now, but the setter must be present
+    view?.shouldEmitHtml = value
   }
 
   override fun setAutoCapitalize(view: EnrichedTextInputView?, flag: String?) {
@@ -255,8 +257,8 @@ class EnrichedTextInputViewManager : SimpleViewManager<EnrichedTextInputView>(),
     view?.addLink(start, end, text, url)
   }
 
-  override fun addImage(view: EnrichedTextInputView?, src: String) {
-    view?.addImage(src)
+  override fun addImage(view: EnrichedTextInputView?, src: String, width: Float, height: Float) {
+    view?.addImage(src, width, height)
   }
 
   override fun startMention(view: EnrichedTextInputView?, indicator: String) {
@@ -268,6 +270,10 @@ class EnrichedTextInputViewManager : SimpleViewManager<EnrichedTextInputView>(),
     view?.addMention(text, indicator, attributes)
   }
 
+  override fun requestHTML(view: EnrichedTextInputView?, requestId: Int) {
+    view?.requestHTML(requestId)
+  }
+
   override fun measure(
     context: Context,
     localData: ReadableMap?,
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewPackage.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewPackage.kt
index 3b93c12..8e9458b 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewPackage.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/EnrichedTextInputViewPackage.kt
@@ -4,10 +4,12 @@ import com.facebook.react.ReactPackage
 import com.facebook.react.bridge.NativeModule
 import com.facebook.react.bridge.ReactApplicationContext
 import com.facebook.react.uimanager.ViewManager
+import com.swmansion.enriched.utils.ResourceManager
 import java.util.ArrayList
 
 class EnrichedTextInputViewPackage : ReactPackage {
   override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
+    ResourceManager.init(reactContext.applicationContext)
     val viewManagers: MutableList<ViewManager<*, *>> = ArrayList()
     viewManagers.add(EnrichedTextInputViewManager())
     return viewManagers
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/MentionHandler.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/MentionHandler.kt
index 874b312..bac63d8 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/MentionHandler.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/MentionHandler.kt
@@ -9,8 +9,8 @@ class MentionHandler(private val view: EnrichedTextInputView) {
   private var previousIndicator: String? = null
 
   fun reset() {
+    endMention()
     previousText = null
-    previousIndicator = null
   }
 
   fun endMention() {
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/OnRequestHtmlResultEvent.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/OnRequestHtmlResultEvent.kt
new file mode 100644
index 0000000..bda88e7
--- /dev/null
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/events/OnRequestHtmlResultEvent.kt
@@ -0,0 +1,33 @@
+package com.swmansion.enriched.events
+
+import com.facebook.react.bridge.Arguments
+import com.facebook.react.bridge.WritableMap
+import com.facebook.react.uimanager.events.Event
+
+class OnRequestHtmlResultEvent(
+  surfaceId: Int,
+  viewId: Int,
+  private val requestId: Int,
+  private val html: String?,
+  private val experimentalSynchronousEvents: Boolean
+) : Event<OnRequestHtmlResultEvent>(surfaceId, viewId) {
+
+  override fun getEventName(): String = EVENT_NAME
+
+  override fun getEventData(): WritableMap {
+    val eventData: WritableMap = Arguments.createMap()
+    eventData.putInt("requestId", requestId)
+    if (html != null) {
+      eventData.putString("html", html)
+    } else {
+      eventData.putNull("html")
+    }
+    return eventData
+  }
+
+  override fun experimental_isSynchronous(): Boolean = experimentalSynchronousEvents
+
+  companion object {
+    const val EVENT_NAME: String = "onRequestHtmlResult"
+  }
+}
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBlockQuoteSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBlockQuoteSpan.kt
index 405f16e..33e2e61 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBlockQuoteSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBlockQuoteSpan.kt
@@ -11,6 +11,8 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 // https://android.googlesource.com/platform/frameworks/base/+/refs/heads/main/core/java/android/text/style/QuoteSpan.java
 class EnrichedBlockQuoteSpan(private val htmlStyle: HtmlStyle) : MetricAffectingSpan(), LeadingMarginSpan, EnrichedBlockSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateMeasureState(p0: TextPaint) {
     // Do nothing, but inform layout that this span affects text metrics
   }
@@ -35,4 +37,8 @@ class EnrichedBlockQuoteSpan(private val htmlStyle: HtmlStyle) : MetricAffecting
       textPaint?.color = color
     }
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedBlockQuoteSpan {
+    return EnrichedBlockQuoteSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBoldSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBoldSpan.kt
index 72a5d4e..e3c27ef 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBoldSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedBoldSpan.kt
@@ -2,9 +2,15 @@ package com.swmansion.enriched.spans
 
 import android.graphics.Typeface
 import android.text.style.StyleSpan
+import com.swmansion.enriched.spans.interfaces.EnrichedBlockSpan
 import com.swmansion.enriched.spans.interfaces.EnrichedInlineSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 @Suppress("UNUSED_PARAMETER")
 class EnrichedBoldSpan(htmlStyle: HtmlStyle) : StyleSpan(Typeface.BOLD), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = false
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedBoldSpan {
+    return EnrichedBoldSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedCodeBlockSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedCodeBlockSpan.kt
index 2ff064b..caf93aa 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedCodeBlockSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedCodeBlockSpan.kt
@@ -2,8 +2,10 @@ package com.swmansion.enriched.spans
 
 import android.graphics.Canvas
 import android.graphics.Paint
+import android.graphics.Path
 import android.graphics.RectF
 import android.graphics.Typeface
+import android.text.Spanned
 import android.text.TextPaint
 import android.text.style.LineBackgroundSpan
 import android.text.style.MetricAffectingSpan
@@ -11,6 +13,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedBlockSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedCodeBlockSpan(private val htmlStyle: HtmlStyle) : MetricAffectingSpan(), LineBackgroundSpan, EnrichedBlockSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateDrawState(paint: TextPaint) {
     paint.typeface = Typeface.MONOSPACE
     paint.color = htmlStyle.codeBlockColor
@@ -33,10 +37,47 @@ class EnrichedCodeBlockSpan(private val htmlStyle: HtmlStyle) : MetricAffectingS
     end: Int,
     lineNum: Int
   ) {
+    if (text !is Spanned) {
+      return
+    }
+
     val previousColor = p.color
     p.color = htmlStyle.codeBlockBackgroundColor
+
+    val radius = htmlStyle.codeBlockRadius
+
+    val spanStart = text.getSpanStart(this)
+    val spanEnd = text.getSpanEnd(this)
+    val isFirstLineOfSpan = start == spanStart
+    val isLastLineOfSpan = end == spanEnd || (spanEnd + 1 == end && text[spanEnd] == '\n')
+
+    val path = Path()
+    val radii = floatArrayOf(0f, 0f, 0f, 0f, 0f, 0f, 0f, 0f)
+
+    if (isFirstLineOfSpan) {
+      // Top-Left and Top-Right corners
+      radii[0] = radius
+      radii[1] = radius
+      radii[2] = radius
+      radii[3] = radius
+    }
+
+    if (isLastLineOfSpan) {
+      // Bottom-Right and Bottom-Left corners
+      radii[4] = radius
+      radii[5] = radius
+      radii[6] = radius
+      radii[7] = radius
+    }
+
     val rect = RectF(left.toFloat(), top.toFloat(), right.toFloat(), bottom.toFloat())
-    canvas.drawRoundRect(rect, htmlStyle.codeBlockRadius, htmlStyle.codeBlockRadius, p)
+
+    path.addRoundRect(rect, radii, Path.Direction.CW)
+    canvas.drawPath(path, p)
     p.color = previousColor
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedCodeBlockSpan {
+    return EnrichedCodeBlockSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH1Span.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH1Span.kt
index c2b28e3..551ade0 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH1Span.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH1Span.kt
@@ -7,6 +7,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedHeadingSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedH1Span(private val style: HtmlStyle) : AbsoluteSizeSpan(style.h1FontSize), EnrichedHeadingSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateDrawState(tp: TextPaint) {
     super.updateDrawState(tp)
     val bold = style.h1Bold
@@ -14,4 +16,8 @@ class EnrichedH1Span(private val style: HtmlStyle) : AbsoluteSizeSpan(style.h1Fo
       tp.typeface = Typeface.create(tp.typeface, Typeface.BOLD)
     }
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedH1Span {
+    return EnrichedH1Span(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH2Span.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH2Span.kt
index 736fe08..581a226 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH2Span.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH2Span.kt
@@ -7,6 +7,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedHeadingSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedH2Span(private val htmlStyle: HtmlStyle) : AbsoluteSizeSpan(htmlStyle.h2FontSize), EnrichedHeadingSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateDrawState(tp: TextPaint) {
     super.updateDrawState(tp)
     val bold = htmlStyle.h2Bold
@@ -14,4 +16,8 @@ class EnrichedH2Span(private val htmlStyle: HtmlStyle) : AbsoluteSizeSpan(htmlSt
       tp.typeface = Typeface.create(tp.typeface, Typeface.BOLD)
     }
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedH2Span {
+    return EnrichedH2Span(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH3Span.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH3Span.kt
index 151acf6..ae8ac39 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH3Span.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedH3Span.kt
@@ -7,6 +7,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedHeadingSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedH3Span(private val htmlStyle: HtmlStyle) : AbsoluteSizeSpan(htmlStyle.h3FontSize), EnrichedHeadingSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateDrawState(tp: TextPaint) {
     super.updateDrawState(tp)
     val bold = htmlStyle.h3Bold
@@ -14,4 +16,8 @@ class EnrichedH3Span(private val htmlStyle: HtmlStyle) : AbsoluteSizeSpan(htmlSt
       tp.typeface = Typeface.create(tp.typeface, Typeface.BOLD)
     }
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedH3Span {
+    return EnrichedH3Span(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedImageSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedImageSpan.kt
index 708050d..951efe5 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedImageSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedImageSpan.kt
@@ -1,24 +1,35 @@
 package com.swmansion.enriched.spans
 
-import android.content.Context
+import android.annotation.SuppressLint
+import android.content.res.Resources
+import android.graphics.BitmapFactory
 import android.graphics.Canvas
 import android.graphics.Paint
+import android.graphics.drawable.BitmapDrawable
 import android.graphics.drawable.Drawable
-import android.net.Uri
+import android.text.Editable
+import android.text.Spannable
 import android.text.style.ImageSpan
+import android.util.Log
+import androidx.core.graphics.drawable.DrawableCompat
 import androidx.core.graphics.withSave
 import com.swmansion.enriched.spans.interfaces.EnrichedInlineSpan
+import com.swmansion.enriched.utils.AsyncDrawable
+import androidx.core.graphics.drawable.toDrawable
+import com.swmansion.enriched.R
+import com.swmansion.enriched.spans.utils.ForceRedrawSpan
 import com.swmansion.enriched.styles.HtmlStyle
+import com.swmansion.enriched.utils.ResourceManager
 
 class EnrichedImageSpan : ImageSpan, EnrichedInlineSpan {
-  private var htmlStyle: HtmlStyle? = null
+  override val dependsOnHtmlStyle: Boolean = false
 
-  constructor(context: Context, uri: Uri, htmlStyle: HtmlStyle, ) : super(context, uri, ALIGN_BASELINE) {
-    this.htmlStyle = htmlStyle
-  }
+  private var width: Int = 0
+  private var height: Int = 0
 
-  constructor(drawable: Drawable, source: String, htmlStyle: HtmlStyle) : super(drawable, source, ALIGN_BASELINE) {
-    this.htmlStyle = htmlStyle
+  constructor(drawable: Drawable, source: String, width: Int, height: Int) : super(drawable, source, ALIGN_BASELINE) {
+    this.width = width
+    this.height = height
   }
 
   override fun draw(
@@ -35,7 +46,122 @@ class EnrichedImageSpan : ImageSpan, EnrichedInlineSpan {
 
   override fun getDrawable(): Drawable {
     val drawable = super.getDrawable()
-    drawable.setBounds(0, 0, htmlStyle!!.imgWidth, htmlStyle!!.imgHeight)
+    val scale = Resources.getSystem().displayMetrics.density
+
+    drawable.setBounds(0, 0, (width * scale).toInt() , (height * scale).toInt())
     return drawable
   }
+
+  override fun getSize(
+    paint: Paint,
+    text: CharSequence?,
+    start: Int,
+    end: Int,
+    fm: Paint.FontMetricsInt?
+  ): Int {
+    val d = drawable
+    val rect = d.bounds
+
+    if (fm != null) {
+      val imageHeight = rect.bottom - rect.top
+
+      // We want the image bottom to sit on the baseline (0).
+      // Therefore, the image top will be at: -imageHeight.
+      val targetTop = -imageHeight
+
+      // Expand the line UPWARDS if the image is taller than the current font
+      if (targetTop < fm.ascent) {
+        fm.ascent = targetTop
+        fm.top = targetTop
+      }
+    }
+
+    return rect.right
+  }
+
+  private fun registerDrawableLoadCallback (d: AsyncDrawable, text: Editable?) {
+    d.onLoaded = onLoaded@{
+      val spannable = text as? Spannable
+
+      if (spannable == null) {
+        return@onLoaded
+      }
+
+      val start = spannable.getSpanStart(this@EnrichedImageSpan)
+      val end = spannable.getSpanEnd(this@EnrichedImageSpan)
+
+      if (start != -1 && end != -1) {
+        // trick for adding empty span to force redraw when image is loaded
+        val redrawSpan = ForceRedrawSpan()
+        spannable.setSpan(redrawSpan, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
+        spannable.removeSpan(redrawSpan)
+      }
+    }
+  }
+
+  fun observeAsyncDrawableLoaded(text: Editable?) {
+    val d = drawable
+
+    if (d !is AsyncDrawable) {
+      return
+    }
+
+    registerDrawableLoadCallback(d, text)
+
+    // If it's already loaded (race condition), run logic immediately
+    if (d.isLoaded) {
+      d.onLoaded?.invoke()
+    }
+  }
+
+  fun getWidth(): Int {
+    return width
+  }
+
+  fun getHeight(): Int {
+    return height
+  }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedImageSpan = this
+
+  companion object {
+    fun createEnrichedImageSpan(src: String, width: Int, height: Int): EnrichedImageSpan {
+      var imgDrawable = prepareDrawableForImage(src)
+
+      if (imgDrawable == null) {
+        imgDrawable = ResourceManager.getDrawableResource(R.drawable.broken_image)
+      }
+
+      return EnrichedImageSpan(imgDrawable, src, width, height)
+    }
+
+    private fun prepareDrawableForImage(src: String): Drawable? {
+      var cleanPath = src
+
+      if (cleanPath.startsWith("http://") || cleanPath.startsWith("https://")) {
+        return AsyncDrawable(cleanPath)
+      }
+
+      if (cleanPath.startsWith("file://")) {
+        cleanPath = cleanPath.substring(7)
+      }
+
+      var drawable: BitmapDrawable? = null
+
+      try {
+        val bitmap = BitmapFactory.decodeFile(cleanPath)
+        if (bitmap != null) {
+          drawable = bitmap.toDrawable(Resources.getSystem())
+          // set bounds so it knows how big it is naturally,
+          // though EnrichedImageSpan will override this with the HTML width/height later.
+          drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight())
+        }
+      } catch (e: Exception) {
+        // Failed to load file
+        Log.e("EnrichedImageSpan", "Failed to load image from path: $cleanPath", e)
+      }
+
+      return drawable
+    }
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedInlineCodeSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedInlineCodeSpan.kt
index 8c9717e..cf69612 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedInlineCodeSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedInlineCodeSpan.kt
@@ -7,6 +7,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedInlineSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedInlineCodeSpan(private val htmlStyle: HtmlStyle) : MetricAffectingSpan(), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateDrawState(textPaint: TextPaint) {
     val typeface = Typeface.create(Typeface.MONOSPACE, Typeface.NORMAL)
     textPaint.typeface = typeface
@@ -18,4 +20,8 @@ class EnrichedInlineCodeSpan(private val htmlStyle: HtmlStyle) : MetricAffecting
     val typeface = Typeface.create(Typeface.MONOSPACE, Typeface.NORMAL)
     textPaint.typeface = typeface
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedInlineCodeSpan {
+    return EnrichedInlineCodeSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedItalicSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedItalicSpan.kt
index 3d44f9e..e89974e 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedItalicSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedItalicSpan.kt
@@ -7,4 +7,9 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 @Suppress("UNUSED_PARAMETER")
 class EnrichedItalicSpan(private val htmlStyle: HtmlStyle) : StyleSpan(Typeface.ITALIC), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = false
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedItalicSpan {
+    return EnrichedItalicSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedLinkSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedLinkSpan.kt
index b8a9636..8ac9d1b 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedLinkSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedLinkSpan.kt
@@ -7,6 +7,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedInlineSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedLinkSpan(private val url: String, private val htmlStyle: HtmlStyle) : ClickableSpan(), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun onClick(view: View) {
     // Do nothing, links inside the input are not clickable.
     // We are using `ClickableSpan` to allow the text to be styled as a link.
@@ -21,4 +23,8 @@ class EnrichedLinkSpan(private val url: String, private val htmlStyle: HtmlStyle
   fun getUrl(): String {
     return url
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedLinkSpan {
+    return EnrichedLinkSpan(url, htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedMentionSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedMentionSpan.kt
index f28925b..1bef8da 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedMentionSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedMentionSpan.kt
@@ -8,6 +8,8 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedMentionSpan(private val text: String, private val indicator: String, private val attributes: Map<String, String>, private val htmlStyle: HtmlStyle) :
   ClickableSpan(), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun onClick(view: View) {
     // Do nothing. Mentions inside the input are not clickable.
     // We are using `ClickableSpan` to allow the text to be styled as a clickable element.
@@ -33,4 +35,8 @@ class EnrichedMentionSpan(private val text: String, private val indicator: Strin
   fun getIndicator(): String {
     return indicator
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedMentionSpan {
+    return EnrichedMentionSpan(text, indicator, attributes, htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedOrderedListSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedOrderedListSpan.kt
index 55b9167..b335ecf 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedOrderedListSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedOrderedListSpan.kt
@@ -11,6 +11,8 @@ import com.swmansion.enriched.spans.interfaces.EnrichedParagraphSpan
 import com.swmansion.enriched.styles.HtmlStyle
 
 class EnrichedOrderedListSpan(private var index: Int, private val htmlStyle: HtmlStyle) : MetricAffectingSpan(), LeadingMarginSpan, EnrichedParagraphSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateMeasureState(p0: TextPaint) {
     // Do nothing, but inform layout that this span affects text metrics
   }
@@ -78,4 +80,8 @@ class EnrichedOrderedListSpan(private var index: Int, private val htmlStyle: Htm
   fun setIndex(i: Int) {
     index = i
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedOrderedListSpan {
+    return EnrichedOrderedListSpan(index, htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedSpans.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedSpans.kt
index ef1b408..7883c63 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedSpans.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedSpans.kt
@@ -2,9 +2,13 @@ package com.swmansion.enriched.spans
 
 import com.swmansion.enriched.styles.HtmlStyle
 
-data class BaseSpanConfig(val clazz: Class<*>)
-data class ParagraphSpanConfig(val clazz: Class<*>, val isContinuous: Boolean)
-data class ListSpanConfig(val clazz: Class<*>, val shortcut: String)
+interface ISpanConfig {
+  val clazz: Class<*>
+}
+
+data class BaseSpanConfig(override  val clazz: Class<*>): ISpanConfig
+data class ParagraphSpanConfig(override  val clazz: Class<*>, val isContinuous: Boolean): ISpanConfig
+data class ListSpanConfig(override val clazz: Class<*>, val shortcut: String) : ISpanConfig
 
 data class StylesMergingConfig(
   // styles that should be removed when we apply specific style
@@ -64,6 +68,8 @@ object EnrichedSpans {
     MENTION to BaseSpanConfig(EnrichedMentionSpan::class.java),
   )
 
+  val allSpans: Map<String, ISpanConfig> = inlineSpans + paragraphSpans + listSpans + parametrizedStyles
+
   fun getMergingConfigForStyle(style: String, htmlStyle: HtmlStyle): StylesMergingConfig? {
     return when (style) {
       BOLD -> {
@@ -123,4 +129,8 @@ object EnrichedSpans {
       else -> null
     }
   }
+
+  fun isTypeContinuous(type: Class<*>): Boolean {
+    return paragraphSpans.values.find { it.clazz == type }?.isContinuous == true
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedStrikeThroughSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedStrikeThroughSpan.kt
index 46ad5fc..7a56454 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedStrikeThroughSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedStrikeThroughSpan.kt
@@ -6,4 +6,9 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 @Suppress("UNUSED_PARAMETER")
 class EnrichedStrikeThroughSpan(private val htmlStyle: HtmlStyle) : StrikethroughSpan(), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = false
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedStrikeThroughSpan {
+    return EnrichedStrikeThroughSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnderlineSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnderlineSpan.kt
index 977388c..66c5b8b 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnderlineSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnderlineSpan.kt
@@ -6,4 +6,9 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 @Suppress("UNUSED_PARAMETER")
 class EnrichedUnderlineSpan(private val htmlStyle: HtmlStyle) : UnderlineSpan(), EnrichedInlineSpan {
+  override val dependsOnHtmlStyle: Boolean = false
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedUnderlineSpan {
+    return EnrichedUnderlineSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnorderedListSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnorderedListSpan.kt
index 9235a8b..e7bbd4b 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnorderedListSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/EnrichedUnorderedListSpan.kt
@@ -12,6 +12,8 @@ import com.swmansion.enriched.styles.HtmlStyle
 
 // https://android.googlesource.com/platform/frameworks/base/+/refs/heads/main/core/java/android/text/style/BulletSpan.java
 class EnrichedUnorderedListSpan(private val htmlStyle: HtmlStyle) : MetricAffectingSpan(), LeadingMarginSpan, EnrichedParagraphSpan {
+  override val dependsOnHtmlStyle: Boolean = true
+
   override fun updateMeasureState(p0: TextPaint) {
     // Do nothing, but inform layout that this span affects text metrics
   }
@@ -56,4 +58,8 @@ class EnrichedUnorderedListSpan(private val htmlStyle: HtmlStyle) : MetricAffect
       paint.style = style
     }
   }
+
+  override fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedUnorderedListSpan {
+    return EnrichedUnorderedListSpan(htmlStyle)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/interfaces/EnrichedSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/interfaces/EnrichedSpan.kt
index 5a5de53..50c2f07 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/interfaces/EnrichedSpan.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/interfaces/EnrichedSpan.kt
@@ -1,4 +1,8 @@
 package com.swmansion.enriched.spans.interfaces
 
+import com.swmansion.enriched.styles.HtmlStyle
+
 interface EnrichedSpan {
+  val dependsOnHtmlStyle: Boolean
+  fun rebuildWithStyle(htmlStyle: HtmlStyle): EnrichedSpan
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/utils/ForceRedrawSpan.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/utils/ForceRedrawSpan.kt
new file mode 100644
index 0000000..f83e6b7
--- /dev/null
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/spans/utils/ForceRedrawSpan.kt
@@ -0,0 +1,13 @@
+package com.swmansion.enriched.spans.utils
+
+import android.text.TextPaint
+import android.text.style.MetricAffectingSpan
+
+class ForceRedrawSpan:  MetricAffectingSpan() {
+  override fun updateMeasureState(tp: TextPaint) {
+    // Do nothing, we don't actually want to change how it looks
+  }
+  override fun updateDrawState(tp: TextPaint?) {
+    // Do nothing
+  }
+}
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/HtmlStyle.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/HtmlStyle.kt
index 8a4b908..5643d40 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/HtmlStyle.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/HtmlStyle.kt
@@ -43,9 +43,6 @@ class HtmlStyle {
   var ulBulletSize: Int = 8
   var ulBulletColor: Int = Color.BLACK
 
-  var imgWidth: Int = 200
-  var imgHeight: Int = 200
-
   var aColor: Int = Color.BLACK
   var aUnderline: Boolean = true
 
@@ -100,10 +97,6 @@ class HtmlStyle {
     ulMarginLeft = parseFloat(ulStyle, "marginLeft").toInt()
     ulBulletSize = parseFloat(ulStyle, "bulletSize").toInt()
 
-    val imgStyle = style.getMap("img")
-    imgWidth = parseFloat(imgStyle, "width").toInt()
-    imgHeight = parseFloat(imgStyle, "height").toInt()
-
     val aStyle = style.getMap("a")
     aColor = parseColor(aStyle, "color")
     aUnderline = parseIsUnderline(aStyle)
@@ -124,8 +117,8 @@ class HtmlStyle {
   private fun parseFloat(map: ReadableMap?, key: String): Float {
     val safeMap = ensureValueIsSet(map, key)
 
-    val fontSize = safeMap.getDouble(key)
-    return ceil(PixelUtil.toPixelFromSP(fontSize))
+    val value = safeMap.getDouble(key)
+    return ceil(PixelUtil.toPixelFromSP(value))
   }
 
   private fun parseColorWithOpacity(map: ReadableMap?, key: String, opacity: Int): Int {
@@ -219,6 +212,84 @@ class HtmlStyle {
     return parseFontWeight(fontWeight)
   }
 
+  override fun equals(other: Any?): Boolean {
+    if (this === other) return true
+    if (other !is HtmlStyle) return false
+
+    return h1FontSize == other.h1FontSize &&
+      h1Bold == other.h1Bold &&
+      h2FontSize == other.h2FontSize &&
+      h2Bold == other.h2Bold &&
+      h3FontSize == other.h3FontSize &&
+      h3Bold == other.h3Bold &&
+
+      blockquoteColor == other.blockquoteColor &&
+      blockquoteBorderColor == other.blockquoteBorderColor &&
+      blockquoteStripeWidth == other.blockquoteStripeWidth &&
+      blockquoteGapWidth == other.blockquoteGapWidth &&
+
+      olGapWidth == other.olGapWidth &&
+      olMarginLeft == other.olMarginLeft &&
+      olMarkerFontWeight == other.olMarkerFontWeight &&
+      olMarkerColor == other.olMarkerColor &&
+
+      ulGapWidth == other.ulGapWidth &&
+      ulMarginLeft == other.ulMarginLeft &&
+      ulBulletSize == other.ulBulletSize &&
+      ulBulletColor == other.ulBulletColor &&
+
+      aColor == other.aColor &&
+      aUnderline == other.aUnderline &&
+
+      codeBlockColor == other.codeBlockColor &&
+      codeBlockBackgroundColor == other.codeBlockBackgroundColor &&
+      codeBlockRadius == other.codeBlockRadius &&
+
+      inlineCodeColor == other.inlineCodeColor &&
+      inlineCodeBackgroundColor == other.inlineCodeBackgroundColor &&
+
+      mentionsStyle == other.mentionsStyle
+  }
+
+
+  override fun hashCode(): Int {
+    var result = h1FontSize.hashCode()
+    result = 31 * result + h1Bold.hashCode()
+    result = 31 * result + h2FontSize.hashCode()
+    result = 31 * result + h2Bold.hashCode()
+    result = 31 * result + h3FontSize.hashCode()
+    result = 31 * result + h3Bold.hashCode()
+
+    result = 31 * result + (blockquoteColor ?: 0)
+    result = 31 * result + blockquoteBorderColor.hashCode()
+    result = 31 * result + blockquoteStripeWidth.hashCode()
+    result = 31 * result + blockquoteGapWidth.hashCode()
+
+    result = 31 * result + olGapWidth.hashCode()
+    result = 31 * result + olMarginLeft.hashCode()
+    result = 31 * result + (olMarkerFontWeight?.hashCode() ?: 0)
+    result = 31 * result + (olMarkerColor ?: 0)
+
+    result = 31 * result + ulGapWidth.hashCode()
+    result = 31 * result + ulMarginLeft.hashCode()
+    result = 31 * result + ulBulletSize.hashCode()
+    result = 31 * result + ulBulletColor.hashCode()
+
+    result = 31 * result + aColor.hashCode()
+    result = 31 * result + aUnderline.hashCode()
+
+    result = 31 * result + codeBlockColor.hashCode()
+    result = 31 * result + codeBlockBackgroundColor.hashCode()
+    result = 31 * result + codeBlockRadius.hashCode()
+
+    result = 31 * result + inlineCodeColor.hashCode()
+    result = 31 * result + inlineCodeBackgroundColor.hashCode()
+
+    result = 31 * result + mentionsStyle.hashCode()
+
+    return result
+  }
+
   companion object {
     data class MentionStyle(
       val color: Int,
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/InlineStyles.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/InlineStyles.kt
index 41581c0..1b92494 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/InlineStyles.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/InlineStyles.kt
@@ -54,6 +54,7 @@ class InlineStyles(private val view: EnrichedTextInputView) {
       val spanEnd = spannable.getSpanEnd(span)
       var finalStart: Int? = null
       var finalEnd: Int? = null
+      if (spanStart == -1 || spanEnd == -1) continue
 
       spannable.removeSpan(span)
 
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParagraphStyles.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParagraphStyles.kt
index 2d3d0b8..ea90844 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParagraphStyles.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParagraphStyles.kt
@@ -3,13 +3,85 @@ package com.swmansion.enriched.styles
 import android.text.Editable
 import android.text.Spannable
 import android.text.SpannableStringBuilder
+import android.util.Log
 import com.swmansion.enriched.EnrichedTextInputView
 import com.swmansion.enriched.spans.EnrichedSpans
+import com.swmansion.enriched.spans.interfaces.EnrichedSpan
 import com.swmansion.enriched.utils.getParagraphBounds
 import com.swmansion.enriched.utils.getSafeSpanBoundaries
 
 class ParagraphStyles(private val view: EnrichedTextInputView) {
+  private fun <T>getPreviousParagraphSpan(spannable: Spannable, paragraphStart: Int, type: Class<T>): T? {
+    if (paragraphStart <= 0) return null
+
+    val (previousParagraphStart, previousParagraphEnd) = spannable.getParagraphBounds(paragraphStart - 1)
+    val spans = spannable.getSpans(previousParagraphStart, previousParagraphEnd, type)
+
+    // A paragraph implies a single cohesive style. having multiple spans of the
+    // same type (e.g., two codeblock spans) in one paragraph is an invalid state in current library logic
+    if (spans.size > 1) {
+      Log.w("ParagraphStyles", "getPreviousParagraphSpan(): Found more than one span in the paragraph!")
+    }
+
+    if (spans.isNotEmpty()) {
+      return spans.first()
+    }
+
+    return null
+  }
+
+  private fun <T>getNextParagraphSpan(spannable: Spannable, paragraphEnd: Int, type: Class<T>): T? {
+    if (paragraphEnd >= spannable.length - 1) return null
+
+    val (nextParagraphStart, nextParagraphEnd) = spannable.getParagraphBounds(paragraphEnd + 1)
+
+    val spans = spannable.getSpans(nextParagraphStart, nextParagraphEnd, type)
+
+    // A paragraph implies a single cohesive style. having multiple spans of the
+    // same type (e.g., two codeblock spans) in one paragraph is an invalid state in current library logic
+    if (spans.size > 1) {
+      Log.w("ParagraphStyles", "getNextParagraphSpan(): Found more than one span in the paragraph!")
+    }
+
+    if (spans.isNotEmpty()) {
+      return spans.first()
+    }
+
+    return null
+  }
+
+  /**
+   * Applies a continuous span to the specified range.
+   * If the new range touches existing continuous spans, they are coalesced into a single span
+   */
+  private fun <T>setContinuousSpan(spannable: Spannable, start: Int, end: Int, type: Class<T>) {
+    val span = type.getDeclaredConstructor(HtmlStyle::class.java).newInstance(view.htmlStyle)
+    val previousSpan = getPreviousParagraphSpan(spannable, start, type)
+    val nextSpan = getNextParagraphSpan(spannable, end, type)
+    var newStart = start
+    var newEnd = end
+
+    if (previousSpan != null) {
+      newStart = spannable.getSpanStart(previousSpan)
+      spannable.removeSpan(previousSpan)
+    }
+
+    if (nextSpan != null && start != end) {
+      newEnd = spannable.getSpanEnd(nextSpan)
+      spannable.removeSpan(nextSpan)
+    }
+
+    val (safeStart, safeEnd) = spannable.getSafeSpanBoundaries(newStart, newEnd)
+    spannable.setSpan(span, safeStart, safeEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
+  }
+
+
   private fun <T>setSpan(spannable: Spannable, type: Class<T>, start: Int, end: Int) {
+    if (EnrichedSpans.isTypeContinuous(type)) {
+      setContinuousSpan(spannable, start, end, type)
+      return
+    }
+
     val span = type.getDeclaredConstructor(HtmlStyle::class.java).newInstance(view.htmlStyle)
     val (safeStart, safeEnd) = spannable.getSafeSpanBoundaries(start, end)
     spannable.setSpan(span, safeStart, safeEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
@@ -94,14 +166,116 @@ class ParagraphStyles(private val view: EnrichedTextInputView) {
     return spans.isNotEmpty()
   }
 
+  private fun <T>mergeAdjacentStyleSpans(s: Editable, endCursorPosition: Int, type: Class<T>) {
+    val (start, end) = s.getParagraphBounds(endCursorPosition)
+    val currParagraphSpans = s.getSpans(start, end, type)
+
+    if (currParagraphSpans.isEmpty()) {
+      return
+    }
+
+    val currSpan = currParagraphSpans[0]
+    val nextSpan = getNextParagraphSpan(s, end, type)
+
+    if (nextSpan == null) {
+      return
+    }
+
+    val newStart = s.getSpanStart(currSpan)
+    val newEnd = s.getSpanEnd(nextSpan)
+
+    s.removeSpan(nextSpan)
+    s.removeSpan(currSpan)
+
+    val (safeStart, safeEnd) = s.getSafeSpanBoundaries(newStart, newEnd)
+    val span = type.getDeclaredConstructor(HtmlStyle::class.java).newInstance(view.htmlStyle)
+
+    s.setSpan(span, safeStart, safeEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
+  }
+
+  private fun handleConflictsDuringNewlineDeletion(s: Editable, style: String, paragraphStart: Int, paragraphEnd: Int): Boolean {
+    val spanState = view.spanState ?: return false
+    val mergingConfig = EnrichedSpans.getMergingConfigForStyle(style, view.htmlStyle) ?: return false
+    var isConflicting = false
+    val stylesToCheck = mergingConfig.blockingStyles + mergingConfig.conflictingStyles
+
+    for (styleToCheck in stylesToCheck) {
+      val conflictingType = EnrichedSpans.allSpans[styleToCheck]?.clazz ?: continue
+
+      val spans = s.getSpans(paragraphStart, paragraphEnd, conflictingType)
+      if (spans.isEmpty()) {
+        continue
+      }
+      isConflicting = true
+
+      val isParagraphStyle = EnrichedSpans.paragraphSpans[styleToCheck] != null
+      if (!isParagraphStyle) {
+        continue
+      }
+
+      for (span in spans) {
+        extendStyleOnWholeParagraph(s, span as EnrichedSpan, conflictingType, paragraphEnd)
+      }
+    }
+
+    if (isConflicting) {
+      val styleStart =  spanState.getStart(style) ?: return false
+      spanState.setStart(style, null)
+      removeStyle(style, styleStart, paragraphEnd)
+      return true
+    }
+
+    return false
+  }
+
+
+  private fun deleteConflictingAndBlockingStyles(s: Editable, style: String, paragraphStart: Int, paragraphEnd: Int) {
+    val mergingConfig = EnrichedSpans.getMergingConfigForStyle(style, view.htmlStyle) ?: return
+    val stylesToCheck = mergingConfig.blockingStyles + mergingConfig.conflictingStyles
+
+    for (styleToCheck in stylesToCheck) {
+      val conflictingType = EnrichedSpans.allSpans[styleToCheck]?.clazz ?: continue
+
+      val spans = s.getSpans(paragraphStart, paragraphEnd, conflictingType)
+      for (span in spans) {
+        s.removeSpan(span)
+      }
+    }
+  }
+
+  private fun <T>extendStyleOnWholeParagraph(s: Editable, span: EnrichedSpan, type: Class<T>, paragraphEnd: Int) {
+    val currStyleStart = s.getSpanStart(span)
+    s.removeSpan(span)
+    val (safeStart, safeEnd) = s.getSafeSpanBoundaries(currStyleStart, paragraphEnd)
+    setSpan(s, type, safeStart, safeEnd)
+  }
+
   fun afterTextChanged(s: Editable, endPosition: Int, previousTextLength: Int) {
     var endCursorPosition = endPosition
     val isBackspace = s.length < previousTextLength
     val isNewLine = endCursorPosition == 0 || endCursorPosition > 0 && s[endCursorPosition - 1] == '\n'
+    val spanState = view.spanState ?: return
 
     for ((style, config) in EnrichedSpans.paragraphSpans) {
-      val spanState = view.spanState ?: continue
-      val styleStart = spanState.getStart(style) ?: continue
+      val styleStart = spanState.getStart(style)
+
+      if (styleStart == null) {
+        if (isBackspace) {
+          val (start, end) = s.getParagraphBounds(endCursorPosition)
+          val spans = s.getSpans(start, end, config.clazz)
+
+          for (span in spans) {
+            // handle conflicts when entering paragraph with some paragraph style applied
+            deleteConflictingAndBlockingStyles(s, style, start, end)
+            extendStyleOnWholeParagraph(s, span as EnrichedSpan, config.clazz, end)
+          }
+        }
+
+        if (config.isContinuous) {
+          mergeAdjacentStyleSpans(s, endCursorPosition, config.clazz)
+        }
+        continue
+      }
 
       if (isNewLine) {
         if (!config.isContinuous) {
@@ -111,7 +285,7 @@ class ParagraphStyles(private val view: EnrichedTextInputView) {
 
         if (isBackspace) {
           endCursorPosition -= 1
-          view.spanState.setStart(style, null)
+          spanState.setStart(style, null)
         } else {
           s.insert(endCursorPosition, "\u200B")
           endCursorPosition += 1
@@ -119,6 +293,15 @@ class ParagraphStyles(private val view: EnrichedTextInputView) {
       }
 
       var (start, end) = s.getParagraphBounds(styleStart, endCursorPosition)
+
+      // handle conflicts when deleting newline from paragraph style (going back to previous line)
+      if (isBackspace && styleStart != start) {
+        val isConflicting = handleConflictsDuringNewlineDeletion(s, style, start, end)
+        if (isConflicting) {
+          continue
+        }
+      }
+
       val isNotEndLineSpan = isSpanEnabledInNextLine(s, end, config.clazz)
       val spans = s.getSpans(start, end, config.clazz)
 
@@ -154,8 +337,8 @@ class ParagraphStyles(private val view: EnrichedTextInputView) {
 
     if (start == end) {
       spannable.insert(start, "\u200B")
-      view.spanState?.setStart(name, start + 1)
       setAndMergeSpans(spannable, type, start, end + 1)
+      view.selection.validateStyles()
 
       return
     }
@@ -170,8 +353,8 @@ class ParagraphStyles(private val view: EnrichedTextInputView) {
       currentStart = currentEnd + 1
     }
 
-    view.spanState?.setStart(name, start)
     setAndMergeSpans(spannable, type, start, currentEnd)
+    view.selection.validateStyles()
   }
 
   fun getStyleRange(): Pair<Int, Int> {
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParametrizedStyles.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParametrizedStyles.kt
index 9b86656..1c2de28 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParametrizedStyles.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/styles/ParametrizedStyles.kt
@@ -1,6 +1,5 @@
 package com.swmansion.enriched.styles
 
-import android.net.Uri
 import android.text.Editable
 import android.text.Spannable
 import android.text.SpannableStringBuilder
@@ -11,7 +10,6 @@ import com.swmansion.enriched.spans.EnrichedLinkSpan
 import com.swmansion.enriched.spans.EnrichedMentionSpan
 import com.swmansion.enriched.spans.EnrichedSpans
 import com.swmansion.enriched.utils.getSafeSpanBoundaries
-import java.io.File
 
 class ParametrizedStyles(private val view: EnrichedTextInputView) {
   private var mentionStart: Int? = null
@@ -85,7 +83,7 @@ class ParametrizedStyles(private val view: EnrichedTextInputView) {
     }
   }
 
-  private fun getWordAtIndex(s: Editable, index: Int): Triple<String, Int, Int>? {
+  private fun getWordAtIndex(s: CharSequence, index: Int): TextRange? {
     if (index < 0 ) return null
 
     var start = index
@@ -101,7 +99,7 @@ class ParametrizedStyles(private val view: EnrichedTextInputView) {
 
     val result = s.subSequence(start, end).toString()
 
-    return Triple(result, start, end)
+    return TextRange(result, start, end)
   }
 
   private fun canLinkBeApplied(): Boolean {
@@ -120,7 +118,7 @@ class ParametrizedStyles(private val view: EnrichedTextInputView) {
     return true
   }
 
-  private fun afterTextChangedLinks(result: Triple<String, Int, Int>) {
+  private fun afterTextChangedLinks(result: TextRange) {
     // Do not detect link if it's applied manually
     if (isSettingLinkSpan || !canLinkBeApplied()) return
 
@@ -141,55 +139,80 @@ class ParametrizedStyles(private val view: EnrichedTextInputView) {
     }
   }
 
-  private fun afterTextChangedMentions(result: Triple<String, Int, Int>) {
+  private fun afterTextChangedMentions(currentWord: TextRange) {
     val mentionHandler = view.mentionHandler ?: return
     val spannable = view.text as Spannable
-    val (word, start, end) = result
 
     val indicatorsPattern = mentionIndicators.joinToString("|") { Regex.escape(it) }
     val mentionIndicatorRegex = Regex("^($indicatorsPattern)")
     val mentionRegex= Regex("^($indicatorsPattern)\\w*")
 
-    val spans = spannable.getSpans(start, end, EnrichedMentionSpan::class.java)
+    val spans = spannable.getSpans(currentWord.start, currentWord.end, EnrichedMentionSpan::class.java)
     for (span in spans) {
       spannable.removeSpan(span)
     }
 
-    if (mentionRegex.matches(word)) {
-      val indicator = mentionIndicatorRegex.find(word)?.value ?: ""
-      val text = word.replaceFirst(indicator, "")
+    var indicator: String
+    var finalStart: Int
+    val finalEnd = currentWord.end
+
+    // No mention in the current word, check previous one
+    if (!mentionRegex.matches(currentWord.text)) {
+      val previousWord = getWordAtIndex(spannable, currentWord.start - 1)
 
-      // Means we are starting mention
-      if (text.isEmpty()) {
-        mentionStart = start
+      // No previous word -> no mention to be detected
+      if (previousWord == null) {
+        mentionHandler.endMention()
+        return
       }
 
-      mentionHandler.onMention(indicator, text)
+      // Previous word is not a mention -> end mention
+      if (!mentionRegex.matches(previousWord.text)) {
+        mentionHandler.endMention()
+        return
+      }
+
+      // Previous word is a mention -> use it
+      finalStart = previousWord.start
+      indicator = mentionIndicatorRegex.find(previousWord.text)?.value ?: ""
     } else {
-      mentionHandler.endMention()
+      // Current word is a mention -> use it
+      finalStart = currentWord.start
+      indicator = mentionIndicatorRegex.find(currentWord.text)?.value ?: ""
+    }
+
+    // Extract text without indicator
+    val text = spannable.subSequence(finalStart, finalEnd).toString().replaceFirst(indicator, "")
+
+    // Means we are starting mention
+    if (text.isEmpty()) {
+      mentionStart = finalStart
     }
+
+    mentionHandler.onMention(indicator, text)
   }
 
-  fun setImageSpan(src: String) {
+  fun setImageSpan(src: String, width: Float, height: Float) {
     if (view.selection == null) return
-
     val spannable = view.text as SpannableStringBuilder
-    var (start, end) = view.selection.getInlineSelection()
-    val spans = spannable.getSpans(start, end, EnrichedImageSpan::class.java)
+    val (start, originalEnd) = view.selection.getInlineSelection()
 
-    for (s in spans) {
-      spannable.removeSpan(s)
-    }
-
-    if (start == end) {
+    if (start == originalEnd) {
       spannable.insert(start, "\uFFFC")
-      end++
+    } else {
+      val spans = spannable.getSpans(start, originalEnd, EnrichedImageSpan::class.java)
+      for (s in spans) {
+        spannable.removeSpan(s)
+      }
+
+      spannable.replace(start, originalEnd, "\uFFFC")
     }
 
-    val uri = Uri.fromFile(File(src))
-    val span = EnrichedImageSpan(view.context, uri, view.htmlStyle)
-    val (safeStart, safeEnd) = spannable.getSafeSpanBoundaries(start, end)
-    spannable.setSpan(span, safeStart, safeEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
+    val (imageStart, imageEnd) = spannable.getSafeSpanBoundaries(start, start + 1)
+    val span = EnrichedImageSpan.createEnrichedImageSpan(src, width.toInt(), height.toInt())
+    span.observeAsyncDrawableLoaded(view.text)
+
+    spannable.setSpan(span, imageStart, imageEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
   }
 
   fun startMention(indicator: String) {
@@ -245,4 +268,8 @@ class ParametrizedStyles(private val view: EnrichedTextInputView) {
     val spannable = view.text as Spannable
     return removeSpansForRange(spannable, start, end, config.clazz)
   }
+
+  companion object {
+    data class TextRange(val text: String, val start: Int, val end: Int)
+  }
 }
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/AsyncDrawable.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/AsyncDrawable.kt
new file mode 100644
index 0000000..cda370b
--- /dev/null
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/AsyncDrawable.kt
@@ -0,0 +1,91 @@
+package com.swmansion.enriched.utils
+
+import android.annotation.SuppressLint
+import android.content.res.Resources
+import android.graphics.BitmapFactory
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.ColorFilter
+import android.graphics.PixelFormat
+import android.graphics.drawable.Drawable
+import android.os.Handler
+import android.os.Looper
+import android.util.Log
+import androidx.core.content.res.ResourcesCompat
+import androidx.core.graphics.drawable.DrawableCompat
+import java.net.URL
+import java.util.concurrent.Executors
+import androidx.core.graphics.drawable.toDrawable
+import com.swmansion.enriched.R
+
+class AsyncDrawable (
+  private val url: String,
+) : Drawable() {
+  private var internalDrawable: Drawable = Color.TRANSPARENT.toDrawable()
+  private val mainHandler = Handler(Looper.getMainLooper())
+  private val executor = Executors.newSingleThreadExecutor()
+  var isLoaded = false
+
+  init {
+    internalDrawable.bounds = bounds
+
+    load()
+  }
+
+  private fun load() {
+    executor.execute {
+      try {
+        isLoaded = false
+        val inputStream = URL(url).openStream()
+        val bitmap = BitmapFactory.decodeStream(inputStream)
+
+        // Switch to Main Thread to update UI
+        mainHandler.post {
+          if (bitmap != null) {
+            val d = bitmap.toDrawable(Resources.getSystem())
+
+            d.bounds = bounds
+            internalDrawable = d
+          } else {
+            loadPlaceholderImage()
+          }
+        }
+      } catch (e: Exception) {
+        Log.e("AsyncDrawable", "Failed to load: $url", e)
+
+        loadPlaceholderImage()
+      } finally {
+        isLoaded = true
+        onLoaded?.invoke()
+      }
+    }
+  }
+
+  private fun loadPlaceholderImage() {
+    internalDrawable = ResourceManager.getDrawableResource(R.drawable.broken_image)
+  }
+
+  override fun draw(canvas: Canvas) {
+    internalDrawable.draw(canvas)
+  }
+
+  override fun setAlpha(alpha: Int) {
+    internalDrawable.alpha = alpha
+  }
+
+  override fun setColorFilter(colorFilter: ColorFilter?) {
+    internalDrawable.colorFilter = colorFilter
+  }
+
+  @Deprecated("Deprecated in Java")
+  override fun getOpacity(): Int {
+    return PixelFormat.TRANSLUCENT
+  }
+
+  override fun setBounds(left: Int, top: Int, right: Int, bottom: Int) {
+    super.setBounds(left, top, right, bottom)
+    internalDrawable.setBounds(left, top, right, bottom)
+  }
+
+  var onLoaded: (() -> Unit)? = null
+}
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/EnrichedParser.java b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/EnrichedParser.java
index 82fe911..1b0758b 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/EnrichedParser.java
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/EnrichedParser.java
@@ -105,6 +105,14 @@ public class EnrichedParser {
     String normalizedBlockQuote = normalizedCodeBlock.replaceAll("</blockquote>\\n<br>", "</blockquote>");
     return "<html>\n" + normalizedBlockQuote + "</html>";
   }
+
+  public static String toHtmlWithDefault(CharSequence text) {
+    if (text instanceof Spanned) {
+      return toHtml((Spanned) text);
+    }
+    return "<html>\n<p></p>\n</html>";
+  }
+
   /**
    * Returns an HTML escaped representation of the given plain text.
    */
@@ -275,7 +283,16 @@ public class EnrichedParser {
         if (style[j] instanceof EnrichedImageSpan) {
           out.append("<img src=\"");
           out.append(((EnrichedImageSpan) style[j]).getSource());
-          out.append("\">");
+          out.append("\"");
+
+          out.append(" width=\"");
+          out.append(((EnrichedImageSpan) style[j]).getWidth());
+          out.append("\"");
+
+          out.append(" height=\"");
+          out.append(((EnrichedImageSpan) style[j]).getHeight());
+
+          out.append("\"/>");
           // Don't output the placeholder character underlying the image.
           i = next;
         }
@@ -412,7 +429,6 @@ class HtmlToSpannedConverter implements ContentHandler {
   }
 
   private void handleStartTag(String tag, Attributes attributes) {
-    isEmptyTag = false;
     if (tag.equalsIgnoreCase("br")) {
       // We don't need to handle this. TagSoup will ensure that there's a </br> for each <br>
       // so we can safely emit the linebreaks when we handle the close tag.
@@ -454,7 +470,7 @@ class HtmlToSpannedConverter implements ContentHandler {
     } else if (tag.equalsIgnoreCase("h3")) {
       startHeading(mSpannableStringBuilder, 3);
     } else if (tag.equalsIgnoreCase("img")) {
-      startImg(mSpannableStringBuilder, attributes, mImageGetter, mStyle);
+      startImg(mSpannableStringBuilder, attributes, mImageGetter);
     } else if (tag.equalsIgnoreCase("code")) {
       start(mSpannableStringBuilder, new Code());
     } else if (tag.equalsIgnoreCase("mention")) {
@@ -679,20 +695,15 @@ class HtmlToSpannedConverter implements ContentHandler {
     }
   }
 
-  private static void startImg(Editable text, Attributes attributes, EnrichedParser.ImageGetter img, HtmlStyle style) {
+  private static void startImg(Editable text, Attributes attributes, EnrichedParser.ImageGetter img) {
     String src = attributes.getValue("", "src");
-    Drawable d = null;
-    if (img != null) {
-      d = img.getDrawable(src);
-    }
-
-    if (d == null) {
-      return;
-    }
+    String width = attributes.getValue("", "width");
+    String height = attributes.getValue("", "height");
 
     int len = text.length();
+    EnrichedImageSpan span = EnrichedImageSpan.Companion.createEnrichedImageSpan(src, Integer.parseInt(width), Integer.parseInt(height));
     text.append("ï¿¼");
-    text.setSpan(new EnrichedImageSpan(d, src, style), len, text.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+    text.setSpan(span, len, text.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
   }
 
   private static void startA(Editable text, Attributes attributes) {
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/ResourceManager.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/ResourceManager.kt
new file mode 100644
index 0000000..72ba9c3
--- /dev/null
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/utils/ResourceManager.kt
@@ -0,0 +1,26 @@
+package com.swmansion.enriched.utils
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.res.Resources
+import android.graphics.drawable.Drawable
+import androidx.core.content.res.ResourcesCompat
+import androidx.core.graphics.drawable.DrawableCompat
+
+object ResourceManager {
+  private var appContext: Context? = null
+
+  fun init(context: Context) {
+    this.appContext = context.applicationContext
+  }
+
+  @SuppressLint("UseCompatLoadingForDrawables")
+  fun getDrawableResource(id: Int): Drawable {
+    val context = appContext ?: throw IllegalStateException("ResourceManager not initialized! Call init() first.")
+
+    val image = ResourcesCompat.getDrawable(context.resources, id, null)
+    val finalImage = image ?: Resources.getSystem().getDrawable(android.R.drawable.ic_menu_report_image)
+
+    return DrawableCompat.wrap(finalImage)
+  }
+}
diff --git a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/watchers/EnrichedSpanWatcher.kt b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/watchers/EnrichedSpanWatcher.kt
index 16b2511..f45f6bc 100644
--- a/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/watchers/EnrichedSpanWatcher.kt
+++ b/node_modules/react-native-enriched/android/src/main/java/com/swmansion/enriched/watchers/EnrichedSpanWatcher.kt
@@ -52,6 +52,9 @@ class EnrichedSpanWatcher(private val view: EnrichedTextInputView) : SpanWatcher
   }
 
   fun emitEvent(s: Spannable, what: Any?) {
+    // Do not parse spannable and emit event if onChangeHtml is not provided
+    if (!view.shouldEmitHtml) return
+
     // Emit event only if we change one of ours spans
     if (what != null && what !is EnrichedSpan) return
 
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.cpp b/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.cpp
index 775c9e0..c17e72c 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.cpp
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.cpp
@@ -1,9 +1,10 @@
 
 /**
- * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ * This code was generated by
+ * [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
  *
- * Do not edit this file as changes may cause incorrect behavior and will be lost
- * once the code is regenerated.
+ * Do not edit this file as changes may cause incorrect behavior and will be
+ * lost once the code is regenerated.
  *
  * @generated by codegen project: GenerateModuleJniCpp.js
  */
@@ -12,9 +13,8 @@
 
 namespace facebook::react {
 
-
-
-std::shared_ptr<TurboModule> RNEnrichedTextInputViewSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+std::shared_ptr<TurboModule> RNEnrichedTextInputViewSpec_ModuleProvider(
+    const std::string &moduleName, const JavaTurboModule::InitParams &params) {
 
   return nullptr;
 }
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.h b/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.h
index d37e4e5..a09d32a 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/RNEnrichedTextInputViewSpec.h
@@ -1,9 +1,10 @@
 
 /**
- * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ * This code was generated by
+ * [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
  *
- * Do not edit this file as changes may cause incorrect behavior and will be lost
- * once the code is regenerated.
+ * Do not edit this file as changes may cause incorrect behavior and will be
+ * lost once the code is regenerated.
  *
  * @generated by codegen project: GenerateModuleJniH.js
  */
@@ -18,9 +19,8 @@
 
 namespace facebook::react {
 
-
-
 JSI_EXPORT
-std::shared_ptr<TurboModule> RNEnrichedTextInputViewSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+std::shared_ptr<TurboModule> RNEnrichedTextInputViewSpec_ModuleProvider(
+    const std::string &moduleName, const JavaTurboModule::InitParams &params);
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputComponentDescriptor.h b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputComponentDescriptor.h
index 0e0f51f..b246d91 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputComponentDescriptor.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputComponentDescriptor.h
@@ -8,28 +8,28 @@
 namespace facebook::react {
 
 class EnrichedTextInputComponentDescriptor final
-        : public ConcreteComponentDescriptor<EnrichedTextInputShadowNode> {
+    : public ConcreteComponentDescriptor<EnrichedTextInputShadowNode> {
 public:
-    EnrichedTextInputComponentDescriptor(
-            const ComponentDescriptorParameters& parameters)
-        : ConcreteComponentDescriptor(parameters),
-            measurementsManager_(
-                std::make_shared<EnrichedTextInputMeasurementManager>(
-                        contextContainer_)) {}
-
-    void adopt(ShadowNode& shadowNode) const override {
-        ConcreteComponentDescriptor::adopt(shadowNode);
-        auto& editorShadowNode = static_cast<EnrichedTextInputShadowNode&>(shadowNode);
-
-        // `EnrichedTextInputShadowNode` uses
-        // `EnrichedTextInputMeasurementManager` to provide measurements to Yoga.
-        editorShadowNode.setMeasurementsManager(measurementsManager_);
-    }
+  EnrichedTextInputComponentDescriptor(
+      const ComponentDescriptorParameters &parameters)
+      : ConcreteComponentDescriptor(parameters),
+        measurementsManager_(
+            std::make_shared<EnrichedTextInputMeasurementManager>(
+                contextContainer_)) {}
+
+  void adopt(ShadowNode &shadowNode) const override {
+    ConcreteComponentDescriptor::adopt(shadowNode);
+    auto &editorShadowNode =
+        static_cast<EnrichedTextInputShadowNode &>(shadowNode);
+
+    // `EnrichedTextInputShadowNode` uses
+    // `EnrichedTextInputMeasurementManager` to provide measurements to Yoga.
+    editorShadowNode.setMeasurementsManager(measurementsManager_);
+  }
 
 private:
-    const std::shared_ptr<EnrichedTextInputMeasurementManager>
-            measurementsManager_;
+  const std::shared_ptr<EnrichedTextInputMeasurementManager>
+      measurementsManager_;
 };
 
 } // namespace facebook::react
-
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.cpp b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.cpp
index 01f391e..e0f7cb3 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.cpp
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.cpp
@@ -9,56 +9,45 @@ using namespace facebook::jni;
 
 namespace facebook::react {
 
-    Size EnrichedTextInputMeasurementManager::measure(
-            SurfaceId surfaceId,
-            int viewTag,
-            const EnrichedTextInputViewProps& props,
-            LayoutConstraints layoutConstraints) const {
-        const jni::global_ref<jobject>& fabricUIManager =
-                contextContainer_->at<jni::global_ref<jobject>>("FabricUIManager");
-
-        static const auto measure = facebook::jni::findClassStatic(
-                "com/facebook/react/fabric/FabricUIManager")
-                ->getMethod<jlong(
-                        jint,
-                        jstring,
-                        ReadableMap::javaobject,
-                        ReadableMap::javaobject,
-                        ReadableMap::javaobject,
-                        jfloat,
-                        jfloat,
-                        jfloat,
-                        jfloat)>("measure");
-
-        auto minimumSize = layoutConstraints.minimumSize;
-        auto maximumSize = layoutConstraints.maximumSize;
-
-        local_ref<JString> componentName = make_jstring("EnrichedTextInputView");
-
-        // Prepare extraData map with viewTag
-        folly::dynamic extraData = folly::dynamic::object();
-        extraData["viewTag"] = viewTag;
-        local_ref<ReadableNativeMap::javaobject> extraDataRNM = ReadableNativeMap::newObjectCxxArgs(extraData);
-        local_ref<ReadableMap::javaobject> extraDataRM = make_local(reinterpret_cast<ReadableMap::javaobject>(extraDataRNM.get()));
-
-        // Prepare layout metrics affecting props
-        auto serializedProps = toDynamic(props);
-        local_ref<ReadableNativeMap::javaobject> propsRNM = ReadableNativeMap::newObjectCxxArgs(serializedProps);
-        local_ref<ReadableMap::javaobject> propsRM = make_local(reinterpret_cast<ReadableMap::javaobject>(propsRNM.get()));
-
-        auto measurement = yogaMeassureToSize(measure(
-                fabricUIManager,
-                surfaceId,
-                componentName.get(),
-                extraDataRM.get(),
-                propsRM.get(),
-                nullptr,
-                minimumSize.width,
-                maximumSize.width,
-                minimumSize.height,
-                maximumSize.height));
-
-        return measurement;
-    }
+Size EnrichedTextInputMeasurementManager::measure(
+    SurfaceId surfaceId, int viewTag, const EnrichedTextInputViewProps &props,
+    LayoutConstraints layoutConstraints) const {
+  const jni::global_ref<jobject> &fabricUIManager =
+      contextContainer_->at<jni::global_ref<jobject>>("FabricUIManager");
+
+  static const auto measure =
+      facebook::jni::findClassStatic(
+          "com/facebook/react/fabric/FabricUIManager")
+          ->getMethod<jlong(jint, jstring, ReadableMap::javaobject,
+                            ReadableMap::javaobject, ReadableMap::javaobject,
+                            jfloat, jfloat, jfloat, jfloat)>("measure");
+
+  auto minimumSize = layoutConstraints.minimumSize;
+  auto maximumSize = layoutConstraints.maximumSize;
+
+  local_ref<JString> componentName = make_jstring("EnrichedTextInputView");
+
+  // Prepare extraData map with viewTag
+  folly::dynamic extraData = folly::dynamic::object();
+  extraData["viewTag"] = viewTag;
+  local_ref<ReadableNativeMap::javaobject> extraDataRNM =
+      ReadableNativeMap::newObjectCxxArgs(extraData);
+  local_ref<ReadableMap::javaobject> extraDataRM =
+      make_local(reinterpret_cast<ReadableMap::javaobject>(extraDataRNM.get()));
+
+  // Prepare layout metrics affecting props
+  auto serializedProps = toDynamic(props);
+  local_ref<ReadableNativeMap::javaobject> propsRNM =
+      ReadableNativeMap::newObjectCxxArgs(serializedProps);
+  local_ref<ReadableMap::javaobject> propsRM =
+      make_local(reinterpret_cast<ReadableMap::javaobject>(propsRNM.get()));
+
+  auto measurement = yogaMeassureToSize(
+      measure(fabricUIManager, surfaceId, componentName.get(),
+              extraDataRM.get(), propsRM.get(), nullptr, minimumSize.width,
+              maximumSize.width, minimumSize.height, maximumSize.height));
+
+  return measurement;
+}
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.h b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.h
index 775a3fc..b70c435 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputMeasurementManager.h
@@ -2,26 +2,24 @@
 
 #include "ComponentDescriptors.h"
 
-#include <react/utils/ContextContainer.h>
-#include <react/renderer/core/LayoutConstraints.h>
 #include <react/renderer/components/RNEnrichedTextInputViewSpec/Props.h>
+#include <react/renderer/core/LayoutConstraints.h>
+#include <react/utils/ContextContainer.h>
 
 namespace facebook::react {
 
-    class EnrichedTextInputMeasurementManager {
-    public:
-        EnrichedTextInputMeasurementManager(
-                const std::shared_ptr<const ContextContainer>& contextContainer)
-                : contextContainer_(contextContainer) {}
+class EnrichedTextInputMeasurementManager {
+public:
+  EnrichedTextInputMeasurementManager(
+      const std::shared_ptr<const ContextContainer> &contextContainer)
+      : contextContainer_(contextContainer) {}
 
-        Size measure(
-                SurfaceId surfaceId,
-                int viewTag,
-                const EnrichedTextInputViewProps& props,
-                LayoutConstraints layoutConstraints) const;
+  Size measure(SurfaceId surfaceId, int viewTag,
+               const EnrichedTextInputViewProps &props,
+               LayoutConstraints layoutConstraints) const;
 
-    private:
-        const std::shared_ptr<const ContextContainer> contextContainer_;
-    };
+private:
+  const std::shared_ptr<const ContextContainer> contextContainer_;
+};
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.cpp b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.cpp
index a2632ad..30d4618 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.cpp
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.cpp
@@ -4,30 +4,32 @@
 
 namespace facebook::react {
 extern const char EnrichedTextInputComponentName[] = "EnrichedTextInputView";
-    void EnrichedTextInputShadowNode::setMeasurementsManager(
-            const std::shared_ptr<EnrichedTextInputMeasurementManager>&
-            measurementsManager) {
-        ensureUnsealed();
-        measurementsManager_ = measurementsManager;
-    }
+void EnrichedTextInputShadowNode::setMeasurementsManager(
+    const std::shared_ptr<EnrichedTextInputMeasurementManager>
+        &measurementsManager) {
+  ensureUnsealed();
+  measurementsManager_ = measurementsManager;
+}
 
-    // Mark layout as dirty after state has been updated
-    // Once layout is marked as dirty, `measureContent` will be called in order to recalculate layout
-    void EnrichedTextInputShadowNode::dirtyLayoutIfNeeded() {
-        const auto state = this->getStateData();
-        const auto counter = state.getForceHeightRecalculationCounter();
+// Mark layout as dirty after state has been updated
+// Once layout is marked as dirty, `measureContent` will be called in order to
+// recalculate layout
+void EnrichedTextInputShadowNode::dirtyLayoutIfNeeded() {
+  const auto state = this->getStateData();
+  const auto counter = state.getForceHeightRecalculationCounter();
 
-        if (forceHeightRecalculationCounter_ != counter) {
-            forceHeightRecalculationCounter_ = counter;
+  if (forceHeightRecalculationCounter_ != counter) {
+    forceHeightRecalculationCounter_ = counter;
 
-            dirtyLayout();
-        }
-    }
+    dirtyLayout();
+  }
+}
 
-    Size EnrichedTextInputShadowNode::measureContent(
-            const LayoutContext &layoutContext,
-            const LayoutConstraints &layoutConstraints) const {
-        return measurementsManager_->measure(getSurfaceId(), getTag(), getConcreteProps(), layoutConstraints);
-    }
+Size EnrichedTextInputShadowNode::measureContent(
+    const LayoutContext &layoutContext,
+    const LayoutConstraints &layoutConstraints) const {
+  return measurementsManager_->measure(getSurfaceId(), getTag(),
+                                       getConcreteProps(), layoutConstraints);
+}
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.h b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.h
index 6ff3e3c..4d8e6cb 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputShadowNode.h
@@ -3,9 +3,9 @@
 #include "EnrichedTextInputMeasurementManager.h"
 #include "EnrichedTextInputState.h"
 
-#include <react/renderer/components/view/ConcreteViewShadowNode.h>
-#include <react/renderer/components/RNEnrichedTextInputViewSpec/Props.h>
 #include <react/renderer/components/RNEnrichedTextInputViewSpec/EventEmitters.h>
+#include <react/renderer/components/RNEnrichedTextInputViewSpec/Props.h>
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
 
 namespace facebook::react {
 
@@ -13,42 +13,41 @@ JSI_EXPORT extern const char EnrichedTextInputComponentName[];
 /*
  * `ShadowNode` for <EnrichedTextInputView> component.
  */
-class EnrichedTextInputShadowNode final : public ConcreteViewShadowNode<
-        EnrichedTextInputComponentName,
-        EnrichedTextInputViewProps,
-        EnrichedTextInputViewEventEmitter,
-        EnrichedTextInputState> {
+class EnrichedTextInputShadowNode final
+    : public ConcreteViewShadowNode<
+          EnrichedTextInputComponentName, EnrichedTextInputViewProps,
+          EnrichedTextInputViewEventEmitter, EnrichedTextInputState> {
 public:
-    using ConcreteViewShadowNode::ConcreteViewShadowNode;
-
-    // This constructor is called when we "update" shadow node, e.g. after updating shadow node's state
-    EnrichedTextInputShadowNode(
-            ShadowNode const &sourceShadowNode,
-            ShadowNodeFragment const &fragment)
-        : ConcreteViewShadowNode(sourceShadowNode, fragment) {
-            dirtyLayoutIfNeeded();
-    }
-
-    static ShadowNodeTraits BaseTraits() {
-        auto traits = ConcreteViewShadowNode::BaseTraits();
-        traits.set(ShadowNodeTraits::Trait::LeafYogaNode);
-        traits.set(ShadowNodeTraits::Trait::MeasurableYogaNode);
-        return traits;
-    }
-
-    // Associates a shared `EnrichedTextInputMeasurementManager` with the node.
-    void setMeasurementsManager(
-            const std::shared_ptr<EnrichedTextInputMeasurementManager>&
-            measurementsManager);
-
-    void dirtyLayoutIfNeeded();
-
-    Size measureContent(
-            const LayoutContext& layoutContext,
-            const LayoutConstraints& layoutConstraints) const override;
+  using ConcreteViewShadowNode::ConcreteViewShadowNode;
+
+  // This constructor is called when we "update" shadow node, e.g. after
+  // updating shadow node's state
+  EnrichedTextInputShadowNode(ShadowNode const &sourceShadowNode,
+                              ShadowNodeFragment const &fragment)
+      : ConcreteViewShadowNode(sourceShadowNode, fragment) {
+    dirtyLayoutIfNeeded();
+  }
+
+  static ShadowNodeTraits BaseTraits() {
+    auto traits = ConcreteViewShadowNode::BaseTraits();
+    traits.set(ShadowNodeTraits::Trait::LeafYogaNode);
+    traits.set(ShadowNodeTraits::Trait::MeasurableYogaNode);
+    return traits;
+  }
+
+  // Associates a shared `EnrichedTextInputMeasurementManager` with the node.
+  void setMeasurementsManager(
+      const std::shared_ptr<EnrichedTextInputMeasurementManager>
+          &measurementsManager);
+
+  void dirtyLayoutIfNeeded();
+
+  Size
+  measureContent(const LayoutContext &layoutContext,
+                 const LayoutConstraints &layoutConstraints) const override;
 
 private:
-    int forceHeightRecalculationCounter_;
-    std::shared_ptr<EnrichedTextInputMeasurementManager> measurementsManager_;
+  int forceHeightRecalculationCounter_;
+  std::shared_ptr<EnrichedTextInputMeasurementManager> measurementsManager_;
 };
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.cpp b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.cpp
index 31287bd..b6caf28 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.cpp
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.cpp
@@ -2,8 +2,8 @@
 
 namespace facebook::react {
 
-    int EnrichedTextInputState::getForceHeightRecalculationCounter() const {
-        return forceHeightRecalculationCounter_;
-    }
-
+int EnrichedTextInputState::getForceHeightRecalculationCounter() const {
+  return forceHeightRecalculationCounter_;
 }
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.h b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.h
index 31980e4..0f46bdd 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/EnrichedTextInputState.h
@@ -4,22 +4,21 @@
 
 namespace facebook::react {
 
-    class EnrichedTextInputState {
-    public:
-        EnrichedTextInputState()
-                : forceHeightRecalculationCounter_(0) {}
+class EnrichedTextInputState {
+public:
+  EnrichedTextInputState() : forceHeightRecalculationCounter_(0) {}
 
-        // Used by Kotlin to set current text value
-        EnrichedTextInputState(EnrichedTextInputState const &previousState, folly::dynamic data)
-                : forceHeightRecalculationCounter_((int)data["forceHeightRecalculationCounter"].getInt()){};
-        folly::dynamic getDynamic() const {
-            return {};
-        };
+  // Used by Kotlin to set current text value
+  EnrichedTextInputState(EnrichedTextInputState const &previousState,
+                         folly::dynamic data)
+      : forceHeightRecalculationCounter_(
+            (int)data["forceHeightRecalculationCounter"].getInt()){};
+  folly::dynamic getDynamic() const { return {}; };
 
-        int getForceHeightRecalculationCounter() const;
+  int getForceHeightRecalculationCounter() const;
 
-    private:
-        const int forceHeightRecalculationCounter_{};
-    };
+private:
+  const int forceHeightRecalculationCounter_{};
+};
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/conversions.h b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/conversions.h
index 0b82fdc..b43446e 100644
--- a/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/conversions.h
+++ b/node_modules/react-native-enriched/android/src/main/new_arch/react/renderer/components/RNEnrichedTextInputViewSpec/conversions.h
@@ -1,26 +1,25 @@
 #pragma once
 
 #include <folly/dynamic.h>
-#include <react/renderer/components/FBReactNativeSpec/Props.h>
-#include <react/renderer/core/propsConversions.h>
+#include <react/renderer/components/rncore/Props.h>
 #include <react/renderer/components/RNEnrichedTextInputViewSpec/Props.h>
+#include <react/renderer/core/propsConversions.h>
 
 namespace facebook::react {
 
 #ifdef RN_SERIALIZABLE_STATE
-inline folly::dynamic toDynamic(const EnrichedTextInputViewProps &props)
-{
-    // Serialize only metrics affecting props
-    folly::dynamic serializedProps = folly::dynamic::object();
-    serializedProps["defaultValue"] = props.defaultValue;
-    serializedProps["placeholder"] = props.placeholder;
-    serializedProps["fontSize"] = props.fontSize;
-    serializedProps["fontWeight"] = props.fontWeight;
-    serializedProps["fontStyle"] = props.fontStyle;
-    serializedProps["fontFamily"] = props.fontFamily;
-    serializedProps["htmlStyle"] = toDynamic(props.htmlStyle);
+inline folly::dynamic toDynamic(const EnrichedTextInputViewProps &props) {
+  // Serialize only metrics affecting props
+  folly::dynamic serializedProps = folly::dynamic::object();
+  serializedProps["defaultValue"] = props.defaultValue;
+  serializedProps["placeholder"] = props.placeholder;
+  serializedProps["fontSize"] = props.fontSize;
+  serializedProps["fontWeight"] = props.fontWeight;
+  serializedProps["fontStyle"] = props.fontStyle;
+  serializedProps["fontFamily"] = props.fontFamily;
+  serializedProps["htmlStyle"] = toDynamic(props.htmlStyle);
 
-    return serializedProps;
+  return serializedProps;
 }
 #endif
 
diff --git a/node_modules/react-native-enriched/android/src/main/res/drawable/broken_image.xml b/node_modules/react-native-enriched/android/src/main/res/drawable/broken_image.xml
new file mode 100644
index 0000000..42d644f
--- /dev/null
+++ b/node_modules/react-native-enriched/android/src/main/res/drawable/broken_image.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="960"
+    android:viewportHeight="960"
+    android:tint="?attr/colorControlNormal">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M200,840Q167,840 143.5,816.5Q120,793 120,760L120,200Q120,167 143.5,143.5Q167,120 200,120L760,120Q793,120 816.5,143.5Q840,167 840,200L840,760Q840,793 816.5,816.5Q793,840 760,840L200,840ZM240,503L400,343L560,503L720,343L760,383L760,200Q760,200 760,200Q760,200 760,200L200,200Q200,200 200,200Q200,200 200,200L200,463L240,503ZM200,760L760,760Q760,760 760,760Q760,760 760,760L760,496L720,456L560,616L400,456L240,616L200,576L200,760Q200,760 200,760Q200,760 200,760ZM200,760L200,760Q200,760 200,760Q200,760 200,760L200,496L200,576L200,463L200,383L200,200Q200,200 200,200Q200,200 200,200L200,200Q200,200 200,200Q200,200 200,200L200,463L200,463L200,576L200,576L200,760Q200,760 200,760Q200,760 200,760Z"/>
+</vector>
diff --git a/node_modules/react-native-enriched/ios/EnrichedTextInputView.h b/node_modules/react-native-enriched/ios/EnrichedTextInputView.h
index 962cd2f..9bf2c3d 100644
--- a/node_modules/react-native-enriched/ios/EnrichedTextInputView.h
+++ b/node_modules/react-native-enriched/ios/EnrichedTextInputView.h
@@ -1,30 +1,45 @@
 #pragma once
-#import <React/RCTViewComponentView.h>
-#import <UIKit/UIKit.h>
+#import "BaseStyleProtocol.h"
 #import "InputConfig.h"
 #import "InputParser.h"
-#import "BaseStyleProtocol.h"
 #import "InputTextView.h"
+#import "MediaAttachment.h"
+#import <React/RCTViewComponentView.h>
+#import <UIKit/UIKit.h>
 
 #ifndef EnrichedTextInputViewNativeComponent_h
 #define EnrichedTextInputViewNativeComponent_h
 
 NS_ASSUME_NONNULL_BEGIN
 
-@interface EnrichedTextInputView : RCTViewComponentView {
-  @public InputTextView *textView;
-  @public NSRange recentlyChangedRange;
-  @public InputConfig *config;
-  @public InputParser *parser;
-  @public NSMutableDictionary<NSAttributedStringKey, id> *defaultTypingAttributes;
-  @public NSDictionary<NSNumber *, id<BaseStyleProtocol>> *stylesDict;
-  @public BOOL blockEmitting;
+@interface EnrichedTextInputView
+    : RCTViewComponentView <MediaAttachmentDelegate> {
+@public
+  InputTextView *textView;
+@public
+  NSRange recentlyChangedRange;
+@public
+  InputConfig *config;
+@public
+  InputParser *parser;
+@public
+  NSMutableDictionary<NSAttributedStringKey, id> *defaultTypingAttributes;
+@public
+  NSDictionary<NSNumber *, id<BaseStyleProtocol>> *stylesDict;
+  NSDictionary<NSNumber *, NSArray<NSNumber *> *> *conflictingStyles;
+  NSDictionary<NSNumber *, NSArray<NSNumber *> *> *blockingStyles;
+@public
+  BOOL blockEmitting;
 }
 - (CGSize)measureSize:(CGFloat)maxWidth;
-- (void)emitOnLinkDetectedEvent:(NSString *)text url:(NSString *)url range:(NSRange)range;
+- (void)emitOnLinkDetectedEvent:(NSString *)text
+                            url:(NSString *)url
+                          range:(NSRange)range;
 - (void)emitOnMentionEvent:(NSString *)indicator text:(nullable NSString *)text;
 - (void)anyTextMayHaveBeenModified;
 - (BOOL)handleStyleBlocksAndConflicts:(StyleType)type range:(NSRange)range;
+- (NSArray<NSNumber *> *)getPresentStyleTypesFrom:(NSArray<NSNumber *> *)types
+                                            range:(NSRange)range;
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/node_modules/react-native-enriched/ios/EnrichedTextInputView.mm b/node_modules/react-native-enriched/ios/EnrichedTextInputView.mm
index d588ab0..c3cad89 100644
--- a/node_modules/react-native-enriched/ios/EnrichedTextInputView.mm
+++ b/node_modules/react-native-enriched/ios/EnrichedTextInputView.mm
@@ -1,24 +1,25 @@
 #import "EnrichedTextInputView.h"
+#import "CoreText/CoreText.h"
+#import "LayoutManagerExtension.h"
+#import "ParagraphAttributesUtils.h"
 #import "RCTFabricComponentsPlugins.h"
+#import "StringExtension.h"
+#import "StyleHeaders.h"
+#import "UIView+React.h"
+#import "WordsUtils.h"
+#import "ZeroWidthSpaceUtils.h"
+#import <React/RCTConversions.h>
 #import <ReactNativeEnriched/EnrichedTextInputViewComponentDescriptor.h>
 #import <ReactNativeEnriched/EventEmitters.h>
 #import <ReactNativeEnriched/Props.h>
 #import <ReactNativeEnriched/RCTComponentViewHelpers.h>
-#import <react/utils/ManagedObjectWrapper.h>
 #import <folly/dynamic.h>
-#import "UIView+React.h"
-#import "StringExtension.h"
-#import "CoreText/CoreText.h"
-#import <React/RCTConversions.h>
-#import "StyleHeaders.h"
-#import "WordsUtils.h"
-#import "LayoutManagerExtension.h"
-#import "ZeroWidthSpaceUtils.h"
-#import "ParagraphAttributesUtils.h"
+#import <react/utils/ManagedObjectWrapper.h>
 
 using namespace facebook::react;
 
-@interface EnrichedTextInputView () <RCTEnrichedTextInputViewViewProtocol, UITextViewDelegate, NSObject>
+@interface EnrichedTextInputView () <RCTEnrichedTextInputViewViewProtocol,
+                                     UITextViewDelegate, NSObject>
 
 @end
 
@@ -26,11 +27,9 @@ using namespace facebook::react;
   EnrichedTextInputViewShadowNode::ConcreteState::Shared _state;
   int _componentViewHeightUpdateCounter;
   NSMutableSet<NSNumber *> *_activeStyles;
-  NSDictionary<NSNumber *, NSArray<NSNumber *> *> *_conflictingStyles;
-  NSDictionary<NSNumber *, NSArray<NSNumber *> *> *_blockingStyles;
   LinkData *_recentlyActiveLinkData;
   NSRange _recentlyActiveLinkRange;
-  NSString *_recentlyEmittedString;
+  NSString *_recentInputString;
   MentionParams *_recentlyActiveMentionParams;
   NSRange _recentlyActiveMentionRange;
   NSString *_recentlyEmittedHtml;
@@ -43,7 +42,8 @@ using namespace facebook::react;
 // MARK: - Component utils
 
 + (ComponentDescriptorProvider)componentDescriptorProvider {
-  return concreteComponentDescriptorProvider<EnrichedTextInputViewComponentDescriptor>();
+  return concreteComponentDescriptorProvider<
+      EnrichedTextInputViewComponentDescriptor>();
 }
 
 Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
@@ -58,7 +58,8 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (instancetype)initWithFrame:(CGRect)frame {
   if (self = [super initWithFrame:frame]) {
-    static const auto defaultProps = std::make_shared<const EnrichedTextInputViewProps>();
+    static const auto defaultProps =
+        std::make_shared<const EnrichedTextInputViewProps>();
     _props = defaultProps;
     [self setDefaults];
     [self setupTextView];
@@ -74,60 +75,116 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   _recentlyActiveLinkRange = NSMakeRange(0, 0);
   _recentlyActiveMentionRange = NSMakeRange(0, 0);
   recentlyChangedRange = NSMakeRange(0, 0);
-  _recentlyEmittedString = @"";
+  _recentInputString = @"";
   _recentlyEmittedHtml = @"<html>\n<p></p>\n</html>";
   _emitHtml = NO;
   blockEmitting = NO;
   _emitFocusBlur = YES;
 
-  defaultTypingAttributes = [[NSMutableDictionary<NSAttributedStringKey, id> alloc] init];
+  defaultTypingAttributes =
+      [[NSMutableDictionary<NSAttributedStringKey, id> alloc] init];
 
   stylesDict = @{
     @([BoldStyle getStyleType]) : [[BoldStyle alloc] initWithInput:self],
-    @([ItalicStyle getStyleType]): [[ItalicStyle alloc] initWithInput:self],
-    @([UnderlineStyle getStyleType]): [[UnderlineStyle alloc] initWithInput:self],
-    @([StrikethroughStyle getStyleType]): [[StrikethroughStyle alloc] initWithInput:self],
-    @([InlineCodeStyle getStyleType]): [[InlineCodeStyle alloc] initWithInput:self],
-    @([LinkStyle getStyleType]): [[LinkStyle alloc] initWithInput:self],
-    @([MentionStyle getStyleType]): [[MentionStyle alloc] initWithInput:self],
-    @([H1Style getStyleType]): [[H1Style alloc] initWithInput:self],
-    @([H2Style getStyleType]): [[H2Style alloc] initWithInput:self],
-    @([H3Style getStyleType]): [[H3Style alloc] initWithInput:self],
-    @([UnorderedListStyle getStyleType]): [[UnorderedListStyle alloc] initWithInput:self],
-    @([OrderedListStyle getStyleType]): [[OrderedListStyle alloc] initWithInput:self],
-    @([BlockQuoteStyle getStyleType]): [[BlockQuoteStyle alloc] initWithInput:self]
+    @([ItalicStyle getStyleType]) : [[ItalicStyle alloc] initWithInput:self],
+    @([UnderlineStyle getStyleType]) :
+        [[UnderlineStyle alloc] initWithInput:self],
+    @([StrikethroughStyle getStyleType]) :
+        [[StrikethroughStyle alloc] initWithInput:self],
+    @([InlineCodeStyle getStyleType]) :
+        [[InlineCodeStyle alloc] initWithInput:self],
+    @([LinkStyle getStyleType]) : [[LinkStyle alloc] initWithInput:self],
+    @([MentionStyle getStyleType]) : [[MentionStyle alloc] initWithInput:self],
+    @([H1Style getStyleType]) : [[H1Style alloc] initWithInput:self],
+    @([H2Style getStyleType]) : [[H2Style alloc] initWithInput:self],
+    @([H3Style getStyleType]) : [[H3Style alloc] initWithInput:self],
+    @([UnorderedListStyle getStyleType]) :
+        [[UnorderedListStyle alloc] initWithInput:self],
+    @([OrderedListStyle getStyleType]) :
+        [[OrderedListStyle alloc] initWithInput:self],
+    @([BlockQuoteStyle getStyleType]) :
+        [[BlockQuoteStyle alloc] initWithInput:self],
+    @([CodeBlockStyle getStyleType]) :
+        [[CodeBlockStyle alloc] initWithInput:self],
+    @([ImageStyle getStyleType]) : [[ImageStyle alloc] initWithInput:self]
   };
 
-  _conflictingStyles = @{
+  conflictingStyles = @{
     @([BoldStyle getStyleType]) : @[],
     @([ItalicStyle getStyleType]) : @[],
     @([UnderlineStyle getStyleType]) : @[],
     @([StrikethroughStyle getStyleType]) : @[],
-    @([InlineCodeStyle getStyleType]) : @[@([LinkStyle getStyleType]), @([MentionStyle getStyleType])],
-    @([LinkStyle getStyleType]): @[@([InlineCodeStyle getStyleType]), @([LinkStyle getStyleType]), @([MentionStyle getStyleType])],
-    @([MentionStyle getStyleType]): @[@([InlineCodeStyle getStyleType]), @([LinkStyle getStyleType])],
-    @([H1Style getStyleType]): @[@([H2Style getStyleType]), @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]), @([BlockQuoteStyle getStyleType])],
-    @([H2Style getStyleType]): @[@([H1Style getStyleType]), @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]), @([BlockQuoteStyle getStyleType])],
-    @([H3Style getStyleType]): @[@([H1Style getStyleType]), @([H2Style getStyleType]), @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]), @([BlockQuoteStyle getStyleType])],
-    @([UnorderedListStyle getStyleType]): @[@([H1Style getStyleType]), @([H2Style getStyleType]), @([H3Style getStyleType]), @([OrderedListStyle getStyleType]), @([BlockQuoteStyle getStyleType])],
-    @([OrderedListStyle getStyleType]): @[@([H1Style getStyleType]), @([H2Style getStyleType]), @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]), @([BlockQuoteStyle getStyleType])],
-    @([BlockQuoteStyle getStyleType]): @[@([H1Style getStyleType]), @([H2Style getStyleType]), @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType])]
+    @([InlineCodeStyle getStyleType]) :
+        @[ @([LinkStyle getStyleType]), @([MentionStyle getStyleType]) ],
+    @([LinkStyle getStyleType]) : @[
+      @([InlineCodeStyle getStyleType]), @([LinkStyle getStyleType]),
+      @([MentionStyle getStyleType])
+    ],
+    @([MentionStyle getStyleType]) :
+        @[ @([InlineCodeStyle getStyleType]), @([LinkStyle getStyleType]) ],
+    @([H1Style getStyleType]) : @[
+      @([H2Style getStyleType]), @([H3Style getStyleType]),
+      @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([H2Style getStyleType]) : @[
+      @([H1Style getStyleType]), @([H3Style getStyleType]),
+      @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([H3Style getStyleType]) : @[
+      @([H1Style getStyleType]), @([H2Style getStyleType]),
+      @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([UnorderedListStyle getStyleType]) : @[
+      @([H1Style getStyleType]), @([H2Style getStyleType]),
+      @([H3Style getStyleType]), @([OrderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([OrderedListStyle getStyleType]) : @[
+      @([H1Style getStyleType]), @([H2Style getStyleType]),
+      @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([BlockQuoteStyle getStyleType]) : @[
+      @([H1Style getStyleType]), @([H2Style getStyleType]),
+      @([H3Style getStyleType]), @([UnorderedListStyle getStyleType]),
+      @([OrderedListStyle getStyleType]), @([CodeBlockStyle getStyleType])
+    ],
+    @([CodeBlockStyle getStyleType]) : @[
+      @([H1Style getStyleType]), @([H2Style getStyleType]),
+      @([H3Style getStyleType]), @([BoldStyle getStyleType]),
+      @([ItalicStyle getStyleType]), @([UnderlineStyle getStyleType]),
+      @([StrikethroughStyle getStyleType]),
+      @([UnorderedListStyle getStyleType]), @([OrderedListStyle getStyleType]),
+      @([BlockQuoteStyle getStyleType]), @([InlineCodeStyle getStyleType]),
+      @([MentionStyle getStyleType]), @([LinkStyle getStyleType])
+    ],
+    @([ImageStyle getStyleType]) :
+        @[ @([LinkStyle getStyleType]), @([MentionStyle getStyleType]) ]
   };
 
-  _blockingStyles = @{
-    @([BoldStyle getStyleType]) : @[],
-    @([ItalicStyle getStyleType]) : @[],
-    @([UnderlineStyle getStyleType]) : @[],
-    @([StrikethroughStyle getStyleType]) : @[],
-    @([InlineCodeStyle getStyleType]) : @[],
-    @([LinkStyle getStyleType]): @[],
-    @([MentionStyle getStyleType]): @[],
-    @([H1Style getStyleType]): @[],
-    @([H2Style getStyleType]): @[],
-    @([H3Style getStyleType]): @[],
-    @([UnorderedListStyle getStyleType]): @[],
-    @([OrderedListStyle getStyleType]): @[],
-    @([BlockQuoteStyle getStyleType]): @[],
+  blockingStyles = @{
+    @([BoldStyle getStyleType]) : @[ @([CodeBlockStyle getStyleType]) ],
+    @([ItalicStyle getStyleType]) : @[ @([CodeBlockStyle getStyleType]) ],
+    @([UnderlineStyle getStyleType]) : @[ @([CodeBlockStyle getStyleType]) ],
+    @([StrikethroughStyle getStyleType]) :
+        @[ @([CodeBlockStyle getStyleType]) ],
+    @([InlineCodeStyle getStyleType]) :
+        @[ @([CodeBlockStyle getStyleType]), @([ImageStyle getStyleType]) ],
+    @([LinkStyle getStyleType]) :
+        @[ @([CodeBlockStyle getStyleType]), @([ImageStyle getStyleType]) ],
+    @([MentionStyle getStyleType]) :
+        @[ @([CodeBlockStyle getStyleType]), @([ImageStyle getStyleType]) ],
+    @([H1Style getStyleType]) : @[],
+    @([H2Style getStyleType]) : @[],
+    @([H3Style getStyleType]) : @[],
+    @([UnorderedListStyle getStyleType]) : @[],
+    @([OrderedListStyle getStyleType]) : @[],
+    @([BlockQuoteStyle getStyleType]) : @[],
+    @([CodeBlockStyle getStyleType]) : @[],
+    @([ImageStyle getStyleType]) : @[ @([InlineCodeStyle getStyleType]) ]
   };
 
   parser = [[InputParser alloc] initWithInput:self];
@@ -147,11 +204,14 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   _placeholderLabel = [[UILabel alloc] initWithFrame:CGRectZero];
   _placeholderLabel.translatesAutoresizingMaskIntoConstraints = NO;
   [textView addSubview:_placeholderLabel];
-  [NSLayoutConstraint activateConstraints: @[
-    [_placeholderLabel.leadingAnchor constraintEqualToAnchor:textView.leadingAnchor],
-    [_placeholderLabel.widthAnchor constraintEqualToAnchor:textView.widthAnchor],
+  [NSLayoutConstraint activateConstraints:@[
+    [_placeholderLabel.leadingAnchor
+        constraintEqualToAnchor:textView.leadingAnchor],
+    [_placeholderLabel.widthAnchor
+        constraintEqualToAnchor:textView.widthAnchor],
     [_placeholderLabel.topAnchor constraintEqualToAnchor:textView.topAnchor],
-    [_placeholderLabel.bottomAnchor constraintEqualToAnchor:textView.bottomAnchor]
+    [_placeholderLabel.bottomAnchor
+        constraintEqualToAnchor:textView.bottomAnchor]
   ]];
   _placeholderLabel.lineBreakMode = NSLineBreakByTruncatingTail;
   _placeholderLabel.text = @"";
@@ -160,14 +220,17 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 // MARK: - Props
 
-- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps {
-  const auto &oldViewProps = *std::static_pointer_cast<EnrichedTextInputViewProps const>(_props);
-  const auto &newViewProps = *std::static_pointer_cast<EnrichedTextInputViewProps const>(props);
+- (void)updateProps:(Props::Shared const &)props
+           oldProps:(Props::Shared const &)oldProps {
+  const auto &oldViewProps =
+      *std::static_pointer_cast<EnrichedTextInputViewProps const>(_props);
+  const auto &newViewProps =
+      *std::static_pointer_cast<EnrichedTextInputViewProps const>(props);
   BOOL isFirstMount = NO;
   BOOL stylePropChanged = NO;
 
   // initial config
-  if(config == nullptr) {
+  if (config == nullptr) {
     isFirstMount = YES;
     config = [[InputConfig alloc] init];
   }
@@ -177,8 +240,8 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
   InputConfig *newConfig = [config copy];
 
-  if(newViewProps.color != oldViewProps.color) {
-    if(isColorMeaningful(newViewProps.color)) {
+  if (newViewProps.color != oldViewProps.color) {
+    if (isColorMeaningful(newViewProps.color)) {
       UIColor *uiColor = RCTUIColorFromSharedColor(newViewProps.color);
       [newConfig setPrimaryColor:uiColor];
     } else {
@@ -187,9 +250,9 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     stylePropChanged = YES;
   }
 
-  if(newViewProps.fontSize != oldViewProps.fontSize) {
-    if(newViewProps.fontSize) {
-      NSNumber* fontSize = @(newViewProps.fontSize);
+  if (newViewProps.fontSize != oldViewProps.fontSize) {
+    if (newViewProps.fontSize) {
+      NSNumber *fontSize = @(newViewProps.fontSize);
       [newConfig setPrimaryFontSize:fontSize];
     } else {
       [newConfig setPrimaryFontSize:nullptr];
@@ -197,18 +260,22 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     stylePropChanged = YES;
   }
 
-  if(newViewProps.fontWeight != oldViewProps.fontWeight) {
-    if(!newViewProps.fontWeight.empty()) {
-      [newConfig setPrimaryFontWeight:[NSString fromCppString:newViewProps.fontWeight]];
+  if (newViewProps.fontWeight != oldViewProps.fontWeight) {
+    if (!newViewProps.fontWeight.empty()) {
+      [newConfig
+          setPrimaryFontWeight:[NSString
+                                   fromCppString:newViewProps.fontWeight]];
     } else {
       [newConfig setPrimaryFontWeight:nullptr];
     }
     stylePropChanged = YES;
   }
 
-  if(newViewProps.fontFamily != oldViewProps.fontFamily) {
-    if(!newViewProps.fontFamily.empty()) {
-      [newConfig setPrimaryFontFamily:[NSString fromCppString:newViewProps.fontFamily]];
+  if (newViewProps.fontFamily != oldViewProps.fontFamily) {
+    if (!newViewProps.fontFamily.empty()) {
+      [newConfig
+          setPrimaryFontFamily:[NSString
+                                   fromCppString:newViewProps.fontFamily]];
     } else {
       [newConfig setPrimaryFontFamily:nullptr];
     }
@@ -217,184 +284,261 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
   // rich text style
 
-  if(newViewProps.htmlStyle.h1.fontSize != oldViewProps.htmlStyle.h1.fontSize) {
+  if (newViewProps.htmlStyle.h1.fontSize !=
+      oldViewProps.htmlStyle.h1.fontSize) {
     [newConfig setH1FontSize:newViewProps.htmlStyle.h1.fontSize];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.h1.bold != oldViewProps.htmlStyle.h1.bold) {
+  if (newViewProps.htmlStyle.h1.bold != oldViewProps.htmlStyle.h1.bold) {
     [newConfig setH1Bold:newViewProps.htmlStyle.h1.bold];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.h2.fontSize != oldViewProps.htmlStyle.h2.fontSize) {
+  if (newViewProps.htmlStyle.h2.fontSize !=
+      oldViewProps.htmlStyle.h2.fontSize) {
     [newConfig setH2FontSize:newViewProps.htmlStyle.h2.fontSize];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.h2.bold != oldViewProps.htmlStyle.h2.bold) {
+  if (newViewProps.htmlStyle.h2.bold != oldViewProps.htmlStyle.h2.bold) {
     [newConfig setH2Bold:newViewProps.htmlStyle.h2.bold];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.h3.fontSize != oldViewProps.htmlStyle.h3.fontSize) {
+  if (newViewProps.htmlStyle.h3.fontSize !=
+      oldViewProps.htmlStyle.h3.fontSize) {
     [newConfig setH3FontSize:newViewProps.htmlStyle.h3.fontSize];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.h3.bold != oldViewProps.htmlStyle.h3.bold) {
+  if (newViewProps.htmlStyle.h3.bold != oldViewProps.htmlStyle.h3.bold) {
     [newConfig setH3Bold:newViewProps.htmlStyle.h3.bold];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.blockquote.borderColor != oldViewProps.htmlStyle.blockquote.borderColor) {
-    if(isColorMeaningful(newViewProps.htmlStyle.blockquote.borderColor)) {
-      [newConfig setBlockquoteBorderColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.blockquote.borderColor)];
+  if (newViewProps.htmlStyle.blockquote.borderColor !=
+      oldViewProps.htmlStyle.blockquote.borderColor) {
+    if (isColorMeaningful(newViewProps.htmlStyle.blockquote.borderColor)) {
+      [newConfig setBlockquoteBorderColor:RCTUIColorFromSharedColor(
+                                              newViewProps.htmlStyle.blockquote
+                                                  .borderColor)];
       stylePropChanged = YES;
     }
   }
 
-  if(newViewProps.htmlStyle.blockquote.borderWidth != oldViewProps.htmlStyle.blockquote.borderWidth) {
-    [newConfig setBlockquoteBorderWidth:newViewProps.htmlStyle.blockquote.borderWidth];
+  if (newViewProps.htmlStyle.blockquote.borderWidth !=
+      oldViewProps.htmlStyle.blockquote.borderWidth) {
+    [newConfig
+        setBlockquoteBorderWidth:newViewProps.htmlStyle.blockquote.borderWidth];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.blockquote.gapWidth != oldViewProps.htmlStyle.blockquote.gapWidth) {
-    [newConfig setBlockquoteGapWidth:newViewProps.htmlStyle.blockquote.gapWidth];
+  if (newViewProps.htmlStyle.blockquote.gapWidth !=
+      oldViewProps.htmlStyle.blockquote.gapWidth) {
+    [newConfig
+        setBlockquoteGapWidth:newViewProps.htmlStyle.blockquote.gapWidth];
     stylePropChanged = YES;
   }
 
-  // since this prop defaults to undefined on JS side, we need to force set the value on first mount
-  if(newViewProps.htmlStyle.blockquote.color != oldViewProps.htmlStyle.blockquote.color || isFirstMount) {
-    if(isColorMeaningful(newViewProps.htmlStyle.blockquote.color)) {
-      [newConfig setBlockquoteColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.blockquote.color)];
+  // since this prop defaults to undefined on JS side, we need to force set the
+  // value on first mount
+  if (newViewProps.htmlStyle.blockquote.color !=
+          oldViewProps.htmlStyle.blockquote.color ||
+      isFirstMount) {
+    if (isColorMeaningful(newViewProps.htmlStyle.blockquote.color)) {
+      [newConfig
+          setBlockquoteColor:RCTUIColorFromSharedColor(
+                                 newViewProps.htmlStyle.blockquote.color)];
     } else {
       [newConfig setBlockquoteColor:[newConfig primaryColor]];
     }
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.code.color != oldViewProps.htmlStyle.code.color) {
-    if(isColorMeaningful(newViewProps.htmlStyle.code.color)) {
-      [newConfig setInlineCodeFgColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.code.color)];
+  if (newViewProps.htmlStyle.code.color != oldViewProps.htmlStyle.code.color) {
+    if (isColorMeaningful(newViewProps.htmlStyle.code.color)) {
+      [newConfig setInlineCodeFgColor:RCTUIColorFromSharedColor(
+                                          newViewProps.htmlStyle.code.color)];
       stylePropChanged = YES;
     }
   }
 
-  if(newViewProps.htmlStyle.code.backgroundColor != oldViewProps.htmlStyle.code.backgroundColor) {
-    if(isColorMeaningful(newViewProps.htmlStyle.code.backgroundColor)) {
-      [newConfig setInlineCodeBgColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.code.backgroundColor)];
+  if (newViewProps.htmlStyle.code.backgroundColor !=
+      oldViewProps.htmlStyle.code.backgroundColor) {
+    if (isColorMeaningful(newViewProps.htmlStyle.code.backgroundColor)) {
+      [newConfig setInlineCodeBgColor:RCTUIColorFromSharedColor(
+                                          newViewProps.htmlStyle.code
+                                              .backgroundColor)];
       stylePropChanged = YES;
     }
   }
 
-  if(newViewProps.htmlStyle.ol.gapWidth != oldViewProps.htmlStyle.ol.gapWidth) {
+  if (newViewProps.htmlStyle.ol.gapWidth !=
+      oldViewProps.htmlStyle.ol.gapWidth) {
     [newConfig setOrderedListGapWidth:newViewProps.htmlStyle.ol.gapWidth];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.ol.marginLeft != oldViewProps.htmlStyle.ol.marginLeft) {
+  if (newViewProps.htmlStyle.ol.marginLeft !=
+      oldViewProps.htmlStyle.ol.marginLeft) {
     [newConfig setOrderedListMarginLeft:newViewProps.htmlStyle.ol.marginLeft];
     stylePropChanged = YES;
   }
 
-  // since this prop defaults to undefined on JS side, we need to force set the value on first mount
-  if(newViewProps.htmlStyle.ol.markerFontWeight != oldViewProps.htmlStyle.ol.markerFontWeight || isFirstMount) {
-    if(!newViewProps.htmlStyle.ol.markerFontWeight.empty()) {
-      [newConfig setOrderedListMarkerFontWeight:[NSString fromCppString: newViewProps.htmlStyle.ol.markerFontWeight]];
+  // since this prop defaults to undefined on JS side, we need to force set the
+  // value on first mount
+  if (newViewProps.htmlStyle.ol.markerFontWeight !=
+          oldViewProps.htmlStyle.ol.markerFontWeight ||
+      isFirstMount) {
+    if (!newViewProps.htmlStyle.ol.markerFontWeight.empty()) {
+      [newConfig
+          setOrderedListMarkerFontWeight:
+              [NSString
+                  fromCppString:newViewProps.htmlStyle.ol.markerFontWeight]];
     } else {
       [newConfig setOrderedListMarkerFontWeight:[newConfig primaryFontWeight]];
     }
     stylePropChanged = YES;
   }
 
-  // since this prop defaults to undefined on JS side, we need to force set the value on first mount
-  if(newViewProps.htmlStyle.ol.markerColor != oldViewProps.htmlStyle.ol.markerColor || isFirstMount) {
-    if(isColorMeaningful(newViewProps.htmlStyle.ol.markerColor)) {
-      [newConfig setOrderedListMarkerColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.ol.markerColor)];
+  // since this prop defaults to undefined on JS side, we need to force set the
+  // value on first mount
+  if (newViewProps.htmlStyle.ol.markerColor !=
+          oldViewProps.htmlStyle.ol.markerColor ||
+      isFirstMount) {
+    if (isColorMeaningful(newViewProps.htmlStyle.ol.markerColor)) {
+      [newConfig
+          setOrderedListMarkerColor:RCTUIColorFromSharedColor(
+                                        newViewProps.htmlStyle.ol.markerColor)];
     } else {
       [newConfig setOrderedListMarkerColor:[newConfig primaryColor]];
     }
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.ul.bulletColor != oldViewProps.htmlStyle.ul.bulletColor) {
-    if(isColorMeaningful(newViewProps.htmlStyle.ul.bulletColor)) {
-      [newConfig setUnorderedListBulletColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.ul.bulletColor)];
+  if (newViewProps.htmlStyle.ul.bulletColor !=
+      oldViewProps.htmlStyle.ul.bulletColor) {
+    if (isColorMeaningful(newViewProps.htmlStyle.ul.bulletColor)) {
+      [newConfig setUnorderedListBulletColor:RCTUIColorFromSharedColor(
+                                                 newViewProps.htmlStyle.ul
+                                                     .bulletColor)];
       stylePropChanged = YES;
     }
   }
 
-  if(newViewProps.htmlStyle.ul.bulletSize != oldViewProps.htmlStyle.ul.bulletSize) {
+  if (newViewProps.htmlStyle.ul.bulletSize !=
+      oldViewProps.htmlStyle.ul.bulletSize) {
     [newConfig setUnorderedListBulletSize:newViewProps.htmlStyle.ul.bulletSize];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.ul.gapWidth != oldViewProps.htmlStyle.ul.gapWidth) {
+  if (newViewProps.htmlStyle.ul.gapWidth !=
+      oldViewProps.htmlStyle.ul.gapWidth) {
     [newConfig setUnorderedListGapWidth:newViewProps.htmlStyle.ul.gapWidth];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.ul.marginLeft != oldViewProps.htmlStyle.ul.marginLeft) {
+  if (newViewProps.htmlStyle.ul.marginLeft !=
+      oldViewProps.htmlStyle.ul.marginLeft) {
     [newConfig setUnorderedListMarginLeft:newViewProps.htmlStyle.ul.marginLeft];
     stylePropChanged = YES;
   }
 
-  if(newViewProps.htmlStyle.a.color != oldViewProps.htmlStyle.a.color) {
-    if(isColorMeaningful(newViewProps.htmlStyle.a.color)) {
-      [newConfig setLinkColor:RCTUIColorFromSharedColor(newViewProps.htmlStyle.a.color)];
+  if (newViewProps.htmlStyle.a.color != oldViewProps.htmlStyle.a.color) {
+    if (isColorMeaningful(newViewProps.htmlStyle.a.color)) {
+      [newConfig setLinkColor:RCTUIColorFromSharedColor(
+                                  newViewProps.htmlStyle.a.color)];
+      stylePropChanged = YES;
+    }
+  }
+
+  if (newViewProps.htmlStyle.codeblock.color !=
+      oldViewProps.htmlStyle.codeblock.color) {
+    if (isColorMeaningful(newViewProps.htmlStyle.codeblock.color)) {
+      [newConfig
+          setCodeBlockFgColor:RCTUIColorFromSharedColor(
+                                  newViewProps.htmlStyle.codeblock.color)];
       stylePropChanged = YES;
     }
   }
 
-  if(newViewProps.htmlStyle.a.textDecorationLine != oldViewProps.htmlStyle.a.textDecorationLine) {
-    NSString *objcString = [NSString fromCppString:newViewProps.htmlStyle.a.textDecorationLine];
-    if([objcString isEqualToString:DecorationUnderline]) {
+  if (newViewProps.htmlStyle.codeblock.backgroundColor !=
+      oldViewProps.htmlStyle.codeblock.backgroundColor) {
+    if (isColorMeaningful(newViewProps.htmlStyle.codeblock.backgroundColor)) {
+      [newConfig setCodeBlockBgColor:RCTUIColorFromSharedColor(
+                                         newViewProps.htmlStyle.codeblock
+                                             .backgroundColor)];
+      stylePropChanged = YES;
+    }
+  }
+
+  if (newViewProps.htmlStyle.codeblock.borderRadius !=
+      oldViewProps.htmlStyle.codeblock.borderRadius) {
+    [newConfig
+        setCodeBlockBorderRadius:newViewProps.htmlStyle.codeblock.borderRadius];
+    stylePropChanged = YES;
+  }
+
+  if (newViewProps.htmlStyle.a.textDecorationLine !=
+      oldViewProps.htmlStyle.a.textDecorationLine) {
+    NSString *objcString =
+        [NSString fromCppString:newViewProps.htmlStyle.a.textDecorationLine];
+    if ([objcString isEqualToString:DecorationUnderline]) {
       [newConfig setLinkDecorationLine:DecorationUnderline];
     } else {
-      // both DecorationNone and a different, wrong value gets a DecorationNone here
+      // both DecorationNone and a different, wrong value gets a DecorationNone
+      // here
       [newConfig setLinkDecorationLine:DecorationNone];
     }
     stylePropChanged = YES;
   }
 
-  if(newViewProps.scrollEnabled != oldViewProps.scrollEnabled || textView.scrollEnabled != newViewProps.scrollEnabled) {
+  if (newViewProps.scrollEnabled != oldViewProps.scrollEnabled ||
+      textView.scrollEnabled != newViewProps.scrollEnabled) {
     [textView setScrollEnabled:newViewProps.scrollEnabled];
   }
 
   folly::dynamic oldMentionStyle = oldViewProps.htmlStyle.mention;
   folly::dynamic newMentionStyle = newViewProps.htmlStyle.mention;
-  if(oldMentionStyle != newMentionStyle) {
+  if (oldMentionStyle != newMentionStyle) {
     bool newSingleProps = NO;
 
-    for(const auto& obj : newMentionStyle.items()) {
-      if(obj.second.isInt() || obj.second.isString()) {
+    for (const auto &obj : newMentionStyle.items()) {
+      if (obj.second.isInt() || obj.second.isString()) {
         // we are in just a single MentionStyleProps object
         newSingleProps = YES;
         break;
-      } else if(obj.second.isObject()) {
+      } else if (obj.second.isObject()) {
         // we are in map of indicators to MentionStyleProps
         newSingleProps = NO;
         break;
       }
     }
 
-    if(newSingleProps) {
-      [newConfig setMentionStyleProps:[MentionStyleProps getSinglePropsFromFollyDynamic:newMentionStyle]];
+    if (newSingleProps) {
+      [newConfig setMentionStyleProps:
+                     [MentionStyleProps
+                         getSinglePropsFromFollyDynamic:newMentionStyle]];
     } else {
-      [newConfig setMentionStyleProps:[MentionStyleProps getComplexPropsFromFollyDynamic:newMentionStyle]];
+      [newConfig setMentionStyleProps:
+                     [MentionStyleProps
+                         getComplexPropsFromFollyDynamic:newMentionStyle]];
     }
 
     stylePropChanged = YES;
   }
 
-  if(stylePropChanged) {
+  if (stylePropChanged) {
     // all the text needs to be rebuilt
-    // we get the current html using old config, then switch to new config and replace text using the html
-    // this way, the newest config attributes are being used!
+    // we get the current html using old config, then switch to new config and
+    // replace text using the html this way, the newest config attributes are
+    // being used!
 
     // the html needs to be generated using the old config
-    NSString *currentHtml = [parser parseToHtmlFromRange:NSMakeRange(0, textView.textStorage.string.length)];
+    NSString *currentHtml = [parser
+        parseToHtmlFromRange:NSMakeRange(0,
+                                         textView.textStorage.string.length)];
 
     // now set the new config
     config = newConfig;
@@ -403,19 +547,24 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     blockEmitting = YES;
 
     // make sure everything is sound in the html
-    NSString *initiallyProcessedHtml = [parser initiallyProcessHtml:currentHtml];
-    if(initiallyProcessedHtml != nullptr) {
+    NSString *initiallyProcessedHtml =
+        [parser initiallyProcessHtml:currentHtml];
+    if (initiallyProcessedHtml != nullptr) {
       [parser replaceWholeFromHtml:initiallyProcessedHtml];
     }
 
     blockEmitting = NO;
 
     // fill the typing attributes with style props
-    defaultTypingAttributes[NSForegroundColorAttributeName] = [config primaryColor];
+    defaultTypingAttributes[NSForegroundColorAttributeName] =
+        [config primaryColor];
     defaultTypingAttributes[NSFontAttributeName] = [config primaryFont];
-    defaultTypingAttributes[NSUnderlineColorAttributeName] = [config primaryColor];
-    defaultTypingAttributes[NSStrikethroughColorAttributeName] = [config primaryColor];
-    defaultTypingAttributes[NSParagraphStyleAttributeName] = [[NSParagraphStyle alloc] init];
+    defaultTypingAttributes[NSUnderlineColorAttributeName] =
+        [config primaryColor];
+    defaultTypingAttributes[NSStrikethroughColorAttributeName] =
+        [config primaryColor];
+    defaultTypingAttributes[NSParagraphStyleAttributeName] =
+        [[NSParagraphStyle alloc] init];
     textView.typingAttributes = defaultTypingAttributes;
 
     // update the placeholder as well
@@ -423,16 +572,19 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   }
 
   // editable
-  if(newViewProps.editable != textView.editable) {
+  if (newViewProps.editable != textView.editable) {
     textView.editable = newViewProps.editable;
   }
 
-  // default value - must be set before placeholder to make sure it correctly shows on first mount
-  if(newViewProps.defaultValue != oldViewProps.defaultValue) {
-    NSString *newDefaultValue = [NSString fromCppString:newViewProps.defaultValue];
+  // default value - must be set before placeholder to make sure it correctly
+  // shows on first mount
+  if (newViewProps.defaultValue != oldViewProps.defaultValue) {
+    NSString *newDefaultValue =
+        [NSString fromCppString:newViewProps.defaultValue];
 
-    NSString *initiallyProcessedHtml = [parser initiallyProcessHtml:newDefaultValue];
-    if(initiallyProcessedHtml == nullptr) {
+    NSString *initiallyProcessedHtml =
+        [parser initiallyProcessHtml:newDefaultValue];
+    if (initiallyProcessedHtml == nullptr) {
       // just plain text
       textView.text = newDefaultValue;
     } else {
@@ -442,10 +594,11 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   }
 
   // placeholderTextColor
-  if(newViewProps.placeholderTextColor != oldViewProps.placeholderTextColor) {
+  if (newViewProps.placeholderTextColor != oldViewProps.placeholderTextColor) {
     // some real color
-    if(isColorMeaningful(newViewProps.placeholderTextColor)) {
-      _placeholderColor = RCTUIColorFromSharedColor(newViewProps.placeholderTextColor);
+    if (isColorMeaningful(newViewProps.placeholderTextColor)) {
+      _placeholderColor =
+          RCTUIColorFromSharedColor(newViewProps.placeholderTextColor);
     } else {
       _placeholderColor = nullptr;
     }
@@ -453,24 +606,25 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   }
 
   // placeholder
-  if(newViewProps.placeholder != oldViewProps.placeholder) {
+  if (newViewProps.placeholder != oldViewProps.placeholder) {
     _placeholderLabel.text = [NSString fromCppString:newViewProps.placeholder];
     [self refreshPlaceholderLabelStyles];
     // additionally show placeholder on first mount if it should be there
-    if(isFirstMount && textView.text.length == 0) {
+    if (isFirstMount && textView.text.length == 0) {
       [self setPlaceholderLabelShown:YES];
     }
   }
 
   // mention indicators
-  auto mismatchPair = std::mismatch(
-    newViewProps.mentionIndicators.begin(), newViewProps.mentionIndicators.end(),
-    oldViewProps.mentionIndicators.begin(), oldViewProps.mentionIndicators.end()
-  );
-  if(mismatchPair.first != newViewProps.mentionIndicators.end() || mismatchPair.second != oldViewProps.mentionIndicators.end()) {
+  auto mismatchPair = std::mismatch(newViewProps.mentionIndicators.begin(),
+                                    newViewProps.mentionIndicators.end(),
+                                    oldViewProps.mentionIndicators.begin(),
+                                    oldViewProps.mentionIndicators.end());
+  if (mismatchPair.first != newViewProps.mentionIndicators.end() ||
+      mismatchPair.second != oldViewProps.mentionIndicators.end()) {
     NSMutableSet<NSNumber *> *newIndicators = [[NSMutableSet alloc] init];
-    for(const std::string &item : newViewProps.mentionIndicators) {
-      if(item.length() == 1) {
+    for (const std::string &item : newViewProps.mentionIndicators) {
+      if (item.length() == 1) {
         [newIndicators addObject:@(item[0])];
       }
     }
@@ -478,29 +632,32 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   }
 
   // selection color sets both selection and cursor on iOS (just as in RN)
-  if(newViewProps.selectionColor != oldViewProps.selectionColor) {
-    if(isColorMeaningful(newViewProps.selectionColor)) {
-      textView.tintColor = RCTUIColorFromSharedColor(newViewProps.selectionColor);
+  if (newViewProps.selectionColor != oldViewProps.selectionColor) {
+    if (isColorMeaningful(newViewProps.selectionColor)) {
+      textView.tintColor =
+          RCTUIColorFromSharedColor(newViewProps.selectionColor);
     } else {
       textView.tintColor = nullptr;
     }
   }
 
   // autoCapitalize
-  if(newViewProps.autoCapitalize != oldViewProps.autoCapitalize) {
+  if (newViewProps.autoCapitalize != oldViewProps.autoCapitalize) {
     NSString *str = [NSString fromCppString:newViewProps.autoCapitalize];
-    if([str isEqualToString: @"none"]) {
+    if ([str isEqualToString:@"none"]) {
       textView.autocapitalizationType = UITextAutocapitalizationTypeNone;
-    } else if([str isEqualToString: @"sentences"]) {
+    } else if ([str isEqualToString:@"sentences"]) {
       textView.autocapitalizationType = UITextAutocapitalizationTypeSentences;
-    } else if([str isEqualToString: @"words"]) {
+    } else if ([str isEqualToString:@"words"]) {
       textView.autocapitalizationType = UITextAutocapitalizationTypeWords;
-    } else if([str isEqualToString: @"characters"]) {
-      textView.autocapitalizationType = UITextAutocapitalizationTypeAllCharacters;
+    } else if ([str isEqualToString:@"characters"]) {
+      textView.autocapitalizationType =
+          UITextAutocapitalizationTypeAllCharacters;
     }
 
-    // textView needs to be refocused on autocapitalization type change and we don't want to emit these events
-    if([textView isFirstResponder]) {
+    // textView needs to be refocused on autocapitalization type change and we
+    // don't want to emit these events
+    if ([textView isFirstResponder]) {
       _emitFocusBlur = NO;
       [textView reactBlur];
       [textView reactFocus];
@@ -512,18 +669,17 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   _emitHtml = newViewProps.isOnChangeHtmlSet;
 
   [super updateProps:props oldProps:oldProps];
-  // mandatory text and height checks
+  // run the changes callback
   [self anyTextMayHaveBeenModified];
-  [self tryUpdatingHeight];
 
   // autofocus - needs to be done at the very end
-  if(isFirstMount && newViewProps.autoFocus) {
+  if (isFirstMount && newViewProps.autoFocus) {
     [textView reactFocus];
   }
 }
 
 - (void)setPlaceholderLabelShown:(BOOL)shown {
-  if(shown) {
+  if (shown) {
     [self refreshPlaceholderLabelStyles];
     _placeholderLabel.hidden = NO;
   } else {
@@ -533,10 +689,12 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)refreshPlaceholderLabelStyles {
   NSMutableDictionary *newAttrs = [defaultTypingAttributes mutableCopy];
-  if(_placeholderColor != nullptr) {
+  if (_placeholderColor != nullptr) {
     newAttrs[NSForegroundColorAttributeName] = _placeholderColor;
   }
-  NSAttributedString *newAttrStr = [[NSAttributedString alloc] initWithString:_placeholderLabel.text attributes: newAttrs];
+  NSAttributedString *newAttrStr =
+      [[NSAttributedString alloc] initWithString:_placeholderLabel.text
+                                      attributes:newAttrs];
   _placeholderLabel.attributedText = newAttrStr;
 }
 
@@ -544,68 +702,84 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (CGSize)measureSize:(CGFloat)maxWidth {
   // copy the the whole attributed string
-  NSMutableAttributedString *currentStr = [[NSMutableAttributedString alloc] initWithAttributedString:textView.textStorage];
-  
-  // edge case: empty input should still be of a height of a single line, so we add a mock "I" character
-  if([currentStr length] == 0 ) {
-    [currentStr appendAttributedString:
-       [[NSAttributedString alloc] initWithString:@"I" attributes:textView.typingAttributes]
-    ];
-  }
-  
-  // edge case: input with only a zero width space should still be of a height of a single line, so we add a mock "I" character
-  if([currentStr length] == 1 && [[currentStr.string substringWithRange:NSMakeRange(0, 1)] isEqualToString:@"\u200B"]) {
-    [currentStr appendAttributedString:
-       [[NSAttributedString alloc] initWithString:@"I" attributes:textView.typingAttributes]
-    ];
-  }
-  
-  // edge case: trailing newlines aren't counted towards height calculations, so we add a mock "I" character
-  if(currentStr.length > 0) {
-    unichar lastChar = [currentStr.string characterAtIndex:currentStr.length-1];
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:lastChar]) {
-      [currentStr appendAttributedString:
-        [[NSAttributedString alloc] initWithString:@"I" attributes:defaultTypingAttributes]
-      ];
+  NSMutableAttributedString *currentStr = [[NSMutableAttributedString alloc]
+      initWithAttributedString:textView.textStorage];
+
+  // edge case: empty input should still be of a height of a single line, so we
+  // add a mock "I" character
+  if ([currentStr length] == 0) {
+    [currentStr
+        appendAttributedString:[[NSAttributedString alloc]
+                                   initWithString:@"I"
+                                       attributes:textView.typingAttributes]];
+  }
+
+  // edge case: input with only a zero width space should still be of a height
+  // of a single line, so we add a mock "I" character
+  if ([currentStr length] == 1 &&
+      [[currentStr.string substringWithRange:NSMakeRange(0, 1)]
+          isEqualToString:@"\u200B"]) {
+    [currentStr
+        appendAttributedString:[[NSAttributedString alloc]
+                                   initWithString:@"I"
+                                       attributes:textView.typingAttributes]];
+  }
+
+  // edge case: trailing newlines aren't counted towards height calculations, so
+  // we add a mock "I" character
+  if (currentStr.length > 0) {
+    unichar lastChar =
+        [currentStr.string characterAtIndex:currentStr.length - 1];
+    if ([[NSCharacterSet newlineCharacterSet] characterIsMember:lastChar]) {
+      [currentStr
+          appendAttributedString:[[NSAttributedString alloc]
+                                     initWithString:@"I"
+                                         attributes:defaultTypingAttributes]];
     }
   }
 
-  CGRect boundingBox = [currentStr boundingRectWithSize:
-    CGSizeMake(maxWidth, CGFLOAT_MAX)
-    options: NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading
-    context: nullptr
-  ];
+  CGRect boundingBox =
+      [currentStr boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX)
+                               options:NSStringDrawingUsesLineFragmentOrigin |
+                                       NSStringDrawingUsesFontLeading
+                               context:nullptr];
 
   return CGSizeMake(maxWidth, ceil(boundingBox.size.height));
 }
 
 // make sure the newest state is kept in _state property
-- (void)updateState:(State::Shared const &)state oldState:(State::Shared const &)oldState {
-  _state = std::static_pointer_cast<const EnrichedTextInputViewShadowNode::ConcreteState>(state);
-  
-  // first render with all the needed stuff already defined (state and componentView)
-  // so we need to run a single height calculation for any initial values
-  if(oldState == nullptr) {
+- (void)updateState:(State::Shared const &)state
+           oldState:(State::Shared const &)oldState {
+  _state = std::static_pointer_cast<
+      const EnrichedTextInputViewShadowNode::ConcreteState>(state);
+
+  // first render with all the needed stuff already defined (state and
+  // componentView) so we need to run a single height calculation for any
+  // initial values
+  if (oldState == nullptr) {
     [self tryUpdatingHeight];
   }
 }
 
 - (void)tryUpdatingHeight {
-  if(_state == nullptr) {
+  if (_state == nullptr) {
     return;
   }
   _componentViewHeightUpdateCounter++;
   auto selfRef = wrapManagedObjectWeakly(self);
-  _state->updateState(EnrichedTextInputViewState(_componentViewHeightUpdateCounter, selfRef));
+  _state->updateState(
+      EnrichedTextInputViewState(_componentViewHeightUpdateCounter, selfRef));
 }
 
 // MARK: - Active styles
 
 - (void)tryUpdatingActiveStyles {
-  // style updates are emitted only if something differs from the previously active styles
+  // style updates are emitted only if something differs from the previously
+  // active styles
   BOOL updateNeeded = NO;
 
-  // active styles are kept in a separate set until we're sure they can be emitted
+  // active styles are kept in a separate set until we're sure they can be
+  // emitted
   NSMutableSet *newActiveStyles = [_activeStyles mutableCopy];
 
   // data for onLinkDetected event
@@ -616,13 +790,13 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   MentionParams *detectedMentionParams;
   NSRange detectedMentionRange = NSMakeRange(0, 0);
 
-  for (NSNumber* type in stylesDict) {
+  for (NSNumber *type in stylesDict) {
     id<BaseStyleProtocol> style = stylesDict[type];
-    BOOL wasActive = [newActiveStyles containsObject: type];
+    BOOL wasActive = [newActiveStyles containsObject:type];
     BOOL isActive = [style detectStyle:textView.selectedRange];
-    if(wasActive != isActive) {
+    if (wasActive != isActive) {
       updateNeeded = YES;
-      if(isActive) {
+      if (isActive) {
         [newActiveStyles addObject:type];
       } else {
         [newActiveStyles removeObject:type];
@@ -630,51 +804,59 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     }
 
     // onLinkDetected event
-    if(isActive && [type intValue] == [LinkStyle getStyleType]) {
+    if (isActive && [type intValue] == [LinkStyle getStyleType]) {
       // get the link data
       LinkData *candidateLinkData;
       NSRange candidateLinkRange = NSMakeRange(0, 0);
-      LinkStyle *linkStyleClass = (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
-      if(linkStyleClass != nullptr) {
-        candidateLinkData = [linkStyleClass getLinkDataAt:textView.selectedRange.location];
-        candidateLinkRange = [linkStyleClass getFullLinkRangeAt:textView.selectedRange.location];
+      LinkStyle *linkStyleClass =
+          (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
+      if (linkStyleClass != nullptr) {
+        candidateLinkData =
+            [linkStyleClass getLinkDataAt:textView.selectedRange.location];
+        candidateLinkRange =
+            [linkStyleClass getFullLinkRangeAt:textView.selectedRange.location];
       }
 
-      if(wasActive == NO) {
+      if (wasActive == NO) {
         // we changed selection from non-link to a link
         detectedLinkData = candidateLinkData;
         detectedLinkRange = candidateLinkRange;
-      } else if(
-        ![_recentlyActiveLinkData.url isEqualToString:candidateLinkData.url] ||
-        ![_recentlyActiveLinkData.text isEqualToString:candidateLinkData.text] ||
-        !NSEqualRanges(_recentlyActiveLinkRange, candidateLinkRange)
-      ) {
-        // we changed selection from one link to the other or modified current link's text
+      } else if (![_recentlyActiveLinkData.url
+                     isEqualToString:candidateLinkData.url] ||
+                 ![_recentlyActiveLinkData.text
+                     isEqualToString:candidateLinkData.text] ||
+                 !NSEqualRanges(_recentlyActiveLinkRange, candidateLinkRange)) {
+        // we changed selection from one link to the other or modified current
+        // link's text
         detectedLinkData = candidateLinkData;
         detectedLinkRange = candidateLinkRange;
       }
     }
 
     // onMentionDetected event
-    if(isActive && [type intValue] == [MentionStyle getStyleType]) {
+    if (isActive && [type intValue] == [MentionStyle getStyleType]) {
       // get mention data
       MentionParams *candidateMentionParams;
       NSRange candidateMentionRange = NSMakeRange(0, 0);
-      MentionStyle *mentionStyleClass = (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
-      if(mentionStyleClass != nullptr) {
-        candidateMentionParams = [mentionStyleClass getMentionParamsAt:textView.selectedRange.location];
-        candidateMentionRange = [mentionStyleClass getFullMentionRangeAt:textView.selectedRange.location];
+      MentionStyle *mentionStyleClass =
+          (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
+      if (mentionStyleClass != nullptr) {
+        candidateMentionParams = [mentionStyleClass
+            getMentionParamsAt:textView.selectedRange.location];
+        candidateMentionRange = [mentionStyleClass
+            getFullMentionRangeAt:textView.selectedRange.location];
       }
 
-      if(wasActive == NO) {
+      if (wasActive == NO) {
         // selection was changed from a non-mention to a mention
         detectedMentionParams = candidateMentionParams;
         detectedMentionRange = candidateMentionRange;
-      } else if(
-        ![_recentlyActiveMentionParams.text isEqualToString:candidateMentionParams.text] ||
-        ![_recentlyActiveMentionParams.attributes isEqualToString:candidateMentionParams.attributes] ||
-        !NSEqualRanges(_recentlyActiveMentionRange, candidateMentionRange)
-      ) {
+      } else if (![_recentlyActiveMentionParams.text
+                     isEqualToString:candidateMentionParams.text] ||
+                 ![_recentlyActiveMentionParams.attributes
+                     isEqualToString:candidateMentionParams.attributes] ||
+                 !NSEqualRanges(_recentlyActiveMentionRange,
+                                candidateMentionRange)) {
         // selection changed from one mention to another
         detectedMentionParams = candidateMentionParams;
         detectedMentionRange = candidateMentionRange;
@@ -682,40 +864,53 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     }
   }
 
-  if(updateNeeded) {
+  if (updateNeeded) {
     auto emitter = [self getEventEmitter];
-    if(emitter != nullptr) {
+    if (emitter != nullptr) {
       // update activeStyles only if emitter is available
       _activeStyles = newActiveStyles;
 
       emitter->onChangeState({
-        .isBold = [_activeStyles containsObject: @([BoldStyle getStyleType])],
-        .isItalic = [_activeStyles containsObject: @([ItalicStyle getStyleType])],
-        .isUnderline = [_activeStyles containsObject: @([UnderlineStyle getStyleType])],
-        .isStrikeThrough = [_activeStyles containsObject: @([StrikethroughStyle getStyleType])],
-        .isInlineCode = [_activeStyles containsObject: @([InlineCodeStyle getStyleType])],
-        .isLink = [_activeStyles containsObject: @([LinkStyle getStyleType])],
-        .isMention = [_activeStyles containsObject: @([MentionStyle getStyleType])],
-        .isH1 = [_activeStyles containsObject: @([H1Style getStyleType])],
-        .isH2 = [_activeStyles containsObject: @([H2Style getStyleType])],
-        .isH3 = [_activeStyles containsObject: @([H3Style getStyleType])],
-        .isUnorderedList = [_activeStyles containsObject: @([UnorderedListStyle getStyleType])],
-        .isOrderedList = [_activeStyles containsObject: @([OrderedListStyle getStyleType])],
-        .isBlockQuote = [_activeStyles containsObject: @([BlockQuoteStyle getStyleType])],
-        .isCodeBlock = NO, // [_activeStyles containsObject: @([CodeBlockStyle getStyleType])],
-        .isImage = NO // [_activeStyles containsObject: @([ImageStyle getStyleType]])],
+        .isBold = [_activeStyles containsObject:@([BoldStyle getStyleType])],
+        .isItalic =
+            [_activeStyles containsObject:@([ItalicStyle getStyleType])],
+        .isUnderline =
+            [_activeStyles containsObject:@([UnderlineStyle getStyleType])],
+        .isStrikeThrough =
+            [_activeStyles containsObject:@([StrikethroughStyle getStyleType])],
+        .isInlineCode =
+            [_activeStyles containsObject:@([InlineCodeStyle getStyleType])],
+        .isLink = [_activeStyles containsObject:@([LinkStyle getStyleType])],
+        .isMention =
+            [_activeStyles containsObject:@([MentionStyle getStyleType])],
+        .isH1 = [_activeStyles containsObject:@([H1Style getStyleType])],
+        .isH2 = [_activeStyles containsObject:@([H2Style getStyleType])],
+        .isH3 = [_activeStyles containsObject:@([H3Style getStyleType])],
+        .isUnorderedList =
+            [_activeStyles containsObject:@([UnorderedListStyle getStyleType])],
+        .isOrderedList =
+            [_activeStyles containsObject:@([OrderedListStyle getStyleType])],
+        .isBlockQuote =
+            [_activeStyles containsObject:@([BlockQuoteStyle getStyleType])],
+        .isCodeBlock =
+            [_activeStyles containsObject:@([CodeBlockStyle getStyleType])],
+        .isImage = [_activeStyles containsObject:@([ImageStyle getStyleType])],
       });
     }
   }
 
-  if(detectedLinkData != nullptr) {
+  if (detectedLinkData != nullptr) {
     // emit onLinkeDetected event
-    [self emitOnLinkDetectedEvent:detectedLinkData.text url:detectedLinkData.url range:detectedLinkRange];
+    [self emitOnLinkDetectedEvent:detectedLinkData.text
+                              url:detectedLinkData.url
+                            range:detectedLinkRange];
   }
 
-  if(detectedMentionParams != nullptr) {
+  if (detectedMentionParams != nullptr) {
     // emit onMentionDetected event
-    [self emitOnMentionDetectedEvent:detectedMentionParams.text indicator:detectedMentionParams.indicator attributes:detectedMentionParams.attributes];
+    [self emitOnMentionDetectedEvent:detectedMentionParams.text
+                           indicator:detectedMentionParams.indicator
+                          attributes:detectedMentionParams.attributes];
 
     _recentlyActiveMentionParams = detectedMentionParams;
     _recentlyActiveMentionRange = detectedMentionRange;
@@ -728,55 +923,67 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 // MARK: - Native commands and events
 
 - (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args {
-  if([commandName isEqualToString:@"focus"]) {
+  if ([commandName isEqualToString:@"focus"]) {
     [self focus];
-  } else if([commandName isEqualToString:@"blur"]) {
+  } else if ([commandName isEqualToString:@"blur"]) {
     [self blur];
-  } else if([commandName isEqualToString:@"setValue"]) {
+  } else if ([commandName isEqualToString:@"setValue"]) {
     NSString *value = (NSString *)args[0];
     [self setValue:value];
-  } else if([commandName isEqualToString:@"toggleBold"]) {
-    [self toggleRegularStyle: [BoldStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleItalic"]) {
-    [self toggleRegularStyle: [ItalicStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleUnderline"]) {
-    [self toggleRegularStyle: [UnderlineStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleStrikeThrough"]) {
-    [self toggleRegularStyle: [StrikethroughStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleInlineCode"]) {
-    [self toggleRegularStyle: [InlineCodeStyle getStyleType]];
-  } else if([commandName isEqualToString:@"addLink"]) {
-    NSInteger start = [((NSNumber*)args[0]) integerValue];
-    NSInteger end = [((NSNumber*)args[1]) integerValue];
+  } else if ([commandName isEqualToString:@"toggleBold"]) {
+    [self toggleRegularStyle:[BoldStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"toggleItalic"]) {
+    [self toggleRegularStyle:[ItalicStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"toggleUnderline"]) {
+    [self toggleRegularStyle:[UnderlineStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"toggleStrikeThrough"]) {
+    [self toggleRegularStyle:[StrikethroughStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"toggleInlineCode"]) {
+    [self toggleRegularStyle:[InlineCodeStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"addLink"]) {
+    NSInteger start = [((NSNumber *)args[0]) integerValue];
+    NSInteger end = [((NSNumber *)args[1]) integerValue];
     NSString *text = (NSString *)args[2];
     NSString *url = (NSString *)args[3];
     [self addLinkAt:start end:end text:text url:url];
-  } else if([commandName isEqualToString:@"addMention"]) {
+  } else if ([commandName isEqualToString:@"addMention"]) {
     NSString *indicator = (NSString *)args[0];
     NSString *text = (NSString *)args[1];
     NSString *attributes = (NSString *)args[2];
     [self addMention:indicator text:text attributes:attributes];
-  } else if([commandName isEqualToString:@"startMention"]) {
+  } else if ([commandName isEqualToString:@"startMention"]) {
     NSString *indicator = (NSString *)args[0];
     [self startMentionWithIndicator:indicator];
-  } else if([commandName isEqualToString:@"toggleH1"]) {
+  } else if ([commandName isEqualToString:@"toggleH1"]) {
     [self toggleParagraphStyle:[H1Style getStyleType]];
-  } else if([commandName isEqualToString:@"toggleH2"]) {
+  } else if ([commandName isEqualToString:@"toggleH2"]) {
     [self toggleParagraphStyle:[H2Style getStyleType]];
-  } else if([commandName isEqualToString:@"toggleH3"]) {
+  } else if ([commandName isEqualToString:@"toggleH3"]) {
     [self toggleParagraphStyle:[H3Style getStyleType]];
-  } else if([commandName isEqualToString:@"toggleUnorderedList"]) {
+  } else if ([commandName isEqualToString:@"toggleUnorderedList"]) {
     [self toggleParagraphStyle:[UnorderedListStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleOrderedList"]) {
+  } else if ([commandName isEqualToString:@"toggleOrderedList"]) {
     [self toggleParagraphStyle:[OrderedListStyle getStyleType]];
-  } else if([commandName isEqualToString:@"toggleBlockQuote"]) {
+  } else if ([commandName isEqualToString:@"toggleBlockQuote"]) {
     [self toggleParagraphStyle:[BlockQuoteStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"toggleCodeBlock"]) {
+    [self toggleParagraphStyle:[CodeBlockStyle getStyleType]];
+  } else if ([commandName isEqualToString:@"addImage"]) {
+    NSString *uri = (NSString *)args[0];
+    CGFloat imgWidth = [(NSNumber *)args[1] floatValue];
+    CGFloat imgHeight = [(NSNumber *)args[2] floatValue];
+
+    [self addImage:uri width:imgWidth height:imgHeight];
+  } else if ([commandName isEqualToString:@"requestHTML"]) {
+    NSInteger requestId = [((NSNumber *)args[0]) integerValue];
+    [self requestHTML:requestId];
   }
 }
 
 - (std::shared_ptr<EnrichedTextInputViewEventEmitter>)getEventEmitter {
-  if(_eventEmitter != nullptr && !blockEmitting) {
-    auto emitter = static_cast<const EnrichedTextInputViewEventEmitter &>(*_eventEmitter);
+  if (_eventEmitter != nullptr && !blockEmitting) {
+    auto emitter =
+        static_cast<const EnrichedTextInputViewEventEmitter &>(*_eventEmitter);
     return std::make_shared<EnrichedTextInputViewEventEmitter>(emitter);
   } else {
     return nullptr;
@@ -793,7 +1000,7 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)setValue:(NSString *)value {
   NSString *initiallyProcessedHtml = [parser initiallyProcessHtml:value];
-  if(initiallyProcessedHtml == nullptr) {
+  if (initiallyProcessedHtml == nullptr) {
     // just plain text
     textView.text = value;
   } else {
@@ -806,9 +1013,11 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   [self anyTextMayHaveBeenModified];
 }
 
-- (void)emitOnLinkDetectedEvent:(NSString *)text url:(NSString *)url range:(NSRange)range {
+- (void)emitOnLinkDetectedEvent:(NSString *)text
+                            url:(NSString *)url
+                          range:(NSRange)range {
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
+  if (emitter != nullptr) {
     // update recently active link info
     LinkData *newLinkData = [[LinkData alloc] init];
     newLinkData.text = text;
@@ -817,57 +1026,67 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
     _recentlyActiveLinkRange = range;
 
     emitter->onLinkDetected({
-      .text = [text toCppString],
-      .url = [url toCppString],
-      .start = static_cast<int>(range.location),
-      .end = static_cast<int>(range.location + range.length),
+        .text = [text toCppString],
+        .url = [url toCppString],
+        .start = static_cast<int>(range.location),
+        .end = static_cast<int>(range.location + range.length),
     });
   }
 }
 
-- (void)emitOnMentionDetectedEvent:(NSString *)text indicator:(NSString *)indicator attributes:(NSString *)attributes {
+- (void)emitOnMentionDetectedEvent:(NSString *)text
+                         indicator:(NSString *)indicator
+                        attributes:(NSString *)attributes {
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
-    emitter->onMentionDetected({
-      .text = [text toCppString],
-      .indicator = [indicator toCppString],
-      .payload = [attributes toCppString]
-    });
+  if (emitter != nullptr) {
+    emitter->onMentionDetected({.text = [text toCppString],
+                                .indicator = [indicator toCppString],
+                                .payload = [attributes toCppString]});
   }
 }
 
 - (void)emitOnMentionEvent:(NSString *)indicator text:(NSString *)text {
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
-    if(text != nullptr) {
+  if (emitter != nullptr) {
+    if (text != nullptr) {
       folly::dynamic fdStr = [text toCppString];
-      emitter->onMention({
-        .indicator = [indicator toCppString],
-        .text = fdStr
-      });
+      emitter->onMention({.indicator = [indicator toCppString], .text = fdStr});
     } else {
       folly::dynamic nul = nullptr;
-      emitter->onMention({
-        .indicator = [indicator toCppString],
-        .text = nul
-      });
+      emitter->onMention({.indicator = [indicator toCppString], .text = nul});
     }
   }
 }
 
 - (void)tryEmittingOnChangeHtmlEvent {
-  if(!_emitHtml || textView.markedTextRange != nullptr) {
+  if (!_emitHtml || textView.markedTextRange != nullptr) {
     return;
   }
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
-    NSString *htmlOutput = [parser parseToHtmlFromRange:NSMakeRange(0, textView.textStorage.string.length)];
+  if (emitter != nullptr) {
+    NSString *htmlOutput = [parser
+        parseToHtmlFromRange:NSMakeRange(0,
+                                         textView.textStorage.string.length)];
     // make sure html really changed
-    if(![htmlOutput isEqualToString:_recentlyEmittedHtml]) {
+    if (![htmlOutput isEqualToString:_recentlyEmittedHtml]) {
       _recentlyEmittedHtml = htmlOutput;
-      emitter->onChangeHtml({
-        .value = [htmlOutput toCppString]
-      });
+      emitter->onChangeHtml({.value = [htmlOutput toCppString]});
+    }
+  }
+}
+
+- (void)requestHTML:(NSInteger)requestId {
+  auto emitter = [self getEventEmitter];
+  if (emitter != nullptr) {
+    @try {
+      NSString *htmlOutput = [parser
+          parseToHtmlFromRange:NSMakeRange(0,
+                                           textView.textStorage.string.length)];
+      emitter->onRequestHtmlResult({.requestId = static_cast<int>(requestId),
+                                    .html = [htmlOutput toCppString]});
+    } @catch (NSException *exception) {
+      emitter->onRequestHtmlResult({.requestId = static_cast<int>(requestId),
+                                    .html = folly::dynamic(nullptr)});
     }
   }
 }
@@ -877,7 +1096,7 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 - (void)toggleRegularStyle:(StyleType)type {
   id<BaseStyleProtocol> styleClass = stylesDict[@(type)];
 
-  if([self handleStyleBlocksAndConflicts:type range:textView.selectedRange]) {
+  if ([self handleStyleBlocksAndConflicts:type range:textView.selectedRange]) {
     [styleClass applyStyle:textView.selectedRange];
     [self anyTextMayHaveBeenModified];
   }
@@ -886,42 +1105,82 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 - (void)toggleParagraphStyle:(StyleType)type {
   id<BaseStyleProtocol> styleClass = stylesDict[@(type)];
   // we always pass whole paragraph/s range to these styles
-  NSRange paragraphRange = [textView.textStorage.string paragraphRangeForRange:textView.selectedRange];
+  NSRange paragraphRange = [textView.textStorage.string
+      paragraphRangeForRange:textView.selectedRange];
 
-  if([self handleStyleBlocksAndConflicts:type range:paragraphRange]) {
+  if ([self handleStyleBlocksAndConflicts:type range:paragraphRange]) {
     [styleClass applyStyle:paragraphRange];
     [self anyTextMayHaveBeenModified];
   }
 }
 
-- (void)addLinkAt:(NSInteger)start end:(NSInteger)end text:(NSString *)text url:(NSString *)url {
-  LinkStyle *linkStyleClass = (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
-  if(linkStyleClass == nullptr) { return; }
+- (void)addLinkAt:(NSInteger)start
+              end:(NSInteger)end
+             text:(NSString *)text
+              url:(NSString *)url {
+  LinkStyle *linkStyleClass =
+      (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
+  if (linkStyleClass == nullptr) {
+    return;
+  }
 
   // translate the output start-end notation to range
   NSRange linkRange = NSMakeRange(start, end - start);
-  if([self handleStyleBlocksAndConflicts:[LinkStyle getStyleType] range:linkRange]) {
-    [linkStyleClass addLink:text url:url range:linkRange manual:YES];
+  if ([self handleStyleBlocksAndConflicts:[LinkStyle getStyleType]
+                                    range:linkRange]) {
+    [linkStyleClass addLink:text
+                        url:url
+                      range:linkRange
+                     manual:YES
+              withSelection:YES];
     [self anyTextMayHaveBeenModified];
   }
 }
 
-- (void)addMention:(NSString *)indicator text:(NSString *)text attributes:(NSString *)attributes {
-  MentionStyle *mentionStyleClass = (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
-  if(mentionStyleClass == nullptr) { return; }
-  if([mentionStyleClass getActiveMentionRange] == nullptr) { return; }
+- (void)addMention:(NSString *)indicator
+              text:(NSString *)text
+        attributes:(NSString *)attributes {
+  MentionStyle *mentionStyleClass =
+      (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
+  if (mentionStyleClass == nullptr) {
+    return;
+  }
+  if ([mentionStyleClass getActiveMentionRange] == nullptr) {
+    return;
+  }
 
-  if([self handleStyleBlocksAndConflicts:[MentionStyle getStyleType] range:[[mentionStyleClass getActiveMentionRange] rangeValue]]) {
+  if ([self handleStyleBlocksAndConflicts:[MentionStyle getStyleType]
+                                    range:[[mentionStyleClass
+                                              getActiveMentionRange]
+                                              rangeValue]]) {
     [mentionStyleClass addMention:indicator text:text attributes:attributes];
     [self anyTextMayHaveBeenModified];
   }
 }
 
+- (void)addImage:(NSString *)uri width:(float)width height:(float)height {
+  ImageStyle *imageStyleClass =
+      (ImageStyle *)stylesDict[@([ImageStyle getStyleType])];
+  if (imageStyleClass == nullptr) {
+    return;
+  }
+
+  if ([self handleStyleBlocksAndConflicts:[ImageStyle getStyleType]
+                                    range:textView.selectedRange]) {
+    [imageStyleClass addImage:uri width:width height:height];
+    [self anyTextMayHaveBeenModified];
+  }
+}
+
 - (void)startMentionWithIndicator:(NSString *)indicator {
-  MentionStyle *mentionStyleClass = (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
-  if(mentionStyleClass == nullptr) { return; }
+  MentionStyle *mentionStyleClass =
+      (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
+  if (mentionStyleClass == nullptr) {
+    return;
+  }
 
-  if([self handleStyleBlocksAndConflicts:[MentionStyle getStyleType] range:[[mentionStyleClass getActiveMentionRange] rangeValue]]) {
+  if ([self handleStyleBlocksAndConflicts:[MentionStyle getStyleType]
+                                    range:textView.selectedRange]) {
     [mentionStyleClass startMentionWithIndicator:indicator];
     [self anyTextMayHaveBeenModified];
   }
@@ -930,26 +1189,30 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 // returns false when style shouldn't be applied and true when it can be
 - (BOOL)handleStyleBlocksAndConflicts:(StyleType)type range:(NSRange)range {
   // handle blocking styles: if any is present we do not apply the toggled style
-  NSArray<NSNumber *> *blocking = [self getPresentStyleTypesFrom: _blockingStyles[@(type)] range:range];
-  if(blocking.count != 0) {
+  NSArray<NSNumber *> *blocking =
+      [self getPresentStyleTypesFrom:blockingStyles[@(type)] range:range];
+  if (blocking.count != 0) {
     return NO;
   }
 
   // handle conflicting styles: all of their occurences have to be removed
-  NSArray<NSNumber *> *conflicting = [self getPresentStyleTypesFrom: _conflictingStyles[@(type)] range:range];
-  if(conflicting.count != 0) {
-    for(NSNumber *style in conflicting) {
+  NSArray<NSNumber *> *conflicting =
+      [self getPresentStyleTypesFrom:conflictingStyles[@(type)] range:range];
+  if (conflicting.count != 0) {
+    for (NSNumber *style in conflicting) {
       id<BaseStyleProtocol> styleClass = stylesDict[style];
 
-      if(range.length >= 1) {
+      if (range.length >= 1) {
         // for ranges, we need to remove each occurence
-        NSArray<StylePair *> *allOccurences = [styleClass findAllOccurences:range];
+        NSArray<StylePair *> *allOccurences =
+            [styleClass findAllOccurences:range];
 
-        for(StylePair* pair in allOccurences) {
-          [styleClass removeAttributes: [pair.rangeValue rangeValue]];
+        for (StylePair *pair in allOccurences) {
+          [styleClass removeAttributes:[pair.rangeValue rangeValue]];
         }
       } else {
-        // with in-place selection, we just remove the adequate typing attributes
+        // with in-place selection, we just remove the adequate typing
+        // attributes
         [styleClass removeTypingAttributes];
       }
     }
@@ -957,17 +1220,19 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   return YES;
 }
 
-- (NSArray<NSNumber *> *)getPresentStyleTypesFrom:(NSArray<NSNumber *> *)types range:(NSRange)range {
-  NSMutableArray<NSNumber *> *resultArray = [[NSMutableArray<NSNumber *> alloc] init];
-  for(NSNumber *type in types) {
+- (NSArray<NSNumber *> *)getPresentStyleTypesFrom:(NSArray<NSNumber *> *)types
+                                            range:(NSRange)range {
+  NSMutableArray<NSNumber *> *resultArray =
+      [[NSMutableArray<NSNumber *> alloc] init];
+  for (NSNumber *type in types) {
     id<BaseStyleProtocol> styleClass = stylesDict[type];
 
-    if(range.length >= 1) {
-      if([styleClass anyOccurence:range]) {
+    if (range.length >= 1) {
+      if ([styleClass anyOccurence:range]) {
         [resultArray addObject:type];
       }
     } else {
-      if([styleClass detectStyle:range]) {
+      if ([styleClass detectStyle:range]) {
         [resultArray addObject:type];
       }
     }
@@ -977,28 +1242,40 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)manageSelectionBasedChanges {
   // link typing attributes fix
-  LinkStyle *linkStyleClass = (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
-  if(linkStyleClass != nullptr) {
+  LinkStyle *linkStyleClass =
+      (LinkStyle *)stylesDict[@([LinkStyle getStyleType])];
+  if (linkStyleClass != nullptr) {
     [linkStyleClass manageLinkTypingAttributes];
   }
 
   // mention typing attribtues fix and active editing
-  MentionStyle *mentionStyleClass = (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
-  if(mentionStyleClass != nullptr) {
+  MentionStyle *mentionStyleClass =
+      (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
+  if (mentionStyleClass != nullptr) {
     [mentionStyleClass manageMentionTypingAttributes];
-    [mentionStyleClass manageMentionEditing];
+
+    // mention editing runs if only a selection was done (no text change)
+    // otherwise we would double-emit with a second call in the
+    // anyTextMayHaveBeenModified method
+    if ([_recentInputString
+            isEqualToString:[textView.textStorage.string copy]]) {
+      [mentionStyleClass manageMentionEditing];
+    }
   }
 
   // typing attributes for empty lines selection reset
   NSString *currentString = [textView.textStorage.string copy];
-  if(textView.selectedRange.length == 0 && [_recentlyEmittedString isEqualToString:currentString]) {
+  if (textView.selectedRange.length == 0 &&
+      [_recentInputString isEqualToString:currentString]) {
     // no string change means only a selection changed with no character changes
-    NSRange paragraphRange = [textView.textStorage.string paragraphRangeForRange:textView.selectedRange];
-    if(
-      paragraphRange.length == 0 ||
-      (paragraphRange.length == 1 &&
-      [[NSCharacterSet newlineCharacterSet] characterIsMember:[textView.textStorage.string characterAtIndex:paragraphRange.location]])
-    ) {
+    NSRange paragraphRange = [textView.textStorage.string
+        paragraphRangeForRange:textView.selectedRange];
+    if (paragraphRange.length == 0 ||
+        (paragraphRange.length == 1 &&
+         [[NSCharacterSet newlineCharacterSet]
+             characterIsMember:[textView.textStorage.string
+                                   characterAtIndex:paragraphRange
+                                                        .location]])) {
       // user changed selection to an empty line (or empty line with a newline)
       // typing attributes need to be reset
       textView.typingAttributes = defaultTypingAttributes;
@@ -1009,11 +1286,14 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   [self tryUpdatingActiveStyles];
 }
 
-- (void)handleWordModificationBasedChanges:(NSString*)word inRange:(NSRange)range {
+- (void)handleWordModificationBasedChanges:(NSString *)word
+                                   inRange:(NSRange)range {
   // manual links refreshing and automatic links detection handling
-  LinkStyle* linkStyle = [stylesDict objectForKey:@([LinkStyle getStyleType])];
-  if(linkStyle != nullptr) {
-    // manual links need to be handled first because they can block automatic links after being refreshed
+  LinkStyle *linkStyle = [stylesDict objectForKey:@([LinkStyle getStyleType])];
+
+  if (linkStyle != nullptr) {
+    // manual links need to be handled first because they can block automatic
+    // links after being refreshed
     [linkStyle handleManualLinks:word inRange:range];
     [linkStyle handleAutomaticLinks:word inRange:range];
   }
@@ -1021,7 +1301,7 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)anyTextMayHaveBeenModified {
   // we don't do no text changes when working with iOS marked text
-  if(textView.markedTextRange != nullptr) {
+  if (textView.markedTextRange != nullptr) {
     return;
   }
 
@@ -1029,74 +1309,87 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   [ZeroWidthSpaceUtils handleZeroWidthSpacesInInput:self];
 
   // emptying input typing attributes management
-  if(textView.textStorage.string.length == 0 && _recentlyEmittedString.length > 0) {
+  if (textView.textStorage.string.length == 0 &&
+      _recentInputString.length > 0) {
     // reset typing attribtues
     textView.typingAttributes = defaultTypingAttributes;
   }
 
   // inline code on newlines fix
   InlineCodeStyle *codeStyle = stylesDict[@([InlineCodeStyle getStyleType])];
-  if(codeStyle != nullptr) {
+  if (codeStyle != nullptr) {
     [codeStyle handleNewlines];
   }
 
   // blockquote colors management
   BlockQuoteStyle *bqStyle = stylesDict[@([BlockQuoteStyle getStyleType])];
-  if(bqStyle != nullptr) {
+  if (bqStyle != nullptr) {
     [bqStyle manageBlockquoteColor];
   }
 
+  // codeblock font and color management
+  CodeBlockStyle *codeBlockStyle = stylesDict[@([CodeBlockStyle getStyleType])];
+  if (codeBlockStyle != nullptr) {
+    [codeBlockStyle manageCodeBlockFontAndColor];
+  }
+
   // improper headings fix
   H1Style *h1Style = stylesDict[@([H1Style getStyleType])];
   H2Style *h2Style = stylesDict[@([H2Style getStyleType])];
   H3Style *h3Style = stylesDict[@([H3Style getStyleType])];
-  if(h1Style != nullptr && h2Style != nullptr && h3Style != nullptr) {
+  if (h1Style != nullptr && h2Style != nullptr && h3Style != nullptr) {
     [h1Style handleImproperHeadings];
     [h2Style handleImproperHeadings];
     [h3Style handleImproperHeadings];
   }
 
-  // mentions removal management
-  MentionStyle *mentionStyleClass = (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
-  if(mentionStyleClass != nullptr) {
+  // mentions management: removal and editing
+  MentionStyle *mentionStyleClass =
+      (MentionStyle *)stylesDict[@([MentionStyle getStyleType])];
+  if (mentionStyleClass != nullptr) {
     [mentionStyleClass handleExistingMentions];
+    [mentionStyleClass manageMentionEditing];
   }
 
   // placholder management
-  if(!_placeholderLabel.hidden && textView.textStorage.string.length > 0) {
+  if (!_placeholderLabel.hidden && textView.textStorage.string.length > 0) {
     [self setPlaceholderLabelShown:NO];
-  } else if(textView.textStorage.string.length == 0 && _placeholderLabel.hidden) {
+  } else if (textView.textStorage.string.length == 0 &&
+             _placeholderLabel.hidden) {
     [self setPlaceholderLabelShown:YES];
   }
 
-  if(![textView.textStorage.string isEqualToString:_recentlyEmittedString]) {
+  if (![textView.textStorage.string isEqualToString:_recentInputString]) {
     // modified words handling
-    NSArray *modifiedWords = [WordsUtils getAffectedWordsFromText:textView.textStorage.string modificationRange:recentlyChangedRange];
-    if(modifiedWords != nullptr) {
-      for(NSDictionary *wordDict in modifiedWords) {
+    NSArray *modifiedWords =
+        [WordsUtils getAffectedWordsFromText:textView.textStorage.string
+                           modificationRange:recentlyChangedRange];
+    if (modifiedWords != nullptr) {
+      for (NSDictionary *wordDict in modifiedWords) {
         NSString *wordText = (NSString *)[wordDict objectForKey:@"word"];
         NSValue *wordRange = (NSValue *)[wordDict objectForKey:@"range"];
 
-        if(wordText == nullptr || wordRange == nullptr) {
+        if (wordText == nullptr || wordRange == nullptr) {
           continue;
         }
 
-        [self handleWordModificationBasedChanges:wordText inRange:[wordRange rangeValue]];
+        [self handleWordModificationBasedChanges:wordText
+                                         inRange:[wordRange rangeValue]];
       }
     }
 
-    // emit string without zero width spaces
-    NSString *stringToBeEmitted = [[textView.textStorage.string stringByReplacingOccurrencesOfString:@"\u200B" withString:@""] copy];
-  
     // emit onChangeText event
     auto emitter = [self getEventEmitter];
-    if(emitter != nullptr) {
-      // set the recently emitted string only if the emitter is defined
-      _recentlyEmittedString = stringToBeEmitted;
+    if (emitter != nullptr) {
+      // set the recent input string only if the emitter is defined
+      _recentInputString = [textView.textStorage.string copy];
 
-      emitter->onChangeText({
-        .value = [stringToBeEmitted toCppString]
-      });
+      // emit string without zero width spaces
+      NSString *stringToBeEmitted = [[textView.textStorage.string
+          stringByReplacingOccurrencesOfString:@"\u200B"
+                                    withString:@""] copy];
+
+      emitter->onChangeText({.value = [stringToBeEmitted toCppString]});
     }
   }
 
@@ -1108,25 +1401,41 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
   [self scheduleRelayoutIfNeeded];
 }
 
-// Debounced relayout helper - coalesces multiple requests into one per runloop tick
-- (void)scheduleRelayoutIfNeeded
-{
+// Debounced relayout helper - coalesces multiple requests into one per runloop
+// tick
+- (void)scheduleRelayoutIfNeeded {
   // Cancel any previously scheduled invocation to debounce
-  [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_performRelayout) object:nil];
+  [NSObject cancelPreviousPerformRequestsWithTarget:self
+                                           selector:@selector(_performRelayout)
+                                             object:nil];
   // Schedule on next runloop cycle
-  [self performSelector:@selector(_performRelayout) withObject:nil afterDelay:0];
+  [self performSelector:@selector(_performRelayout)
+             withObject:nil
+             afterDelay:0];
 }
 
-- (void)_performRelayout
-{
-  if (!textView) { return; }
+- (void)_performRelayout {
+  if (!textView) {
+    return;
+  }
 
   dispatch_async(dispatch_get_main_queue(), ^{
-    NSRange wholeRange = NSMakeRange(0, self->textView.textStorage.string.length);
+    NSRange wholeRange =
+        NSMakeRange(0, self->textView.textStorage.string.length);
     NSRange actualRange = NSMakeRange(0, 0);
-    [self->textView.layoutManager invalidateLayoutForCharacterRange:wholeRange actualCharacterRange:&actualRange];
+    [self->textView.layoutManager
+        invalidateLayoutForCharacterRange:wholeRange
+                     actualCharacterRange:&actualRange];
     [self->textView.layoutManager ensureLayoutForCharacterRange:actualRange];
-    [self->textView.layoutManager invalidateDisplayForCharacterRange:wholeRange];
+    [self->textView.layoutManager
+        invalidateDisplayForCharacterRange:wholeRange];
+
+    // We have to explicitly set contentSize
+    // That way textView knows if content overflows and if should be scrollable
+    // We recall measureSize here because value returned from previous
+    // measureSize may not be up-to date at that point
+    CGSize measuredSize = [self measureSize:self->textView.frame.size.width];
+    self->textView.contentSize = measuredSize;
   });
 }
 
@@ -1140,60 +1449,79 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)textViewDidBeginEditing:(UITextView *)textView {
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
-    //send onFocus event if allowed
-    if(_emitFocusBlur) {
+  if (emitter != nullptr) {
+    // send onFocus event if allowed
+    if (_emitFocusBlur) {
       emitter->onInputFocus({});
     }
 
-    NSString *textAtSelection = [[[NSMutableString alloc] initWithString:textView.textStorage.string] substringWithRange: textView.selectedRange];
-    emitter->onChangeSelection({
-      .start = static_cast<int>(textView.selectedRange.location),
-      .end = static_cast<int>(textView.selectedRange.location + textView.selectedRange.length),
-      .text = [textAtSelection toCppString]
-    });
-  }
-  // manage selection changes since textViewDidChangeSelection sometimes doesn't run on focus
+    NSString *textAtSelection =
+        [[[NSMutableString alloc] initWithString:textView.textStorage.string]
+            substringWithRange:textView.selectedRange];
+    emitter->onChangeSelection(
+        {.start = static_cast<int>(textView.selectedRange.location),
+         .end = static_cast<int>(textView.selectedRange.location +
+                                 textView.selectedRange.length),
+         .text = [textAtSelection toCppString]});
+  }
+  // manage selection changes since textViewDidChangeSelection sometimes doesn't
+  // run on focus
   [self manageSelectionBasedChanges];
 }
 
 - (void)textViewDidEndEditing:(UITextView *)textView {
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr && _emitFocusBlur) {
-    //send onBlur event
+  if (emitter != nullptr && _emitFocusBlur) {
+    // send onBlur event
     emitter->onInputBlur({});
   }
 }
 
-- (bool)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {
+- (bool)textView:(UITextView *)textView
+    shouldChangeTextInRange:(NSRange)range
+            replacementText:(NSString *)text {
   recentlyChangedRange = NSMakeRange(range.location, text.length);
 
   UnorderedListStyle *uStyle = stylesDict[@([UnorderedListStyle getStyleType])];
   OrderedListStyle *oStyle = stylesDict[@([OrderedListStyle getStyleType])];
   BlockQuoteStyle *bqStyle = stylesDict[@([BlockQuoteStyle getStyleType])];
+  CodeBlockStyle *cbStyle = stylesDict[@([CodeBlockStyle getStyleType])];
   LinkStyle *linkStyle = stylesDict[@([LinkStyle getStyleType])];
   MentionStyle *mentionStyle = stylesDict[@([MentionStyle getStyleType])];
   H1Style *h1Style = stylesDict[@([H1Style getStyleType])];
   H2Style *h2Style = stylesDict[@([H2Style getStyleType])];
   H3Style *h3Style = stylesDict[@([H3Style getStyleType])];
 
-  // some of the changes these checks do could interfere with later checks and cause a crash
-  // so here I rely on short circuiting evaluation of the logical expression
-  // either way it's not possible to have two of them come off at the same time
-  if(
-    [uStyle handleBackspaceInRange:range replacementText:text] ||
-    [uStyle tryHandlingListShorcutInRange:range replacementText:text] ||
-    [oStyle handleBackspaceInRange:range replacementText:text] ||
-    [oStyle tryHandlingListShorcutInRange:range replacementText:text] ||
-    [bqStyle handleBackspaceInRange:range replacementText:text] ||
-    [linkStyle handleLeadingLinkReplacement:range replacementText:text] ||
-    [mentionStyle handleLeadingMentionReplacement:range replacementText:text] ||
-    [h1Style handleNewlinesInRange:range replacementText:text] ||
-    [h2Style handleNewlinesInRange:range replacementText:text] ||
-    [h3Style handleNewlinesInRange:range replacementText:text] ||
-    [ZeroWidthSpaceUtils handleBackspaceInRange:range replacementText:text input:self] ||
-    [ParagraphAttributesUtils handleBackspaceInRange:range replacementText:text input:self]
-  ) {
+  // some of the changes these checks do could interfere with later checks and
+  // cause a crash so here I rely on short circuiting evaluation of the logical
+  // expression either way it's not possible to have two of them come off at the
+  // same time
+  if ([uStyle handleBackspaceInRange:range replacementText:text] ||
+      [uStyle tryHandlingListShorcutInRange:range replacementText:text] ||
+      [oStyle handleBackspaceInRange:range replacementText:text] ||
+      [oStyle tryHandlingListShorcutInRange:range replacementText:text] ||
+      [bqStyle handleBackspaceInRange:range replacementText:text] ||
+      [cbStyle handleBackspaceInRange:range replacementText:text] ||
+      [linkStyle handleLeadingLinkReplacement:range replacementText:text] ||
+      [mentionStyle handleLeadingMentionReplacement:range
+                                    replacementText:text] ||
+      [h1Style handleNewlinesInRange:range replacementText:text] ||
+      [h2Style handleNewlinesInRange:range replacementText:text] ||
+      [h3Style handleNewlinesInRange:range replacementText:text] ||
+      [ZeroWidthSpaceUtils handleBackspaceInRange:range
+                                  replacementText:text
+                                            input:self] ||
+      [ParagraphAttributesUtils handleBackspaceInRange:range
+                                       replacementText:text
+                                                 input:self] ||
+      // CRITICAL: This callback HAS TO be always evaluated last.
+      //
+      // This function is the "Generic Fallback": if no specific style claims
+      // the backspace action to change its state, only then do we proceed to
+      // physically delete the newline and merge paragraphs.
+      [ParagraphAttributesUtils handleParagraphStylesMergeOnBackspace:range
+                                                      replacementText:text
+                                                                input:self]) {
     [self anyTextMayHaveBeenModified];
     return NO;
   }
@@ -1203,27 +1531,58 @@ Class<RCTComponentViewProtocol> EnrichedTextInputViewCls(void) {
 
 - (void)textViewDidChangeSelection:(UITextView *)textView {
   // emit the event
-  NSString *textAtSelection = [[[NSMutableString alloc] initWithString:textView.textStorage.string] substringWithRange: textView.selectedRange];
+  NSString *textAtSelection =
+      [[[NSMutableString alloc] initWithString:textView.textStorage.string]
+          substringWithRange:textView.selectedRange];
 
   auto emitter = [self getEventEmitter];
-  if(emitter != nullptr) {
+  if (emitter != nullptr) {
     // iOS range works differently because it specifies location and length
-    // here, start is the location, but end is the first index BEHIND the end. So a 0 length range will have equal start and end
-    emitter->onChangeSelection({
-      .start = static_cast<int>(textView.selectedRange.location),
-      .end = static_cast<int>(textView.selectedRange.location + textView.selectedRange.length),
-      .text = [textAtSelection toCppString]
-    });
+    // here, start is the location, but end is the first index BEHIND the end.
+    // So a 0 length range will have equal start and end
+    emitter->onChangeSelection(
+        {.start = static_cast<int>(textView.selectedRange.location),
+         .end = static_cast<int>(textView.selectedRange.location +
+                                 textView.selectedRange.length),
+         .text = [textAtSelection toCppString]});
   }
 
   // manage selection changes
   [self manageSelectionBasedChanges];
 }
 
-// this function isn't called always when some text changes (for example setting link or starting mention with indicator doesn't fire it)
-// so all the logic is in anyTextMayHaveBeenModified
+// this function isn't called always when some text changes (for example setting
+// link or starting mention with indicator doesn't fire it) so all the logic is
+// in anyTextMayHaveBeenModified
 - (void)textViewDidChange:(UITextView *)textView {
   [self anyTextMayHaveBeenModified];
 }
 
+// MARK: - Media attachments delegate
+
+- (void)mediaAttachmentDidUpdate:(NSTextAttachment *)attachment {
+  NSTextStorage *storage = textView.textStorage;
+  NSRange fullRange = NSMakeRange(0, storage.length);
+
+  __block NSRange foundRange = NSMakeRange(NSNotFound, 0);
+
+  [storage enumerateAttribute:NSAttachmentAttributeName
+                      inRange:fullRange
+                      options:0
+                   usingBlock:^(id value, NSRange range, BOOL *stop) {
+                     if (value == attachment) {
+                       foundRange = range;
+                       *stop = YES;
+                     }
+                   }];
+
+  if (foundRange.location == NSNotFound) {
+    return;
+  }
+
+  [storage edited:NSTextStorageEditedAttributes
+               range:foundRange
+      changeInLength:0];
+}
+
 @end
diff --git a/node_modules/react-native-enriched/ios/attachments/ImageAttachment.h b/node_modules/react-native-enriched/ios/attachments/ImageAttachment.h
new file mode 100644
index 0000000..98681f4
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/attachments/ImageAttachment.h
@@ -0,0 +1,10 @@
+#import "ImageData.h"
+#import "MediaAttachment.h"
+
+@interface ImageAttachment : MediaAttachment
+
+@property(nonatomic, strong) ImageData *imageData;
+
+- (instancetype)initWithImageData:(ImageData *)data;
+
+@end
diff --git a/node_modules/react-native-enriched/ios/attachments/ImageAttachment.mm b/node_modules/react-native-enriched/ios/attachments/ImageAttachment.mm
new file mode 100644
index 0000000..117f099
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/attachments/ImageAttachment.mm
@@ -0,0 +1,34 @@
+#import "ImageAttachment.h"
+
+@implementation ImageAttachment
+
+- (instancetype)initWithImageData:(ImageData *)data {
+  self = [super initWithURI:data.uri width:data.width height:data.height];
+  if (!self)
+    return nil;
+
+  _imageData = data;
+  self.image = [UIImage new];
+
+  [self loadAsync];
+  return self;
+}
+
+- (void)loadAsync {
+  NSURL *url = [NSURL URLWithString:self.uri];
+  if (!url)
+    return;
+
+  dispatch_async(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0), ^{
+    NSData *bytes = [NSData dataWithContentsOfURL:url];
+    UIImage *img = bytes ? [UIImage imageWithData:bytes]
+                         : [UIImage systemImageNamed:@"file"];
+
+    dispatch_async(dispatch_get_main_queue(), ^{
+      self.image = img;
+      [self notifyUpdate];
+    });
+  });
+}
+
+@end
diff --git a/node_modules/react-native-enriched/ios/attachments/MediaAttachment.h b/node_modules/react-native-enriched/ios/attachments/MediaAttachment.h
new file mode 100644
index 0000000..050a993
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/attachments/MediaAttachment.h
@@ -0,0 +1,23 @@
+#import <UIKit/UIKit.h>
+
+@class MediaAttachment;
+
+@protocol MediaAttachmentDelegate <NSObject>
+- (void)mediaAttachmentDidUpdate:(MediaAttachment *)attachment;
+@end
+
+@interface MediaAttachment : NSTextAttachment
+
+@property(nonatomic, weak) id<MediaAttachmentDelegate> delegate;
+@property(nonatomic, strong) NSString *uri;
+@property(nonatomic, assign) CGFloat width;
+@property(nonatomic, assign) CGFloat height;
+
+- (instancetype)initWithURI:(NSString *)uri
+                      width:(CGFloat)width
+                     height:(CGFloat)height;
+
+- (void)loadAsync;
+- (void)notifyUpdate;
+
+@end
diff --git a/node_modules/react-native-enriched/ios/attachments/MediaAttachment.mm b/node_modules/react-native-enriched/ios/attachments/MediaAttachment.mm
new file mode 100644
index 0000000..7eed179
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/attachments/MediaAttachment.mm
@@ -0,0 +1,31 @@
+#import "MediaAttachment.h"
+
+@implementation MediaAttachment
+
+- (instancetype)initWithURI:(NSString *)uri
+                      width:(CGFloat)width
+                     height:(CGFloat)height {
+  self = [super init];
+  if (!self)
+    return nil;
+
+  _uri = uri;
+  _width = width;
+  _height = height;
+
+  self.bounds = CGRectMake(0, 0, width, height);
+
+  return self;
+}
+
+- (void)loadAsync {
+  // no-op for base
+}
+
+- (void)notifyUpdate {
+  if ([self.delegate respondsToSelector:@selector(mediaAttachmentDidUpdate:)]) {
+    [self.delegate mediaAttachmentDidUpdate:self];
+  }
+}
+
+@end
diff --git a/node_modules/react-native-enriched/ios/config/InputConfig.h b/node_modules/react-native-enriched/ios/config/InputConfig.h
index cd12910..e562517 100644
--- a/node_modules/react-native-enriched/ios/config/InputConfig.h
+++ b/node_modules/react-native-enriched/ios/config/InputConfig.h
@@ -1,10 +1,10 @@
 #pragma once
-#import <UIKit/UIKit.h>
-#import "TextDecorationLineEnum.h"
 #import "MentionStyleProps.h"
+#import "TextDecorationLineEnum.h"
+#import <UIKit/UIKit.h>
 
-@interface InputConfig: NSObject<NSCopying>
-- (instancetype) init;
+@interface InputConfig : NSObject <NSCopying>
+- (instancetype)init;
 - (UIColor *)primaryColor;
 - (void)setPrimaryColor:(UIColor *)newValue;
 - (NSNumber *)primaryFontSize;
@@ -15,8 +15,8 @@
 - (void)setPrimaryFontFamily:(NSString *)newValue;
 - (UIFont *)primaryFont;
 - (UIFont *)monospacedFont;
-- (NSSet<NSNumber*>*)mentionIndicators;
-- (void)setMentionIndicators:(NSSet<NSNumber*>*)newValue;
+- (NSSet<NSNumber *> *)mentionIndicators;
+- (void)setMentionIndicators:(NSSet<NSNumber *> *)newValue;
 - (CGFloat)h1FontSize;
 - (void)setH1FontSize:(CGFloat)newValue;
 - (BOOL)h1Bold;
@@ -64,4 +64,10 @@
 - (void)setLinkDecorationLine:(TextDecorationLineEnum)newValue;
 - (void)setMentionStyleProps:(NSDictionary *)newValue;
 - (MentionStyleProps *)mentionStylePropsForIndicator:(NSString *)indicator;
+- (UIColor *)codeBlockFgColor;
+- (void)setCodeBlockFgColor:(UIColor *)newValue;
+- (UIColor *)codeBlockBgColor;
+- (void)setCodeBlockBgColor:(UIColor *)newValue;
+- (CGFloat)codeBlockBorderRadius;
+- (void)setCodeBlockBorderRadius:(CGFloat)newValue;
 @end
diff --git a/node_modules/react-native-enriched/ios/config/InputConfig.mm b/node_modules/react-native-enriched/ios/config/InputConfig.mm
index 00f0903..bccf746 100644
--- a/node_modules/react-native-enriched/ios/config/InputConfig.mm
+++ b/node_modules/react-native-enriched/ios/config/InputConfig.mm
@@ -10,7 +10,7 @@
   UIFont *_monospacedFont;
   BOOL _primaryFontNeedsRecreation;
   BOOL _monospacedFontNeedsRecreation;
-  NSSet<NSNumber*> *_mentionIndicators;
+  NSSet<NSNumber *> *_mentionIndicators;
   CGFloat _h1FontSize;
   BOOL _h1Bold;
   CGFloat _h2FontSize;
@@ -36,9 +36,14 @@
   UIColor *_linkColor;
   TextDecorationLineEnum _linkDecorationLine;
   NSDictionary *_mentionProperties;
+  UIColor *_codeBlockFgColor;
+  CGFloat _codeBlockBorderRadius;
+  UIColor *_codeBlockBgColor;
+  CGFloat _imageWidth;
+  CGFloat _imageHeight;
 }
 
-- (instancetype) init {
+- (instancetype)init {
   self = [super init];
   _primaryFontNeedsRecreation = YES;
   _monospacedFontNeedsRecreation = YES;
@@ -79,6 +84,9 @@
   copy->_linkColor = [_linkColor copy];
   copy->_linkDecorationLine = [_linkDecorationLine copy];
   copy->_mentionProperties = [_mentionProperties mutableCopy];
+  copy->_codeBlockFgColor = [_codeBlockFgColor copy];
+  copy->_codeBlockBgColor = [_codeBlockBgColor copy];
+  copy->_codeBlockBorderRadius = _codeBlockBorderRadius;
   return copy;
 }
 
@@ -102,7 +110,9 @@
 }
 
 - (NSString *)primaryFontWeight {
-  return _primaryFontWeight != nullptr ? _primaryFontWeight : [NSString stringWithFormat:@"%@", @(UIFontWeightRegular)];
+  return _primaryFontWeight != nullptr
+             ? _primaryFontWeight
+             : [NSString stringWithFormat:@"%@", @(UIFontWeightRegular)];
 }
 
 - (void)setPrimaryFontWeight:(NSString *)newValue {
@@ -122,41 +132,45 @@
 }
 
 - (UIFont *)primaryFont {
-  if(_primaryFontNeedsRecreation) {
+  if (_primaryFontNeedsRecreation) {
     _primaryFontNeedsRecreation = NO;
 
     NSString *newFontWeight = [self primaryFontWeight];
     // fix RCTFontWeight conversion warnings:
     // sometimes changing font family comes with weight '0' if not specified
-    // RCTConvert doesn't recognize this value so we just nullify it and it gets a default value
-    if([newFontWeight isEqualToString:@"0"]) {
+    // RCTConvert doesn't recognize this value so we just nullify it and it gets
+    // a default value
+    if ([newFontWeight isEqualToString:@"0"]) {
       newFontWeight = nullptr;
     }
 
     _primaryFont = [RCTFont updateFont:nullptr
-      withFamily:[self primaryFontFamily]
-      size:[self primaryFontSize]
-      weight:newFontWeight
-      style:nullptr
-      variant:nullptr
-      scaleMultiplier: 1];
+                            withFamily:[self primaryFontFamily]
+                                  size:[self primaryFontSize]
+                                weight:newFontWeight
+                                 style:nullptr
+                               variant:nullptr
+                       scaleMultiplier:1];
   }
   return _primaryFont;
 }
 
 - (UIFont *)monospacedFont {
-  if(_monospacedFontNeedsRecreation) {
+  if (_monospacedFontNeedsRecreation) {
     _monospacedFontNeedsRecreation = NO;
-    _monospacedFont = [UIFont monospacedSystemFontOfSize: [[self primaryFontSize] floatValue]  weight: [[self primaryFontWeight] floatValue]];
+    _monospacedFont = [UIFont
+        monospacedSystemFontOfSize:[[self primaryFontSize] floatValue]
+                            weight:[[self primaryFontWeight] floatValue]];
   }
   return _monospacedFont;
 }
 
-- (NSSet<NSNumber*>*)mentionIndicators {
-  return _mentionIndicators != nullptr ? _mentionIndicators : [[NSSet alloc] init];
+- (NSSet<NSNumber *> *)mentionIndicators {
+  return _mentionIndicators != nullptr ? _mentionIndicators
+                                       : [[NSSet alloc] init];
 }
 
-- (void)setMentionIndicators:(NSSet<NSNumber*>*)newValue {
+- (void)setMentionIndicators:(NSSet<NSNumber *> *)newValue {
   _mentionIndicators = newValue;
 }
 
@@ -224,7 +238,6 @@
   _blockquoteBorderWidth = newValue;
 }
 
-
 - (CGFloat)blockquoteGapWidth {
   return _blockquoteGapWidth;
 }
@@ -291,24 +304,25 @@
 }
 
 - (UIFont *)orderedListMarkerFont {
-  if(_olMarkerFontNeedsRecreation) {
+  if (_olMarkerFontNeedsRecreation) {
     _olMarkerFontNeedsRecreation = NO;
 
     NSString *newFontWeight = [self orderedListMarkerFontWeight];
     // fix RCTFontWeight conversion warnings:
     // sometimes changing font family comes with weight '0' if not specified
-    // RCTConvert doesn't recognize this value so we just nullify it and it gets a default value
-    if([newFontWeight isEqualToString:@"0"]) {
+    // RCTConvert doesn't recognize this value so we just nullify it and it gets
+    // a default value
+    if ([newFontWeight isEqualToString:@"0"]) {
       newFontWeight = nullptr;
     }
 
     _orderedListMarkerFont = [RCTFont updateFont:nullptr
-      withFamily:[self primaryFontFamily]
-      size:[self primaryFontSize]
-      weight:newFontWeight
-      style:nullptr
-      variant:nullptr
-      scaleMultiplier: 1];
+                                      withFamily:[self primaryFontFamily]
+                                            size:[self primaryFontSize]
+                                          weight:newFontWeight
+                                           style:nullptr
+                                         variant:nullptr
+                                 scaleMultiplier:1];
   }
   return _orderedListMarkerFont;
 }
@@ -366,10 +380,10 @@
 }
 
 - (MentionStyleProps *)mentionStylePropsForIndicator:(NSString *)indicator {
-  if(_mentionProperties.count == 1 && _mentionProperties[@"all"] != nullptr) {
+  if (_mentionProperties.count == 1 && _mentionProperties[@"all"] != nullptr) {
     // single props for all the indicators
     return _mentionProperties[@"all"];
-  } else if(_mentionProperties[indicator] != nullptr) {
+  } else if (_mentionProperties[indicator] != nullptr) {
     return _mentionProperties[indicator];
   }
   MentionStyleProps *fallbackProps = [[MentionStyleProps alloc] init];
@@ -379,4 +393,28 @@
   return fallbackProps;
 }
 
+- (UIColor *)codeBlockFgColor {
+  return _codeBlockFgColor;
+}
+
+- (void)setCodeBlockFgColor:(UIColor *)newValue {
+  _codeBlockFgColor = newValue;
+}
+
+- (UIColor *)codeBlockBgColor {
+  return _codeBlockBgColor;
+}
+
+- (void)setCodeBlockBgColor:(UIColor *)newValue {
+  _codeBlockBgColor = newValue;
+}
+
+- (CGFloat)codeBlockBorderRadius {
+  return _codeBlockBorderRadius;
+}
+
+- (void)setCodeBlockBorderRadius:(CGFloat)newValue {
+  _codeBlockBorderRadius = newValue;
+}
+
 @end
diff --git a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.cpp b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.cpp
index 0433ff3..9d82a88 100644
--- a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.cpp
+++ b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.cpp
@@ -115,4 +115,14 @@ payload.setProperty(runtime, "text", event.text);
   });
 }
 
+
+void EnrichedTextInputViewEventEmitter::onRequestHtmlResult(OnRequestHtmlResult event) const {
+  dispatchEvent("requestHtmlResult", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "requestId", event.requestId);
+payload.setProperty(runtime, "html", jsi::valueFromDynamic(runtime, event.html));
+    return payload;
+  });
+}
+
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.h b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.h
index 9ec63a1..bda62b9 100644
--- a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.h
+++ b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/EventEmitters.h
@@ -74,6 +74,11 @@ class EnrichedTextInputViewEventEmitter : public ViewEventEmitter {
     int end;
     std::string text;
     };
+
+  struct OnRequestHtmlResult {
+      int requestId;
+    folly::dynamic html;
+    };
   void onInputFocus(OnInputFocus value) const;
 
   void onInputBlur(OnInputBlur value) const;
@@ -91,5 +96,7 @@ class EnrichedTextInputViewEventEmitter : public ViewEventEmitter {
   void onMention(OnMention value) const;
 
   void onChangeSelection(OnChangeSelection value) const;
+
+  void onRequestHtmlResult(OnRequestHtmlResult value) const;
 };
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/Props.h b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/Props.h
index 365e247..142b024 100644
--- a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/Props.h
+++ b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/Props.h
@@ -309,45 +309,6 @@ static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleAStru
 }
 #endif
 
-struct EnrichedTextInputViewHtmlStyleImgStruct {
-  Float width{0.0};
-  Float height{0.0};
-
-#ifdef RN_SERIALIZABLE_STATE
-  bool operator==(const EnrichedTextInputViewHtmlStyleImgStruct&) const = default;
-
-  folly::dynamic toDynamic() const {
-    folly::dynamic result = folly::dynamic::object();
-    result["width"] = width;
-    result["height"] = height;
-    return result;
-  }
-#endif
-};
-
-static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleImgStruct &result) {
-  auto map = (std::unordered_map<std::string, RawValue>)value;
-
-  auto tmp_width = map.find("width");
-  if (tmp_width != map.end()) {
-    fromRawValue(context, tmp_width->second, result.width);
-  }
-  auto tmp_height = map.find("height");
-  if (tmp_height != map.end()) {
-    fromRawValue(context, tmp_height->second, result.height);
-  }
-}
-
-static inline std::string toString(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
-  return "[Object EnrichedTextInputViewHtmlStyleImgStruct]";
-}
-
-#ifdef RN_SERIALIZABLE_STATE
-static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
-  return value.toDynamic();
-}
-#endif
-
 struct EnrichedTextInputViewHtmlStyleOlStruct {
   Float gapWidth{0.0};
   Float marginLeft{0.0};
@@ -459,7 +420,6 @@ struct EnrichedTextInputViewHtmlStyleStruct {
   EnrichedTextInputViewHtmlStyleCodeStruct code{};
   EnrichedTextInputViewHtmlStyleAStruct a{};
   folly::dynamic mention{};
-  EnrichedTextInputViewHtmlStyleImgStruct img{};
   EnrichedTextInputViewHtmlStyleOlStruct ol{};
   EnrichedTextInputViewHtmlStyleUlStruct ul{};
 
@@ -476,7 +436,6 @@ struct EnrichedTextInputViewHtmlStyleStruct {
     result["code"] = ::facebook::react::toDynamic(code);
     result["a"] = ::facebook::react::toDynamic(a);
     result["mention"] = mention;
-    result["img"] = ::facebook::react::toDynamic(img);
     result["ol"] = ::facebook::react::toDynamic(ol);
     result["ul"] = ::facebook::react::toDynamic(ul);
     return result;
@@ -519,10 +478,6 @@ static inline void fromRawValue(const PropsParserContext& context, const RawValu
   if (tmp_mention != map.end()) {
     fromRawValue(context, tmp_mention->second, result.mention);
   }
-  auto tmp_img = map.find("img");
-  if (tmp_img != map.end()) {
-    fromRawValue(context, tmp_img->second, result.img);
-  }
   auto tmp_ol = map.find("ol");
   if (tmp_ol != map.end()) {
     fromRawValue(context, tmp_ol->second, result.ol);
diff --git a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/RCTComponentViewHelpers.h b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/RCTComponentViewHelpers.h
index 3aeab37..892d519 100644
--- a/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/RCTComponentViewHelpers.h
+++ b/node_modules/react-native-enriched/ios/generated/RNEnrichedTextInputViewSpec/RCTComponentViewHelpers.h
@@ -30,9 +30,10 @@ NS_ASSUME_NONNULL_BEGIN
 - (void)toggleOrderedList;
 - (void)toggleUnorderedList;
 - (void)addLink:(NSInteger)start end:(NSInteger)end text:(NSString *)text url:(NSString *)url;
-- (void)addImage:(NSString *)uri;
+- (void)addImage:(NSString *)uri width:(float)width height:(float)height;
 - (void)startMention:(NSString *)indicator;
 - (void)addMention:(NSString *)indicator text:(NSString *)text payload:(NSString *)payload;
+- (void)requestHTML:(NSInteger)requestId;
 @end
 
 RCT_EXTERN inline void RCTEnrichedTextInputViewHandleCommand(
@@ -302,8 +303,8 @@ NSObject *arg3 = args[3];
 
 if ([commandName isEqualToString:@"addImage"]) {
 #if RCT_DEBUG
-  if ([args count] != 1) {
-    RCTLogError(@"%@ command %@ received %d arguments, expected %d.", @"EnrichedTextInputView", commandName, (int)[args count], 1);
+  if ([args count] != 3) {
+    RCTLogError(@"%@ command %@ received %d arguments, expected %d.", @"EnrichedTextInputView", commandName, (int)[args count], 3);
     return;
   }
 #endif
@@ -316,7 +317,23 @@ if ([commandName isEqualToString:@"addImage"]) {
 #endif
   NSString * uri = (NSString *)arg0;
 
-  [componentView addImage:uri];
+NSObject *arg1 = args[1];
+#if RCT_DEBUG
+  if (!RCTValidateTypeOfViewCommandArgument(arg1, [NSNumber class], @"float", @"EnrichedTextInputView", commandName, @"2nd")) {
+    return;
+  }
+#endif
+  float width = [(NSNumber *)arg1 floatValue];
+
+NSObject *arg2 = args[2];
+#if RCT_DEBUG
+  if (!RCTValidateTypeOfViewCommandArgument(arg2, [NSNumber class], @"float", @"EnrichedTextInputView", commandName, @"3rd")) {
+    return;
+  }
+#endif
+  float height = [(NSNumber *)arg2 floatValue];
+
+  [componentView addImage:uri width:width height:height];
   return;
 }
 
@@ -376,6 +393,26 @@ NSObject *arg2 = args[2];
   return;
 }
 
+if ([commandName isEqualToString:@"requestHTML"]) {
+#if RCT_DEBUG
+  if ([args count] != 1) {
+    RCTLogError(@"%@ command %@ received %d arguments, expected %d.", @"EnrichedTextInputView", commandName, (int)[args count], 1);
+    return;
+  }
+#endif
+
+  NSObject *arg0 = args[0];
+#if RCT_DEBUG
+  if (!RCTValidateTypeOfViewCommandArgument(arg0, [NSNumber class], @"number", @"EnrichedTextInputView", commandName, @"1st")) {
+    return;
+  }
+#endif
+  NSInteger requestId = [(NSNumber *)arg0 intValue];
+
+  [componentView requestHTML:requestId];
+  return;
+}
+
 #if RCT_DEBUG
   RCTLogError(@"%@ received command %@, which is not a supported command.", @"EnrichedTextInputView", commandName);
 #endif
diff --git a/node_modules/react-native-enriched/ios/inputParser/InputParser.h b/node_modules/react-native-enriched/ios/inputParser/InputParser.h
index 5c35832..b54ace3 100644
--- a/node_modules/react-native-enriched/ios/inputParser/InputParser.h
+++ b/node_modules/react-native-enriched/ios/inputParser/InputParser.h
@@ -3,9 +3,9 @@
 
 @interface InputParser : NSObject
 - (instancetype _Nonnull)initWithInput:(id _Nonnull)input;
-- (NSString * _Nonnull)parseToHtmlFromRange:(NSRange)range;
-- (void)replaceWholeFromHtml:(NSString * _Nonnull)html;
-- (void)replaceFromHtml:(NSString * _Nonnull)html range:(NSRange)range;
-- (void)insertFromHtml:(NSString * _Nonnull)html location:(NSInteger)location;
-- (NSString * _Nullable)initiallyProcessHtml:(NSString * _Nonnull)html;
+- (NSString *_Nonnull)parseToHtmlFromRange:(NSRange)range;
+- (void)replaceWholeFromHtml:(NSString *_Nonnull)html;
+- (void)replaceFromHtml:(NSString *_Nonnull)html range:(NSRange)range;
+- (void)insertFromHtml:(NSString *_Nonnull)html location:(NSInteger)location;
+- (NSString *_Nullable)initiallyProcessHtml:(NSString *_Nonnull)html;
 @end
diff --git a/node_modules/react-native-enriched/ios/inputParser/InputParser.mm b/node_modules/react-native-enriched/ios/inputParser/InputParser.mm
index 17b06e8..b7dbdd0 100644
--- a/node_modules/react-native-enriched/ios/inputParser/InputParser.mm
+++ b/node_modules/react-native-enriched/ios/inputParser/InputParser.mm
@@ -1,9 +1,9 @@
 #import "InputParser.h"
 #import "EnrichedTextInputView.h"
+#import "StringExtension.h"
 #import "StyleHeaders.h"
-#import "UIView+React.h"
 #import "TextInsertionUtils.h"
-#import "StringExtension.h"
+#import "UIView+React.h"
 
 @implementation InputParser {
   EnrichedTextInputView *_input;
@@ -17,142 +17,217 @@
 
 - (NSString *)parseToHtmlFromRange:(NSRange)range {
   NSInteger offset = range.location;
-  NSString *text = [_input->textView.textStorage.string substringWithRange:range];
+  NSString *text =
+      [_input->textView.textStorage.string substringWithRange:range];
 
-  if(text.length == 0) {
+  if (text.length == 0) {
     return @"<html>\n<p></p>\n</html>";
   }
 
-  NSMutableString *result = [[NSMutableString alloc] initWithString: @"<html>"];
-  NSSet<NSNumber *>*previousActiveStyles = [[NSSet<NSNumber *> alloc]init];
+  NSMutableString *result = [[NSMutableString alloc] initWithString:@"<html>"];
+  NSSet<NSNumber *> *previousActiveStyles = [[NSSet<NSNumber *> alloc] init];
   BOOL newLine = YES;
   BOOL inUnorderedList = NO;
   BOOL inOrderedList = NO;
   BOOL inBlockQuote = NO;
+  BOOL inCodeBlock = NO;
   unichar lastCharacter = 0;
 
-  for(int i = 0; i < text.length; i++) {
+  for (int i = 0; i < text.length; i++) {
     NSRange currentRange = NSMakeRange(offset + i, 1);
-    NSMutableSet<NSNumber *>*currentActiveStyles = [[NSMutableSet<NSNumber *> alloc]init];
-    NSMutableDictionary *currentActiveStylesBeginning = [[NSMutableDictionary alloc] init];
+    NSMutableSet<NSNumber *> *currentActiveStyles =
+        [[NSMutableSet<NSNumber *> alloc] init];
+    NSMutableDictionary *currentActiveStylesBeginning =
+        [[NSMutableDictionary alloc] init];
 
     // check each existing style existence
-    for(NSNumber* type in _input->stylesDict) {
+    for (NSNumber *type in _input->stylesDict) {
       id<BaseStyleProtocol> style = _input->stylesDict[type];
-      if([style detectStyle:currentRange]) {
+      if ([style detectStyle:currentRange]) {
         [currentActiveStyles addObject:type];
 
-        if(![previousActiveStyles member:type]) {
+        if (![previousActiveStyles member:type]) {
           currentActiveStylesBeginning[type] = [NSNumber numberWithInt:i];
         }
-      } else if([previousActiveStyles member:type]) {
+      } else if ([previousActiveStyles member:type]) {
         [currentActiveStylesBeginning removeObjectForKey:type];
       }
     }
 
-    NSString *currentCharacterStr = [_input->textView.textStorage.string substringWithRange:currentRange];
-    unichar currentCharacterChar = [_input->textView.textStorage.string characterAtIndex:currentRange.location];
-    
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:currentCharacterChar]) {
-      if(newLine) {
-        // we can either have an empty list item OR need to close the list and put a BR in such a situation
-        // the existence of the list must be checked on 0 length range, not on the newline character
-        if(inOrderedList) {
+    NSString *currentCharacterStr =
+        [_input->textView.textStorage.string substringWithRange:currentRange];
+    unichar currentCharacterChar = [_input->textView.textStorage.string
+        characterAtIndex:currentRange.location];
+
+    if ([[NSCharacterSet newlineCharacterSet]
+            characterIsMember:currentCharacterChar]) {
+      if (newLine) {
+        // we can either have an empty list item OR need to close the list and
+        // put a BR in such a situation the existence of the list must be
+        // checked on 0 length range, not on the newline character
+        if (inOrderedList) {
           OrderedListStyle *oStyle = _input->stylesDict[@(OrderedList)];
-          BOOL detected = [oStyle detectStyle: NSMakeRange(currentRange.location, 0)];
-          if(detected) {
+          BOOL detected =
+              [oStyle detectStyle:NSMakeRange(currentRange.location, 0)];
+          if (detected) {
             [result appendString:@"\n<li></li>"];
           } else {
             [result appendString:@"\n</ol>\n<br>"];
             inOrderedList = NO;
           }
-        } else if(inUnorderedList) {
+        } else if (inUnorderedList) {
           UnorderedListStyle *uStyle = _input->stylesDict[@(UnorderedList)];
-          BOOL detected = [uStyle detectStyle: NSMakeRange(currentRange.location, 0)];
-          if(detected) {
+          BOOL detected =
+              [uStyle detectStyle:NSMakeRange(currentRange.location, 0)];
+          if (detected) {
             [result appendString:@"\n<li></li>"];
           } else {
             [result appendString:@"\n</ul>\n<br>"];
             inUnorderedList = NO;
           }
+        } else if (inBlockQuote) {
+          BlockQuoteStyle *bqStyle = _input->stylesDict[@(BlockQuote)];
+          BOOL detected =
+              [bqStyle detectStyle:NSMakeRange(currentRange.location, 0)];
+          if (detected) {
+            [result appendString:@"\n<br>"];
+          } else {
+            [result appendString:@"\n</blockquote>\n<br>"];
+            inBlockQuote = NO;
+          }
+        } else if (inCodeBlock) {
+          CodeBlockStyle *cbStyle = _input->stylesDict[@(CodeBlock)];
+          BOOL detected =
+              [cbStyle detectStyle:NSMakeRange(currentRange.location, 0)];
+          if (detected) {
+            [result appendString:@"\n<br>"];
+          } else {
+            [result appendString:@"\n</codeblock>\n<br>"];
+            inCodeBlock = NO;
+          }
         } else {
           [result appendString:@"\n<br>"];
         }
       } else {
         // newline finishes a paragraph and all style tags need to be closed
         // we use previous styles
-        NSArray<NSNumber*> *sortedEndedStyles = [previousActiveStyles sortedArrayUsingDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"intValue" ascending:NO]]];
+        NSArray<NSNumber *> *sortedEndedStyles = [previousActiveStyles
+            sortedArrayUsingDescriptors:@[ [NSSortDescriptor
+                                            sortDescriptorWithKey:@"intValue"
+                                                        ascending:NO] ]];
 
         // append closing tags
-        for(NSNumber *style in sortedEndedStyles) {
-          NSString *tagContent = [self tagContentForStyle:style openingTag:NO location:currentRange.location];
-          [result appendString: [NSString stringWithFormat:@"</%@>", tagContent]];
+        for (NSNumber *style in sortedEndedStyles) {
+          if ([style isEqualToNumber:@([ImageStyle getStyleType])]) {
+            continue;
+          }
+          NSString *tagContent =
+              [self tagContentForStyle:style
+                            openingTag:NO
+                              location:currentRange.location];
+          [result
+              appendString:[NSString stringWithFormat:@"</%@>", tagContent]];
         }
 
         // append closing paragraph tag
-        if([previousActiveStyles containsObject:@([UnorderedListStyle getStyleType])] ||
-           [previousActiveStyles containsObject:@([OrderedListStyle getStyleType])] ||
-           [previousActiveStyles containsObject:@([H1Style getStyleType])] ||
-           [previousActiveStyles containsObject:@([H2Style getStyleType])] ||
-           [previousActiveStyles containsObject:@([H3Style getStyleType])] ||
-           [previousActiveStyles containsObject:@([BlockQuoteStyle getStyleType])]
-        ) {
-          // do nothing, proper closing paragraph tags have been already appended
+        if ([previousActiveStyles
+                containsObject:@([UnorderedListStyle getStyleType])] ||
+            [previousActiveStyles
+                containsObject:@([OrderedListStyle getStyleType])] ||
+            [previousActiveStyles containsObject:@([H1Style getStyleType])] ||
+            [previousActiveStyles containsObject:@([H2Style getStyleType])] ||
+            [previousActiveStyles containsObject:@([H3Style getStyleType])] ||
+            [previousActiveStyles
+                containsObject:@([BlockQuoteStyle getStyleType])] ||
+            [previousActiveStyles
+                containsObject:@([CodeBlockStyle getStyleType])]) {
+          // do nothing, proper closing paragraph tags have been already
+          // appended
         } else {
           [result appendString:@"</p>"];
         }
       }
 
       // clear the previous styles
-      previousActiveStyles = [[NSSet<NSNumber *> alloc]init];
+      previousActiveStyles = [[NSSet<NSNumber *> alloc] init];
 
       // next character opens new paragraph
       newLine = YES;
     } else {
       // new line - open the paragraph
-      if(newLine) {
+      if (newLine) {
         newLine = NO;
 
         // handle ending unordered list
-        if(inUnorderedList && ![currentActiveStyles containsObject:@([UnorderedListStyle getStyleType])]) {
+        if (inUnorderedList &&
+            ![currentActiveStyles
+                containsObject:@([UnorderedListStyle getStyleType])]) {
           inUnorderedList = NO;
           [result appendString:@"\n</ul>"];
         }
         // handle ending ordered list
-        if(inOrderedList && ![currentActiveStyles containsObject:@([OrderedListStyle getStyleType])]) {
+        if (inOrderedList &&
+            ![currentActiveStyles
+                containsObject:@([OrderedListStyle getStyleType])]) {
           inOrderedList = NO;
           [result appendString:@"\n</ol>"];
         }
         // handle ending blockquotes
-        if(inBlockQuote && ![currentActiveStyles containsObject:@([BlockQuoteStyle getStyleType])]) {
+        if (inBlockQuote &&
+            ![currentActiveStyles
+                containsObject:@([BlockQuoteStyle getStyleType])]) {
           inBlockQuote = NO;
           [result appendString:@"\n</blockquote>"];
         }
+        // handle ending codeblock
+        if (inCodeBlock &&
+            ![currentActiveStyles
+                containsObject:@([CodeBlockStyle getStyleType])]) {
+          inCodeBlock = NO;
+          [result appendString:@"\n</codeblock>"];
+        }
 
         // handle starting unordered list
-        if(!inUnorderedList && [currentActiveStyles containsObject:@([UnorderedListStyle getStyleType])]) {
+        if (!inUnorderedList &&
+            [currentActiveStyles
+                containsObject:@([UnorderedListStyle getStyleType])]) {
           inUnorderedList = YES;
           [result appendString:@"\n<ul>"];
         }
         // handle starting ordered list
-        if(!inOrderedList && [currentActiveStyles containsObject:@([OrderedListStyle getStyleType])]) {
+        if (!inOrderedList &&
+            [currentActiveStyles
+                containsObject:@([OrderedListStyle getStyleType])]) {
           inOrderedList = YES;
           [result appendString:@"\n<ol>"];
         }
         // handle starting blockquotes
-        if(!inBlockQuote && [currentActiveStyles containsObject:@([BlockQuoteStyle getStyleType])]) {
+        if (!inBlockQuote &&
+            [currentActiveStyles
+                containsObject:@([BlockQuoteStyle getStyleType])]) {
           inBlockQuote = YES;
           [result appendString:@"\n<blockquote>"];
         }
+        // handle starting codeblock
+        if (!inCodeBlock &&
+            [currentActiveStyles
+                containsObject:@([CodeBlockStyle getStyleType])]) {
+          inCodeBlock = YES;
+          [result appendString:@"\n<codeblock>"];
+        }
 
         // don't add the <p> tag if some paragraph styles are present
-        if([currentActiveStyles containsObject:@([UnorderedListStyle getStyleType])] ||
-           [currentActiveStyles containsObject:@([OrderedListStyle getStyleType])] ||
-           [currentActiveStyles containsObject:@([H1Style getStyleType])] ||
-           [currentActiveStyles containsObject:@([H2Style getStyleType])] ||
-           [currentActiveStyles containsObject:@([H3Style getStyleType])] ||
-           [currentActiveStyles containsObject:@([BlockQuoteStyle getStyleType])]
-        ) {
+        if ([currentActiveStyles
+                containsObject:@([UnorderedListStyle getStyleType])] ||
+            [currentActiveStyles
+                containsObject:@([OrderedListStyle getStyleType])] ||
+            [currentActiveStyles containsObject:@([H1Style getStyleType])] ||
+            [currentActiveStyles containsObject:@([H2Style getStyleType])] ||
+            [currentActiveStyles containsObject:@([H3Style getStyleType])] ||
+            [currentActiveStyles
+                containsObject:@([BlockQuoteStyle getStyleType])] ||
+            [currentActiveStyles
+                containsObject:@([CodeBlockStyle getStyleType])]) {
           [result appendString:@"\n"];
         } else {
           [result appendString:@"\n<p>"];
@@ -160,53 +235,101 @@
       }
 
       // get styles that have ended
-      NSMutableSet<NSNumber *> *endedStyles = [previousActiveStyles mutableCopy];
-      [endedStyles minusSet: currentActiveStyles];
+      NSMutableSet<NSNumber *> *endedStyles =
+          [previousActiveStyles mutableCopy];
+      [endedStyles minusSet:currentActiveStyles];
 
-      // also finish styles that should be ended becasue they are nested in a style that ended
+      // also finish styles that should be ended becasue they are nested in a
+      // style that ended
       NSMutableSet *fixedEndedStyles = [endedStyles mutableCopy];
       NSMutableSet *stylesToBeReAdded = [[NSMutableSet alloc] init];
 
-      for(NSNumber *style in endedStyles) {
-        NSInteger styleBeginning = [currentActiveStylesBeginning[style] integerValue];
+      for (NSNumber *style in endedStyles) {
+        NSInteger styleBeginning =
+            [currentActiveStylesBeginning[style] integerValue];
 
-        for(NSNumber *activeStyle in currentActiveStyles) {
-          NSInteger activeStyleBeginning = [currentActiveStylesBeginning[activeStyle] integerValue];
+        for (NSNumber *activeStyle in currentActiveStyles) {
+          NSInteger activeStyleBeginning =
+              [currentActiveStylesBeginning[activeStyle] integerValue];
 
-          // we end the styles that began after the currently ended style but not at the "i" (cause the old style ended at exactly "i-1"
-          // also the ones that began in the exact same place but are "inner" in relation to them due to StyleTypeEnum integer values
+          // we end the styles that began after the currently ended style but
+          // not at the "i" (cause the old style ended at exactly "i-1" also the
+          // ones that began in the exact same place but are "inner" in relation
+          // to them due to StyleTypeEnum integer values
 
-          if((activeStyleBeginning > styleBeginning && activeStyleBeginning < i) ||
-             (activeStyleBeginning == styleBeginning && activeStyleBeginning < i && [activeStyle integerValue]  > [style integerValue])) {
+          if ((activeStyleBeginning > styleBeginning &&
+               activeStyleBeginning < i) ||
+              (activeStyleBeginning == styleBeginning &&
+               activeStyleBeginning<
+                   i && [activeStyle integerValue]>[style integerValue])) {
             [fixedEndedStyles addObject:activeStyle];
             [stylesToBeReAdded addObject:activeStyle];
           }
         }
       }
 
+      // if a style begins but there is a style inner to it that is (and was
+      // previously) active, it also should be closed and readded
+
+      // newly added styles
+      NSMutableSet *newStyles = [currentActiveStyles mutableCopy];
+      [newStyles minusSet:previousActiveStyles];
+      // styles that were and still are active
+      NSMutableSet *stillActiveStyles = [previousActiveStyles mutableCopy];
+      [stillActiveStyles intersectSet:currentActiveStyles];
+
+      for (NSNumber *style in newStyles) {
+        for (NSNumber *ongoingStyle in stillActiveStyles) {
+          if ([ongoingStyle integerValue] > [style integerValue]) {
+            // the prev style is inner; needs to be closed and re-added later
+            [fixedEndedStyles addObject:ongoingStyle];
+            [stylesToBeReAdded addObject:ongoingStyle];
+          }
+        }
+      }
+
       // they are sorted in a descending order
-      NSArray<NSNumber*> *sortedEndedStyles = [fixedEndedStyles sortedArrayUsingDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"intValue" ascending:NO]]];
+      NSArray<NSNumber *> *sortedEndedStyles = [fixedEndedStyles
+          sortedArrayUsingDescriptors:@[ [NSSortDescriptor
+                                          sortDescriptorWithKey:@"intValue"
+                                                      ascending:NO] ]];
 
       // append closing tags
-      for(NSNumber *style in sortedEndedStyles) {
-        NSString *tagContent = [self tagContentForStyle:style openingTag:NO location:currentRange.location];
-        [result appendString: [NSString stringWithFormat:@"</%@>", tagContent]];
+      for (NSNumber *style in sortedEndedStyles) {
+        if ([style isEqualToNumber:@([ImageStyle getStyleType])]) {
+          continue;
+        }
+        NSString *tagContent = [self tagContentForStyle:style
+                                             openingTag:NO
+                                               location:currentRange.location];
+        [result appendString:[NSString stringWithFormat:@"</%@>", tagContent]];
       }
 
-      // get styles that have begun: they are sorted in a ascending manner to properly keep tags' FILO order
-      NSMutableSet<NSNumber *> *newStyles = [currentActiveStyles mutableCopy];
-      [newStyles minusSet: previousActiveStyles];
-      [newStyles unionSet: stylesToBeReAdded];
-      NSArray<NSNumber*> *sortedNewStyles = [newStyles sortedArrayUsingDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"intValue" ascending:YES]]];
+      // all styles that have begun: new styles + the ones that need to be
+      // re-added they are sorted in a ascending manner to properly keep tags'
+      // FILO order
+      [newStyles unionSet:stylesToBeReAdded];
+      NSArray<NSNumber *> *sortedNewStyles = [newStyles
+          sortedArrayUsingDescriptors:@[ [NSSortDescriptor
+                                          sortDescriptorWithKey:@"intValue"
+                                                      ascending:YES] ]];
 
       // append opening tags
-      for(NSNumber *style in sortedNewStyles) {
-        NSString *tagContent = [self tagContentForStyle:style openingTag:YES location:currentRange.location];
-        [result appendString: [NSString stringWithFormat:@"<%@>", tagContent]];
+      for (NSNumber *style in sortedNewStyles) {
+        NSString *tagContent = [self tagContentForStyle:style
+                                             openingTag:YES
+                                               location:currentRange.location];
+        if ([style isEqualToNumber:@([ImageStyle getStyleType])]) {
+          [result
+              appendString:[NSString stringWithFormat:@"<%@/>", tagContent]];
+          [currentActiveStyles removeObject:@([ImageStyle getStyleType])];
+        } else {
+          [result appendString:[NSString stringWithFormat:@"<%@>", tagContent]];
+        }
       }
 
       // append the letter and escape it if needed
-      [result appendString: [NSString stringByEscapingHtml:currentCharacterStr]];
+      [result appendString:[NSString stringByEscapingHtml:currentCharacterStr]];
 
       // save current styles for next character's checks
       previousActiveStyles = currentActiveStyles;
@@ -216,75 +339,123 @@
     lastCharacter = currentCharacterChar;
   }
 
-  if(![[NSCharacterSet newlineCharacterSet] characterIsMember:lastCharacter]) {
+  if (![[NSCharacterSet newlineCharacterSet] characterIsMember:lastCharacter]) {
     // not-newline character was last - finish the paragraph
     // close all pending tags
-    NSArray<NSNumber*> *sortedEndedStyles = [previousActiveStyles sortedArrayUsingDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"intValue" ascending:NO]]];
+    NSArray<NSNumber *> *sortedEndedStyles = [previousActiveStyles
+        sortedArrayUsingDescriptors:@[ [NSSortDescriptor
+                                        sortDescriptorWithKey:@"intValue"
+                                                    ascending:NO] ]];
 
     // append closing tags
-    for(NSNumber *style in sortedEndedStyles) {
-      NSString *tagContent = [self tagContentForStyle:style openingTag:NO location:_input->textView.textStorage.string.length - 1];
-      [result appendString: [NSString stringWithFormat:@"</%@>", tagContent]];
+    for (NSNumber *style in sortedEndedStyles) {
+      if ([style isEqualToNumber:@([ImageStyle getStyleType])]) {
+        continue;
+      }
+      NSString *tagContent = [self
+          tagContentForStyle:style
+                  openingTag:NO
+                    location:_input->textView.textStorage.string.length - 1];
+      [result appendString:[NSString stringWithFormat:@"</%@>", tagContent]];
     }
 
     // finish the paragraph
     // handle ending of some paragraph styles
-    if([previousActiveStyles containsObject:@([UnorderedListStyle getStyleType])]) {
+    if ([previousActiveStyles
+            containsObject:@([UnorderedListStyle getStyleType])]) {
       [result appendString:@"\n</ul>"];
-    } else if([previousActiveStyles containsObject:@([OrderedListStyle getStyleType])]) {
+    } else if ([previousActiveStyles
+                   containsObject:@([OrderedListStyle getStyleType])]) {
       [result appendString:@"\n</ol>"];
-    } else if([previousActiveStyles containsObject:@([BlockQuoteStyle getStyleType])]) {
+    } else if ([previousActiveStyles
+                   containsObject:@([BlockQuoteStyle getStyleType])]) {
       [result appendString:@"\n</blockquote>"];
-    } else if(
-      [previousActiveStyles containsObject:@([H1Style getStyleType])] ||
-      [previousActiveStyles containsObject:@([H2Style getStyleType])] ||
-      [previousActiveStyles containsObject:@([H3Style getStyleType])]
-    ) {
+    } else if ([previousActiveStyles
+                   containsObject:@([CodeBlockStyle getStyleType])]) {
+      [result appendString:@"\n</codeblock>"];
+    } else if ([previousActiveStyles
+                   containsObject:@([H1Style getStyleType])] ||
+               [previousActiveStyles
+                   containsObject:@([H2Style getStyleType])] ||
+               [previousActiveStyles
+                   containsObject:@([H3Style getStyleType])]) {
       // do nothing, heading closing tag has already ben appended
     } else {
       [result appendString:@"</p>"];
     }
   } else {
     // newline character was last - some paragraph styles need to be closed
-    if(inUnorderedList) {
+    if (inUnorderedList) {
       inUnorderedList = NO;
       [result appendString:@"\n</ul>"];
     }
-    if(inOrderedList) {
+    if (inOrderedList) {
       inOrderedList = NO;
       [result appendString:@"\n</ol>"];
     }
-    if(inBlockQuote) {
+    if (inBlockQuote) {
       inBlockQuote = NO;
       [result appendString:@"\n</blockquote>"];
     }
+    if (inCodeBlock) {
+      inCodeBlock = NO;
+      [result appendString:@"\n</codeblock>"];
+    }
   }
 
-  [result appendString: @"\n</html>"];
+  [result appendString:@"\n</html>"];
 
   // remove zero width spaces in the very end
-  NSRange resultRange = NSMakeRange(0, result.length);
-  [result replaceOccurrencesOfString:@"\u200B" withString:@"" options:0 range:resultRange];
+  [result replaceOccurrencesOfString:@"\u200B"
+                          withString:@""
+                             options:0
+                               range:NSMakeRange(0, result.length)];
+
+  // replace empty <p></p> into <br> in the very end
+  [result replaceOccurrencesOfString:@"<p></p>"
+                          withString:@"<br>"
+                             options:0
+                               range:NSMakeRange(0, result.length)];
+
   return result;
 }
 
-- (NSString *)tagContentForStyle:(NSNumber *)style openingTag:(BOOL)openingTag location:(NSInteger)location {
-  if([style isEqualToNumber: @([BoldStyle getStyleType])]) {
+- (NSString *)tagContentForStyle:(NSNumber *)style
+                      openingTag:(BOOL)openingTag
+                        location:(NSInteger)location {
+  if ([style isEqualToNumber:@([BoldStyle getStyleType])]) {
     return @"b";
-  } else if([style isEqualToNumber: @([ItalicStyle getStyleType])]) {
+  } else if ([style isEqualToNumber:@([ItalicStyle getStyleType])]) {
     return @"i";
-  } else if([style isEqualToNumber: @([UnderlineStyle getStyleType])]) {
+  } else if ([style isEqualToNumber:@([ImageStyle getStyleType])]) {
+    if (openingTag) {
+      ImageStyle *imageStyle =
+          (ImageStyle *)_input->stylesDict[@([ImageStyle getStyleType])];
+      if (imageStyle != nullptr) {
+        ImageData *data = [imageStyle getImageDataAt:location];
+        if (data != nullptr && data.uri != nullptr) {
+          return [NSString
+              stringWithFormat:@"img src=\"%@\" width=\"%f\" height=\"%f\"",
+                               data.uri, data.width, data.height];
+        }
+      }
+      return @"img";
+    } else {
+      return @"";
+    }
+  } else if ([style isEqualToNumber:@([UnderlineStyle getStyleType])]) {
     return @"u";
-  } else if([style isEqualToNumber: @([StrikethroughStyle getStyleType])]) {
+  } else if ([style isEqualToNumber:@([StrikethroughStyle getStyleType])]) {
     return @"s";
-  } else if([style isEqualToNumber: @([InlineCodeStyle getStyleType])]) {
+  } else if ([style isEqualToNumber:@([InlineCodeStyle getStyleType])]) {
     return @"code";
-  } else if([style isEqualToNumber: @([LinkStyle getStyleType])]) {
-    if(openingTag) {
-      LinkStyle *linkStyle = (LinkStyle *)_input->stylesDict[@([LinkStyle getStyleType])];
-      if(linkStyle != nullptr) {
-        LinkData *data = [linkStyle getLinkDataAt: location];
-        if(data != nullptr && data.url != nullptr) {
+  } else if ([style isEqualToNumber:@([LinkStyle getStyleType])]) {
+    if (openingTag) {
+      LinkStyle *linkStyle =
+          (LinkStyle *)_input->stylesDict[@([LinkStyle getStyleType])];
+      if (linkStyle != nullptr) {
+        LinkData *data = [linkStyle getLinkDataAt:location];
+        if (data != nullptr && data.url != nullptr) {
           return [NSString stringWithFormat:@"a href=\"%@\"", data.url];
         }
       }
@@ -292,50 +463,62 @@
     } else {
       return @"a";
     }
-  } else if([style isEqualToNumber: @([MentionStyle getStyleType])]) {
-    if(openingTag) {
-      MentionStyle *mentionStyle = (MentionStyle *)_input->stylesDict[@([MentionStyle getStyleType])];
-      if(mentionStyle != nullptr) {
+  } else if ([style isEqualToNumber:@([MentionStyle getStyleType])]) {
+    if (openingTag) {
+      MentionStyle *mentionStyle =
+          (MentionStyle *)_input->stylesDict[@([MentionStyle getStyleType])];
+      if (mentionStyle != nullptr) {
         MentionParams *params = [mentionStyle getMentionParamsAt:location];
         // attributes can theoretically be nullptr
-        if(params != nullptr && params.indicator != nullptr && params.text != nullptr) {
-          NSMutableString *attrsStr = [[NSMutableString alloc] initWithString: @""];
-          if(params.attributes != nullptr) {
+        if (params != nullptr && params.indicator != nullptr &&
+            params.text != nullptr) {
+          NSMutableString *attrsStr =
+              [[NSMutableString alloc] initWithString:@""];
+          if (params.attributes != nullptr) {
             // turn attributes to Data and then into dict
-            NSData *attrsData = [params.attributes dataUsingEncoding:NSUTF8StringEncoding];
+            NSData *attrsData =
+                [params.attributes dataUsingEncoding:NSUTF8StringEncoding];
             NSError *jsonError;
-            NSDictionary *json = [NSJSONSerialization JSONObjectWithData:attrsData
-              options:0
-              error:&jsonError
-            ];
+            NSDictionary *json =
+                [NSJSONSerialization JSONObjectWithData:attrsData
+                                                options:0
+                                                  error:&jsonError];
             // format dict keys and values into string
-            [json enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
-              [attrsStr appendString: [NSString stringWithFormat:@" %@=\"%@\"", (NSString *)key, (NSString *)obj]];
+            [json enumerateKeysAndObjectsUsingBlock:^(
+                      id _Nonnull key, id _Nonnull obj, BOOL *_Nonnull stop) {
+              [attrsStr
+                  appendString:[NSString stringWithFormat:@" %@=\"%@\"",
+                                                          (NSString *)key,
+                                                          (NSString *)obj]];
             }];
           }
-          return [NSString stringWithFormat:@"mention text=\"%@\" indicator=\"%@\"%@", params.text, params.indicator, attrsStr];
+          return [NSString
+              stringWithFormat:@"mention text=\"%@\" indicator=\"%@\"%@",
+                               params.text, params.indicator, attrsStr];
         }
       }
       return @"mention";
     } else {
       return @"mention";
     }
-  } else if([style isEqualToNumber:@([H1Style getStyleType])]) {
+  } else if ([style isEqualToNumber:@([H1Style getStyleType])]) {
     return @"h1";
-  } else if([style isEqualToNumber:@([H2Style getStyleType])]) {
+  } else if ([style isEqualToNumber:@([H2Style getStyleType])]) {
     return @"h2";
-  } else if([style isEqualToNumber:@([H3Style getStyleType])]) {
+  } else if ([style isEqualToNumber:@([H3Style getStyleType])]) {
     return @"h3";
-  } else if([style isEqualToNumber:@([UnorderedListStyle getStyleType])] || [style isEqualToNumber:@([OrderedListStyle getStyleType])]) {
+  } else if ([style isEqualToNumber:@([UnorderedListStyle getStyleType])] ||
+             [style isEqualToNumber:@([OrderedListStyle getStyleType])]) {
     return @"li";
-  } else if([style isEqualToNumber:@([BlockQuoteStyle getStyleType])]) {
-    // blockquotes use <p> tags the same way lists use <li>
+  } else if ([style isEqualToNumber:@([BlockQuoteStyle getStyleType])] ||
+             [style isEqualToNumber:@([CodeBlockStyle getStyleType])]) {
+    // blockquotes and codeblock use <p> tags the same way lists use <li>
     return @"p";
   }
   return @"";
 }
 
-- (void)replaceWholeFromHtml:(NSString * _Nonnull)html {
+- (void)replaceWholeFromHtml:(NSString *_Nonnull)html {
   NSArray *processingResult = [self getTextAndStylesFromHtml:html];
   NSString *plainText = (NSString *)processingResult[0];
   NSArray *stylesInfo = (NSArray *)processingResult[1];
@@ -348,215 +531,491 @@
   _input->textView.text = plainText;
 
   // re-apply the styles
-  [self applyProcessedStyles:stylesInfo offsetFromBeginning:0];
+  [self applyProcessedStyles:stylesInfo
+         offsetFromBeginning:0
+             plainTextLength:plainText.length];
 }
 
-- (void)replaceFromHtml:(NSString * _Nonnull)html range:(NSRange)range {
+- (void)replaceFromHtml:(NSString *_Nonnull)html range:(NSRange)range {
   NSArray *processingResult = [self getTextAndStylesFromHtml:html];
   NSString *plainText = (NSString *)processingResult[0];
   NSArray *stylesInfo = (NSArray *)processingResult[1];
 
   // we can use ready replace util
-  [TextInsertionUtils replaceText:plainText at:range additionalAttributes:nil input:_input withSelection:YES];
-  
-  [self applyProcessedStyles:stylesInfo offsetFromBeginning:range.location];
+  [TextInsertionUtils replaceText:plainText
+                               at:range
+             additionalAttributes:nil
+                            input:_input
+                    withSelection:YES];
+
+  [self applyProcessedStyles:stylesInfo
+         offsetFromBeginning:range.location
+             plainTextLength:plainText.length];
 }
 
-- (void)insertFromHtml:(NSString * _Nonnull)html location:(NSInteger)location {
+- (void)insertFromHtml:(NSString *_Nonnull)html location:(NSInteger)location {
   NSArray *processingResult = [self getTextAndStylesFromHtml:html];
   NSString *plainText = (NSString *)processingResult[0];
   NSArray *stylesInfo = (NSArray *)processingResult[1];
 
   // same here, insertion utils got our back
-  [TextInsertionUtils insertText:plainText at:location additionalAttributes:nil input:_input withSelection:YES];
-  
-  [self applyProcessedStyles:stylesInfo offsetFromBeginning:location];
+  [TextInsertionUtils insertText:plainText
+                              at:location
+            additionalAttributes:nil
+                           input:_input
+                   withSelection:YES];
+
+  [self applyProcessedStyles:stylesInfo
+         offsetFromBeginning:location
+             plainTextLength:plainText.length];
 }
 
-- (void)applyProcessedStyles:(NSArray *)processedStyles offsetFromBeginning:(NSInteger)offset {
-  for(NSArray* arr in processedStyles) {
+- (void)applyProcessedStyles:(NSArray *)processedStyles
+         offsetFromBeginning:(NSInteger)offset
+             plainTextLength:(NSUInteger)plainTextLength {
+  for (NSArray *arr in processedStyles) {
     // unwrap all info from processed style
     NSNumber *styleType = (NSNumber *)arr[0];
     StylePair *stylePair = (StylePair *)arr[1];
     id<BaseStyleProtocol> baseStyle = _input->stylesDict[styleType];
-    // range must be taking offest into consideration because processed styles' ranges are relative to only the new text
-    // while we need absolute ranges relative to the whole existing text
-    NSRange styleRange = NSMakeRange(offset + [stylePair.rangeValue rangeValue].location, [stylePair.rangeValue rangeValue].length);
-    
-    // of course any changes here need to take blocks and conflicts into consideration
-    if([_input handleStyleBlocksAndConflicts:[[baseStyle class] getStyleType] range:styleRange]) {
-      if([styleType isEqualToNumber: @([LinkStyle getStyleType])]) {
-        NSString *text = [_input->textView.textStorage.string substringWithRange:styleRange];
+    // range must be taking offest into consideration because processed styles'
+    // ranges are relative to only the new text while we need absolute ranges
+    // relative to the whole existing text
+    NSRange styleRange =
+        NSMakeRange(offset + [stylePair.rangeValue rangeValue].location,
+                    [stylePair.rangeValue rangeValue].length);
+
+    // of course any changes here need to take blocks and conflicts into
+    // consideration
+    if ([_input handleStyleBlocksAndConflicts:[[baseStyle class] getStyleType]
+                                        range:styleRange]) {
+      if ([styleType isEqualToNumber:@([LinkStyle getStyleType])]) {
+        NSString *text =
+            [_input->textView.textStorage.string substringWithRange:styleRange];
         NSString *url = (NSString *)stylePair.styleValue;
         BOOL isManual = ![text isEqualToString:url];
-        [((LinkStyle *)baseStyle) addLink:text url:url range:styleRange manual:isManual];
-      } else if([styleType isEqualToNumber: @([MentionStyle getStyleType])]) {
+        [((LinkStyle *)baseStyle) addLink:text
+                                      url:url
+                                    range:styleRange
+                                   manual:isManual
+                            withSelection:NO];
+      } else if ([styleType isEqualToNumber:@([MentionStyle getStyleType])]) {
         MentionParams *params = (MentionParams *)stylePair.styleValue;
-        [((MentionStyle *)baseStyle) addMentionAtRange:styleRange params:params];
+        [((MentionStyle *)baseStyle) addMentionAtRange:styleRange
+                                                params:params];
+      } else if ([styleType isEqualToNumber:@([ImageStyle getStyleType])]) {
+        ImageData *imgData = (ImageData *)stylePair.styleValue;
+        [((ImageStyle *)baseStyle) addImageAtRange:styleRange
+                                         imageData:imgData
+                                     withSelection:NO];
       } else {
-        [baseStyle addAttributes:styleRange];
+        BOOL shouldAddTypingAttr =
+            styleRange.location + styleRange.length == plainTextLength;
+        [baseStyle addAttributes:styleRange withTypingAttr:shouldAddTypingAttr];
       }
     }
   }
   [_input anyTextMayHaveBeenModified];
 }
 
-- (NSString * _Nullable)initiallyProcessHtml:(NSString * _Nonnull)html {
+- (NSString *_Nullable)initiallyProcessHtml:(NSString *_Nonnull)html {
+  NSString *htmlWithoutSpaces = [self stripExtraWhiteSpacesAndNewlines:html];
   NSString *fixedHtml = nullptr;
 
-  if(html.length >= 13) {
-    NSString *firstSix = [html substringWithRange:NSMakeRange(0, 6)];
-    NSString *lastSeven = [html substringWithRange:NSMakeRange(html.length-7, 7)];
+  if (htmlWithoutSpaces.length >= 13) {
+    NSString *firstSix =
+        [htmlWithoutSpaces substringWithRange:NSMakeRange(0, 6)];
+    NSString *lastSeven = [htmlWithoutSpaces
+        substringWithRange:NSMakeRange(htmlWithoutSpaces.length - 7, 7)];
 
-    if([firstSix isEqualToString:@"<html>"] && [lastSeven isEqualToString:@"</html>"]) {
+    if ([firstSix isEqualToString:@"<html>"] &&
+        [lastSeven isEqualToString:@"</html>"]) {
       // remove html tags, might be with newlines or without them
-      fixedHtml = [html copy];
+      fixedHtml = [htmlWithoutSpaces copy];
       // firstly remove newlined html tags if any:
-      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>\n" withString:@""];
-      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"\n</html>" withString:@""];
+      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>\n"
+                                                       withString:@""];
+      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"\n</html>"
+                                                       withString:@""];
       // fallback; remove html tags without their newlines
-      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>" withString:@""];
-      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</html>" withString:@""];
+      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>"
+                                                       withString:@""];
+      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</html>"
+                                                       withString:@""];
     } else {
-      // in other case we are most likely working with some external html - try getting the styles from between body tags
-      NSRange openingBodyRange = [html rangeOfString:@"<body>"];
-      NSRange closingBodyRange = [html rangeOfString:@"</body>"];
+      // in other case we are most likely working with some external html - try
+      // getting the styles from between body tags
+      NSRange openingBodyRange = [htmlWithoutSpaces rangeOfString:@"<body>"];
+      NSRange closingBodyRange = [htmlWithoutSpaces rangeOfString:@"</body>"];
 
-      if(openingBodyRange.length != 0 && closingBodyRange.length != 0) {
+      if (openingBodyRange.length != 0 && closingBodyRange.length != 0) {
         NSInteger newStart = openingBodyRange.location + 7;
         NSInteger newEnd = closingBodyRange.location - 1;
-        fixedHtml = [html substringWithRange:NSMakeRange(newStart, newEnd - newStart + 1)];
+        fixedHtml = [htmlWithoutSpaces
+            substringWithRange:NSMakeRange(newStart, newEnd - newStart + 1)];
       }
     }
   }
 
   // second processing - try fixing htmls with wrong newlines' setup
-  if(fixedHtml != nullptr) {
+  if (fixedHtml != nullptr) {
     // add <br> tag wherever needed
-    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<p></p>" withString:@"<br>"];
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<p></p>"
+                                                     withString:@"<br>"];
 
     // remove <p> tags inside of <li>
-    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<li><p>" withString:@"<li>"];
-    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</p></li>" withString:@"</li>"];
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<li><p>"
+                                                     withString:@"<li>"];
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</p></li>"
+                                                     withString:@"</li>"];
+
+    // change <br/> to <br>
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<br/>"
+                                                     withString:@"<br>"];
+
+    // remove <p> tags around <br>
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<p><br>"
+                                                     withString:@"<br>"];
+    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<br></p>"
+                                                     withString:@"<br>"];
 
     // tags that have to be in separate lines
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<br>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<ul>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</ul>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<ol>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</ol>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<blockquote>" inString:fixedHtml leading:YES trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</blockquote>" inString:fixedHtml leading:YES trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<br>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<ul>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</ul>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<ol>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</ol>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<blockquote>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</blockquote>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<codeblock>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</codeblock>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:YES];
 
     // line opening tags
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<p>" inString:fixedHtml leading:YES trailing:NO];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<li>" inString:fixedHtml leading:YES trailing:NO];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<h1>" inString:fixedHtml leading:YES trailing:NO];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<h2>" inString:fixedHtml leading:YES trailing:NO];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"<h3>" inString:fixedHtml leading:YES trailing:NO];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<p>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:NO];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<li>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:NO];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<h1>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:NO];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<h2>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:NO];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"<h3>"
+                                         inString:fixedHtml
+                                          leading:YES
+                                         trailing:NO];
 
     // line closing tags
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</p>" inString:fixedHtml leading:NO trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</li>" inString:fixedHtml leading:NO trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</h1>" inString:fixedHtml leading:NO trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</h2>" inString:fixedHtml leading:NO trailing:YES];
-    fixedHtml = [self stringByAddingNewlinesToTag:@"</h3>" inString:fixedHtml leading:NO trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</p>"
+                                         inString:fixedHtml
+                                          leading:NO
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</li>"
+                                         inString:fixedHtml
+                                          leading:NO
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</h1>"
+                                         inString:fixedHtml
+                                          leading:NO
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</h2>"
+                                         inString:fixedHtml
+                                          leading:NO
+                                         trailing:YES];
+    fixedHtml = [self stringByAddingNewlinesToTag:@"</h3>"
+                                         inString:fixedHtml
+                                          leading:NO
+                                         trailing:YES];
+
+    // this is more like a hack but for some reason the last <br> in
+    // <blockquote> and <codeblock> are not properly changed into zero width
+    // space so we do that manually here
+    fixedHtml = [fixedHtml
+        stringByReplacingOccurrencesOfString:@"<br>\n</blockquote>"
+                                  withString:@"<p>\u200B</p>\n</blockquote>"];
+    fixedHtml = [fixedHtml
+        stringByReplacingOccurrencesOfString:@"<br>\n</codeblock>"
+                                  withString:@"<p>\u200B</p>\n</codeblock>"];
+
+    // replace "<br>" at the end with "<br>\n" if input is not empty to properly
+    // handle last <br> in html
+    if ([fixedHtml hasSuffix:@"<br>"] && fixedHtml.length != 4) {
+      fixedHtml = [fixedHtml stringByAppendingString:@"\n"];
+    }
   }
 
   return fixedHtml;
 }
 
-- (NSString *)stringByAddingNewlinesToTag:(NSString *)tag inString:(NSString *)html leading:(BOOL)leading trailing:(BOOL)trailing {
+/**
+ * Prepares HTML for the parser by stripping extraneous whitespace and newlines
+ * from structural tags, while preserving them within text content.
+ *
+ * APPROACH:
+ * This function treats the HTML as having two distinct states:
+ * 1. Structure Mode (Depth == 0): We are inside or between container tags (like
+ * <blockquote>, <ul>, <codeblock>). In this mode whitespace and newlines are
+ * considered layout artifacts and are REMOVED to prevent the parser from
+ * creating unwanted spaces.
+ * 2. Content Mode (Depth > 0): We are inside a text-containing tag (like <p>,
+ * <b>, <li>). In this mode, all whitespace is PRESERVED exactly as is, ensuring
+ * that sentences and inline formatting remain readable.
+ *
+ * The function iterates character-by-character, using a depth counter to track
+ * nesting levels of the specific tags defined in `textTags`.
+ *
+ * IMPORTANT:
+ * The `textTags` set acts as a whitelist for "Content Mode". If you add support
+ * for a new HTML tag that contains visible text (e.g., <h4>, <h5>, <h6>),
+ * you MUST add it to the `textTags` set below.
+ */
+- (NSString *)stripExtraWhiteSpacesAndNewlines:(NSString *)html {
+  NSSet *textTags =
+      [NSSet setWithObjects:@"p", @"h1", @"h2", @"h3", @"li", @"b", @"a", @"s",
+                            @"mention", @"code", @"u", @"i", nil];
+
+  NSMutableString *output = [NSMutableString stringWithCapacity:html.length];
+  NSMutableString *currentTagBuffer = [NSMutableString string];
+  NSCharacterSet *whitespaceAndNewlineSet =
+      [NSCharacterSet whitespaceAndNewlineCharacterSet];
+
+  BOOL isReadingTag = NO;
+  NSInteger textDepth = 0;
+
+  for (NSUInteger i = 0; i < html.length; i++) {
+    unichar c = [html characterAtIndex:i];
+
+    if (c == '<') {
+      isReadingTag = YES;
+      [currentTagBuffer setString:@""];
+      [output appendString:@"<"];
+    } else if (c == '>') {
+      isReadingTag = NO;
+      [output appendString:@">"];
+
+      NSString *fullTag = [currentTagBuffer lowercaseString];
+
+      NSString *cleanName = [fullTag
+          stringByTrimmingCharactersInSet:
+              [NSCharacterSet characterSetWithCharactersInString:@"/"]];
+      NSArray *parts =
+          [cleanName componentsSeparatedByCharactersInSet:
+                         [NSCharacterSet whitespaceAndNewlineCharacterSet]];
+      NSString *tagName = parts.firstObject;
+
+      if (![textTags containsObject:tagName]) {
+        continue;
+      }
+
+      if ([fullTag hasPrefix:@"/"]) {
+        textDepth--;
+        if (textDepth < 0)
+          textDepth = 0;
+      } else {
+        // Opening tag (e.g. <h1>) -> Enter Text Mode
+        // (Ignore self-closing tags like <img/> if they happen to be in the
+        // list)
+        if (![fullTag hasSuffix:@"/"]) {
+          textDepth++;
+        }
+      }
+    } else {
+      if (isReadingTag) {
+        [currentTagBuffer appendFormat:@"%C", c];
+        [output appendFormat:@"%C", c];
+        continue;
+      }
+
+      if (textDepth > 0) {
+        [output appendFormat:@"%C", c];
+      } else {
+        if (![whitespaceAndNewlineSet characterIsMember:c]) {
+          [output appendFormat:@"%C", c];
+        }
+      }
+    }
+  }
+
+  return output;
+}
+
+- (NSString *)stringByAddingNewlinesToTag:(NSString *)tag
+                                 inString:(NSString *)html
+                                  leading:(BOOL)leading
+                                 trailing:(BOOL)trailing {
   NSString *str = [html copy];
-  if(leading) {
+  if (leading) {
     NSString *formattedTag = [NSString stringWithFormat:@">%@", tag];
     NSString *formattedNewTag = [NSString stringWithFormat:@">\n%@", tag];
-    str = [str stringByReplacingOccurrencesOfString:formattedTag withString:formattedNewTag];
+    str = [str stringByReplacingOccurrencesOfString:formattedTag
+                                         withString:formattedNewTag];
   }
-  if(trailing) {
+  if (trailing) {
     NSString *formattedTag = [NSString stringWithFormat:@"%@<", tag];
     NSString *formattedNewTag = [NSString stringWithFormat:@"%@\n<", tag];
-    str = [str stringByReplacingOccurrencesOfString:formattedTag withString:formattedNewTag];
+    str = [str stringByReplacingOccurrencesOfString:formattedTag
+                                         withString:formattedNewTag];
   }
   return str;
 }
 
+- (void)finalizeTagEntry:(NSMutableString *)tagName
+               ongoingTags:(NSMutableDictionary *)ongoingTags
+    initiallyProcessedTags:(NSMutableArray *)processedTags
+                 plainText:(NSMutableString *)plainText {
+  NSMutableArray *tagEntry = [[NSMutableArray alloc] init];
+
+  NSArray *tagData = ongoingTags[tagName];
+  NSInteger tagLocation = [((NSNumber *)tagData[0]) intValue];
+  NSRange tagRange = NSMakeRange(tagLocation, plainText.length - tagLocation);
+
+  [tagEntry addObject:[tagName copy]];
+  [tagEntry addObject:[NSValue valueWithRange:tagRange]];
+  if (tagData.count > 1) {
+    [tagEntry addObject:[(NSString *)tagData[1] copy]];
+  }
+
+  [processedTags addObject:tagEntry];
+  [ongoingTags removeObjectForKey:tagName];
+}
+
 - (NSArray *)getTextAndStylesFromHtml:(NSString *)fixedHtml {
-  NSMutableString *plainText = [[NSMutableString alloc] initWithString: @""];
+  NSMutableString *plainText = [[NSMutableString alloc] initWithString:@""];
   NSMutableDictionary *ongoingTags = [[NSMutableDictionary alloc] init];
   NSMutableArray *initiallyProcessedTags = [[NSMutableArray alloc] init];
   BOOL insideTag = NO;
   BOOL gettingTagName = NO;
   BOOL gettingTagParams = NO;
   BOOL closingTag = NO;
-  NSMutableString *currentTagName = [[NSMutableString alloc] initWithString:@""];
-  NSMutableString *currentTagParams = [[NSMutableString alloc] initWithString:@""];
-  NSDictionary *htmlEntitiesDict = [NSString getEscapedCharactersInfoFrom:fixedHtml];
+  NSMutableString *currentTagName =
+      [[NSMutableString alloc] initWithString:@""];
+  NSMutableString *currentTagParams =
+      [[NSMutableString alloc] initWithString:@""];
+  NSDictionary *htmlEntitiesDict =
+      [NSString getEscapedCharactersInfoFrom:fixedHtml];
 
   // firstly, extract text and initially processed tags
-  for(int i = 0; i < fixedHtml.length; i++) {
-    NSString *currentCharacterStr = [fixedHtml substringWithRange:NSMakeRange(i, 1)];
+  for (int i = 0; i < fixedHtml.length; i++) {
+    NSString *currentCharacterStr =
+        [fixedHtml substringWithRange:NSMakeRange(i, 1)];
     unichar currentCharacterChar = [fixedHtml characterAtIndex:i];
 
-    if(currentCharacterChar == '<') {
+    if (currentCharacterChar == '<') {
       // opening the tag, mark that we are inside and getting its name
       insideTag = YES;
       gettingTagName = YES;
-    } else if(currentCharacterChar == '>') {
-      // finishing some tag, no longer marked as inside or getting its name/params
+    } else if (currentCharacterChar == '>') {
+      // finishing some tag, no longer marked as inside or getting its
+      // name/params
       insideTag = NO;
       gettingTagName = NO;
       gettingTagParams = NO;
 
-      if([currentTagName isEqualToString:@"p"] || [currentTagName isEqualToString:@"br"] || [currentTagName isEqualToString:@"li"]) {
+      BOOL isSelfClosing = NO;
+
+      // Check if params ended with '/' (e.g. <img src="" />)
+      if ([currentTagParams hasSuffix:@"/"]) {
+        [currentTagParams
+            deleteCharactersInRange:NSMakeRange(currentTagParams.length - 1,
+                                                1)];
+        isSelfClosing = YES;
+      }
+
+      if ([currentTagName isEqualToString:@"p"] ||
+          [currentTagName isEqualToString:@"br"] ||
+          [currentTagName isEqualToString:@"li"]) {
         // do nothing, we don't include these tags in styles
-      } else if(!closingTag) {
-        // we finish opening tag - get its location and optionally params and put them under tag name key in ongoingTags
+      } else if (!closingTag) {
+        // we finish opening tag - get its location and optionally params and
+        // put them under tag name key in ongoingTags
         NSMutableArray *tagArr = [[NSMutableArray alloc] init];
         [tagArr addObject:[NSNumber numberWithInteger:plainText.length]];
-        if(currentTagParams.length > 0) {
+        if (currentTagParams.length > 0) {
           [tagArr addObject:[currentTagParams copy]];
         }
         ongoingTags[currentTagName] = tagArr;
 
-        // skip one newline after opening tags that are in separate lines intentionally
-        if([currentTagName isEqualToString:@"ul"] || [currentTagName isEqualToString:@"ol"] || [currentTagName isEqualToString:@"blockquote"]) {
+        // skip one newline after opening tags that are in separate lines
+        // intentionally
+        if ([currentTagName isEqualToString:@"ul"] ||
+            [currentTagName isEqualToString:@"ol"] ||
+            [currentTagName isEqualToString:@"blockquote"] ||
+            [currentTagName isEqualToString:@"codeblock"]) {
           i += 1;
         }
-      } else {
-        // we finish closing tags - pack tag name, tag range and optionally tag params into an entry that goes inside initiallyProcessedTags
 
-        // skip one newline that was added before some closing tags that are in separate lines
-        if([currentTagName isEqualToString:@"ul"] || [currentTagName isEqualToString:@"ol"] || [currentTagName isEqualToString:@"blockquote"]) {
-          plainText = [[plainText substringWithRange: NSMakeRange(0, plainText.length - 1)] mutableCopy];
+        if (isSelfClosing) {
+          [self finalizeTagEntry:currentTagName
+                         ongoingTags:ongoingTags
+              initiallyProcessedTags:initiallyProcessedTags
+                           plainText:plainText];
         }
-        
-        NSMutableArray *tagEntry = [[NSMutableArray alloc] init];
-      
-        NSArray *tagData = ongoingTags[currentTagName];
-        NSInteger tagLocation = [((NSNumber *)tagData[0]) intValue];
-        NSRange tagRange = NSMakeRange(tagLocation, plainText.length - tagLocation);
-        
-        [tagEntry addObject:[currentTagName copy]];
-        [tagEntry addObject:[NSValue valueWithRange:tagRange]];
-        if(tagData.count > 1) {
-          [tagEntry addObject:[(NSString *)tagData[1] copy]];
+      } else {
+        // we finish closing tags - pack tag name, tag range and optionally tag
+        // params into an entry that goes inside initiallyProcessedTags
+
+        // skip one newline that was added before some closing tags that are in
+        // separate lines
+        if ([currentTagName isEqualToString:@"ul"] ||
+            [currentTagName isEqualToString:@"ol"] ||
+            [currentTagName isEqualToString:@"blockquote"] ||
+            [currentTagName isEqualToString:@"codeblock"]) {
+          plainText = [[plainText
+              substringWithRange:NSMakeRange(0, plainText.length - 1)]
+              mutableCopy];
         }
 
-        [initiallyProcessedTags addObject:tagEntry];
-        [ongoingTags removeObjectForKey:currentTagName];
+        [self finalizeTagEntry:currentTagName
+                       ongoingTags:ongoingTags
+            initiallyProcessedTags:initiallyProcessedTags
+                         plainText:plainText];
       }
       // post-tag cleanup
       closingTag = NO;
       currentTagName = [[NSMutableString alloc] initWithString:@""];
       currentTagParams = [[NSMutableString alloc] initWithString:@""];
     } else {
-      if(!insideTag) {
+      if (!insideTag) {
         // no tags logic - just append the right text
 
-        // html entity on the index; use unescaped character and forward iterator accordingly
+        // html entity on the index; use unescaped character and forward
+        // iterator accordingly
         NSArray *entityInfo = htmlEntitiesDict[@(i)];
-        if(entityInfo != nullptr) {
+        if (entityInfo != nullptr) {
           NSString *escaped = entityInfo[0];
           NSString *unescaped = entityInfo[1];
           [plainText appendString:unescaped];
@@ -566,19 +1025,19 @@
           [plainText appendString:currentCharacterStr];
         }
       } else {
-        if(gettingTagName) {
-          if(currentCharacterChar == ' ') {
+        if (gettingTagName) {
+          if (currentCharacterChar == ' ') {
             // no longer getting tag name - switch to params
             gettingTagName = NO;
             gettingTagParams = YES;
-          } else if(currentCharacterChar == '/') {
+          } else if (currentCharacterChar == '/') {
             // mark that the tag is closing
             closingTag = YES;
           } else {
             // append next tag char
             [currentTagName appendString:currentCharacterStr];
           }
-        } else if(gettingTagParams) {
+        } else if (gettingTagParams) {
           // append next tag params char
           [currentTagParams appendString:currentCharacterStr];
         }
@@ -589,34 +1048,91 @@
   // process tags into proper StyleType + StylePair values
   NSMutableArray *processedStyles = [[NSMutableArray alloc] init];
 
-  for(NSArray* arr in initiallyProcessedTags) {
+  for (NSArray *arr in initiallyProcessedTags) {
     NSString *tagName = (NSString *)arr[0];
     NSValue *tagRangeValue = (NSValue *)arr[1];
     NSMutableString *params = [[NSMutableString alloc] initWithString:@""];
-    if(arr.count > 2) {
+    if (arr.count > 2) {
       [params appendString:(NSString *)arr[2]];
     }
 
     NSMutableArray *styleArr = [[NSMutableArray alloc] init];
     StylePair *stylePair = [[StylePair alloc] init];
-    if([tagName isEqualToString:@"b"]) {
+    if ([tagName isEqualToString:@"b"]) {
       [styleArr addObject:@([BoldStyle getStyleType])];
-    } else if([tagName isEqualToString:@"i"]) {
+    } else if ([tagName isEqualToString:@"i"]) {
       [styleArr addObject:@([ItalicStyle getStyleType])];
-    } else if([tagName isEqualToString:@"u"]) {
+    } else if ([tagName isEqualToString:@"img"]) {
+      NSRegularExpression *srcRegex =
+          [NSRegularExpression regularExpressionWithPattern:@"src=\"([^\"]+)\""
+                                                    options:0
+                                                      error:nullptr];
+      NSTextCheckingResult *match =
+          [srcRegex firstMatchInString:params
+                               options:0
+                                 range:NSMakeRange(0, params.length)];
+
+      if (match == nullptr) {
+        continue;
+      }
+
+      NSRange srcRange = match.range;
+      [styleArr addObject:@([ImageStyle getStyleType])];
+      // cut only the uri from the src="..." string
+      NSString *uri =
+          [params substringWithRange:NSMakeRange(srcRange.location + 5,
+                                                 srcRange.length - 6)];
+      ImageData *imageData = [[ImageData alloc] init];
+      imageData.uri = uri;
+
+      NSRegularExpression *widthRegex = [NSRegularExpression
+          regularExpressionWithPattern:@"width=\"([0-9.]+)\""
+                               options:0
+                                 error:nil];
+      NSTextCheckingResult *widthMatch =
+          [widthRegex firstMatchInString:params
+                                 options:0
+                                   range:NSMakeRange(0, params.length)];
+
+      if (widthMatch) {
+        NSString *widthString =
+            [params substringWithRange:[widthMatch rangeAtIndex:1]];
+        imageData.width = [widthString floatValue];
+      }
+
+      NSRegularExpression *heightRegex = [NSRegularExpression
+          regularExpressionWithPattern:@"height=\"([0-9.]+)\""
+                               options:0
+                                 error:nil];
+      NSTextCheckingResult *heightMatch =
+          [heightRegex firstMatchInString:params
+                                  options:0
+                                    range:NSMakeRange(0, params.length)];
+
+      if (heightMatch) {
+        NSString *heightString =
+            [params substringWithRange:[heightMatch rangeAtIndex:1]];
+        imageData.height = [heightString floatValue];
+      }
+
+      stylePair.styleValue = imageData;
+    } else if ([tagName isEqualToString:@"u"]) {
       [styleArr addObject:@([UnderlineStyle getStyleType])];
-    } else if([tagName isEqualToString:@"s"]) {
+    } else if ([tagName isEqualToString:@"s"]) {
       [styleArr addObject:@([StrikethroughStyle getStyleType])];
-    } else if([tagName isEqualToString:@"code"]) {
+    } else if ([tagName isEqualToString:@"code"]) {
       [styleArr addObject:@([InlineCodeStyle getStyleType])];
-    } else if([tagName isEqualToString:@"a"]) {
-      NSRegularExpression *hrefRegex = [NSRegularExpression regularExpressionWithPattern:@"href=\".+\""
-        options:0
-        error:nullptr
-      ];
-      NSTextCheckingResult* match = [hrefRegex firstMatchInString:params options:0 range: NSMakeRange(0, params.length)];
-      
-      if(match == nullptr) {
+    } else if ([tagName isEqualToString:@"a"]) {
+      NSRegularExpression *hrefRegex =
+          [NSRegularExpression regularExpressionWithPattern:@"href=\".+\""
+                                                    options:0
+                                                      error:nullptr];
+      NSTextCheckingResult *match =
+          [hrefRegex firstMatchInString:params
+                                options:0
+                                  range:NSMakeRange(0, params.length)];
+
+      if (match == nullptr) {
         // same as on Android, no href (or empty href) equals no link style
         continue;
       }
@@ -624,52 +1140,70 @@
       NSRange hrefRange = match.range;
       [styleArr addObject:@([LinkStyle getStyleType])];
       // cut only the url from the href="..." string
-      NSString *url = [params substringWithRange:NSMakeRange(hrefRange.location + 6, hrefRange.length - 7)];
+      NSString *url =
+          [params substringWithRange:NSMakeRange(hrefRange.location + 6,
+                                                 hrefRange.length - 7)];
       stylePair.styleValue = url;
-    } else if([tagName isEqualToString:@"mention"]) {
+    } else if ([tagName isEqualToString:@"mention"]) {
       [styleArr addObject:@([MentionStyle getStyleType])];
       // extract html expression into dict using some regex
       NSMutableDictionary *paramsDict = [[NSMutableDictionary alloc] init];
       NSString *pattern = @"(\\w+)=\"([^\"]*)\"";
-      NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
-      
-      [regex enumerateMatchesInString:params options:0 range:NSMakeRange(0,params.length)
-        usingBlock:^(NSTextCheckingResult * _Nullable result, NSMatchingFlags flags, BOOL * _Nonnull stop) {
-          if(result.numberOfRanges == 3) {
-            NSString *key = [params substringWithRange:[result rangeAtIndex:1]];
-            NSString *value = [params substringWithRange:[result rangeAtIndex:2]];
-            paramsDict[key] = value;
-          }
-        }
-      ];
+      NSRegularExpression *regex =
+          [NSRegularExpression regularExpressionWithPattern:pattern
+                                                    options:0
+                                                      error:nil];
+
+      [regex enumerateMatchesInString:params
+                              options:0
+                                range:NSMakeRange(0, params.length)
+                           usingBlock:^(NSTextCheckingResult *_Nullable result,
+                                        NSMatchingFlags flags,
+                                        BOOL *_Nonnull stop) {
+                             if (result.numberOfRanges == 3) {
+                               NSString *key = [params
+                                   substringWithRange:[result rangeAtIndex:1]];
+                               NSString *value = [params
+                                   substringWithRange:[result rangeAtIndex:2]];
+                               paramsDict[key] = value;
+                             }
+                           }];
 
       MentionParams *mentionParams = [[MentionParams alloc] init];
       mentionParams.text = paramsDict[@"text"];
       mentionParams.indicator = paramsDict[@"indicator"];
 
-      [paramsDict removeObjectsForKeys:@[@"text", @"indicator"]];
+      [paramsDict removeObjectsForKeys:@[ @"text", @"indicator" ]];
       NSError *error;
-      NSData *attrsData = [NSJSONSerialization dataWithJSONObject:paramsDict options:0 error:&error];
-      NSString *formattedAttrsString = [[NSString alloc] initWithData:attrsData encoding:NSUTF8StringEncoding];
+      NSData *attrsData = [NSJSONSerialization dataWithJSONObject:paramsDict
+                                                          options:0
+                                                            error:&error];
+      NSString *formattedAttrsString =
+          [[NSString alloc] initWithData:attrsData
+                                encoding:NSUTF8StringEncoding];
       mentionParams.attributes = formattedAttrsString;
 
       stylePair.styleValue = mentionParams;
-    } else if([[tagName substringWithRange:NSMakeRange(0, 1)] isEqualToString: @"h"]) {
-      if([tagName isEqualToString:@"h1"]) {
+    } else if ([[tagName substringWithRange:NSMakeRange(0, 1)]
+                   isEqualToString:@"h"]) {
+      if ([tagName isEqualToString:@"h1"]) {
         [styleArr addObject:@([H1Style getStyleType])];
-      } else if([tagName isEqualToString:@"h2"]) {
+      } else if ([tagName isEqualToString:@"h2"]) {
         [styleArr addObject:@([H2Style getStyleType])];
-      } else if([tagName isEqualToString:@"h3"]) {
+      } else if ([tagName isEqualToString:@"h3"]) {
         [styleArr addObject:@([H3Style getStyleType])];
       }
-    } else if([tagName isEqualToString:@"ul"]) {
+    } else if ([tagName isEqualToString:@"ul"]) {
       [styleArr addObject:@([UnorderedListStyle getStyleType])];
-    } else if([tagName isEqualToString:@"ol"]) {
+    } else if ([tagName isEqualToString:@"ol"]) {
       [styleArr addObject:@([OrderedListStyle getStyleType])];
-    } else if([tagName isEqualToString:@"blockquote"]) {
+    } else if ([tagName isEqualToString:@"blockquote"]) {
       [styleArr addObject:@([BlockQuoteStyle getStyleType])];
+    } else if ([tagName isEqualToString:@"codeblock"]) {
+      [styleArr addObject:@([CodeBlockStyle getStyleType])];
     } else {
-      // some other external tags like span just don't get put into the processed styles
+      // some other external tags like span just don't get put into the
+      // processed styles
       continue;
     }
 
@@ -678,7 +1212,7 @@
     [processedStyles addObject:styleArr];
   }
 
-  return @[plainText, processedStyles];
+  return @[ plainText, processedStyles ];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/inputTextView/InputTextView.h b/node_modules/react-native-enriched/ios/inputTextView/InputTextView.h
index f116593..6ddac2e 100644
--- a/node_modules/react-native-enriched/ios/inputTextView/InputTextView.h
+++ b/node_modules/react-native-enriched/ios/inputTextView/InputTextView.h
@@ -2,5 +2,5 @@
 #import <UIkit/UIKit.h>
 
 @interface InputTextView : UITextView
-@property (nonatomic, weak) id input;
+@property(nonatomic, weak) id input;
 @end
diff --git a/node_modules/react-native-enriched/ios/inputTextView/InputTextView.mm b/node_modules/react-native-enriched/ios/inputTextView/InputTextView.mm
index 73115fa..2487c90 100644
--- a/node_modules/react-native-enriched/ios/inputTextView/InputTextView.mm
+++ b/node_modules/react-native-enriched/ios/inputTextView/InputTextView.mm
@@ -1,113 +1,154 @@
 #import "InputTextView.h"
 #import "EnrichedTextInputView.h"
 #import "StringExtension.h"
-#import <UniformTypeIdentifiers/UniformTypeIdentifiers.h>
 #import "TextInsertionUtils.h"
+#import <UniformTypeIdentifiers/UniformTypeIdentifiers.h>
 
 @implementation InputTextView
 
 - (void)copy:(id)sender {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)_input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   // remove zero width spaces before copying the text
-  NSString *plainText = [typedInput->textView.textStorage.string substringWithRange:typedInput->textView.selectedRange];
-  NSString *fixedPlainText = [plainText stringByReplacingOccurrencesOfString:@"\u200B" withString:@""];
+  NSString *plainText = [typedInput->textView.textStorage.string
+      substringWithRange:typedInput->textView.selectedRange];
+  NSString *fixedPlainText =
+      [plainText stringByReplacingOccurrencesOfString:@"\u200B" withString:@""];
 
-  NSString *parsedHtml = [typedInput->parser parseToHtmlFromRange:typedInput->textView.selectedRange];
+  NSString *parsedHtml = [typedInput->parser
+      parseToHtmlFromRange:typedInput->textView.selectedRange];
 
-  NSMutableAttributedString *attrStr = [[typedInput->textView.textStorage attributedSubstringFromRange:typedInput->textView.selectedRange] mutableCopy];
+  NSMutableAttributedString *attrStr = [[typedInput->textView.textStorage
+      attributedSubstringFromRange:typedInput->textView.selectedRange]
+      mutableCopy];
   NSRange fullAttrStrRange = NSMakeRange(0, attrStr.length);
-  [attrStr.mutableString replaceOccurrencesOfString:@"\u200B" withString:@"" options:0 range:fullAttrStrRange];
-  
-  NSData *rtfData = [attrStr dataFromRange:NSMakeRange(0, attrStr.length)
-    documentAttributes:@{NSDocumentTypeDocumentAttribute:NSRTFTextDocumentType}
-    error:nullptr
-  ];
+  [attrStr.mutableString replaceOccurrencesOfString:@"\u200B"
+                                         withString:@""
+                                            options:0
+                                              range:fullAttrStrRange];
+
+  NSData *rtfData =
+      [attrStr dataFromRange:NSMakeRange(0, attrStr.length)
+          documentAttributes:@{
+            NSDocumentTypeDocumentAttribute : NSRTFTextDocumentType
+          }
+                       error:nullptr];
 
   UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
-  [pasteboard setItems:@[@{
-    UTTypeUTF8PlainText.identifier : fixedPlainText,
-    UTTypeHTML.identifier : parsedHtml,
-    UTTypeRTF.identifier : rtfData
-  }]];
+  [pasteboard setItems:@[ @{
+                UTTypeUTF8PlainText.identifier : fixedPlainText,
+                UTTypeHTML.identifier : parsedHtml,
+                UTTypeRTF.identifier : rtfData
+              } ]];
 }
 
 - (void)paste:(id)sender {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)_input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
   NSArray<NSString *> *pasteboardTypes = pasteboard.pasteboardTypes;
   NSRange currentRange = typedInput->textView.selectedRange;
 
-  if([pasteboardTypes containsObject:UTTypeHTML.identifier]) {
+  if ([pasteboardTypes containsObject:UTTypeHTML.identifier]) {
     // we try processing the html contents
 
     NSString *htmlString;
     id htmlValue = [pasteboard valueForPasteboardType:UTTypeHTML.identifier];
 
-    if([htmlValue isKindOfClass:[NSData class]]) {
-      htmlString = [[NSString alloc]initWithData:htmlValue encoding:NSUTF8StringEncoding];
-    } else if([htmlValue isKindOfClass:[NSString class]]) {
+    if ([htmlValue isKindOfClass:[NSData class]]) {
+      htmlString = [[NSString alloc] initWithData:htmlValue
+                                         encoding:NSUTF8StringEncoding];
+    } else if ([htmlValue isKindOfClass:[NSString class]]) {
       htmlString = htmlValue;
     }
 
     // validate the html
-    NSString *initiallyProcessedHtml = [typedInput->parser initiallyProcessHtml:htmlString];
+    NSString *initiallyProcessedHtml =
+        [typedInput->parser initiallyProcessHtml:htmlString];
 
-    if(initiallyProcessedHtml != nullptr) {
+    if (initiallyProcessedHtml != nullptr) {
       // valid html, let's apply it
       currentRange.length > 0
-        ? [typedInput->parser replaceFromHtml:initiallyProcessedHtml range:currentRange]
-        : [typedInput->parser insertFromHtml:initiallyProcessedHtml location:currentRange.location];
+          ? [typedInput->parser replaceFromHtml:initiallyProcessedHtml
+                                          range:currentRange]
+          : [typedInput->parser insertFromHtml:initiallyProcessedHtml
+                                      location:currentRange.location];
     } else {
       // fall back to plain text, otherwise do nothing
-      [self tryHandlingPlainTextItemsIn:pasteboard range:currentRange input:typedInput];
+      [self tryHandlingPlainTextItemsIn:pasteboard
+                                  range:currentRange
+                                  input:typedInput];
     }
   } else {
-    [self tryHandlingPlainTextItemsIn:pasteboard range:currentRange input:typedInput];
+    [self tryHandlingPlainTextItemsIn:pasteboard
+                                range:currentRange
+                                input:typedInput];
   }
 
   [typedInput anyTextMayHaveBeenModified];
 }
 
-- (void)tryHandlingPlainTextItemsIn:(UIPasteboard *)pasteboard range:(NSRange)range input:(EnrichedTextInputView *)input {
+- (void)tryHandlingPlainTextItemsIn:(UIPasteboard *)pasteboard
+                              range:(NSRange)range
+                              input:(EnrichedTextInputView *)input {
   NSArray *existingTypes = pasteboard.pasteboardTypes;
-  NSArray *handledTypes = @[UTTypeUTF8PlainText.identifier, UTTypePlainText.identifier, UTTypeURL.identifier];
+  NSArray *handledTypes = @[
+    UTTypeUTF8PlainText.identifier, UTTypePlainText.identifier,
+    UTTypeURL.identifier
+  ];
   NSString *plainText;
 
-  for(NSString *type in handledTypes) {
-    if(![existingTypes containsObject:type]) {
+  for (NSString *type in handledTypes) {
+    if (![existingTypes containsObject:type]) {
       continue;
     }
 
     id value = [pasteboard valueForPasteboardType:type];
 
-    if([value isKindOfClass:[NSData class]]) {
-      plainText = [[NSString alloc]initWithData:value encoding:NSUTF8StringEncoding];
-    } else if([value isKindOfClass:[NSString class]]) {
+    if ([value isKindOfClass:[NSData class]]) {
+      plainText = [[NSString alloc] initWithData:value
+                                        encoding:NSUTF8StringEncoding];
+    } else if ([value isKindOfClass:[NSString class]]) {
       plainText = (NSString *)value;
-    } else if([value isKindOfClass:[NSURL class]]) {
+    } else if ([value isKindOfClass:[NSURL class]]) {
       plainText = [(NSURL *)value absoluteString];
     }
   }
 
-  if(!plainText) {
+  if (!plainText) {
     return;
   }
 
-  range.length > 0
-    ? [TextInsertionUtils replaceText:plainText at:range additionalAttributes:nullptr input:input withSelection:YES]
-    : [TextInsertionUtils insertText:plainText at:range.location additionalAttributes:nullptr input:input withSelection:YES];
+  range.length > 0 ? [TextInsertionUtils replaceText:plainText
+                                                  at:range
+                                additionalAttributes:nullptr
+                                               input:input
+                                       withSelection:YES]
+                   : [TextInsertionUtils insertText:plainText
+                                                 at:range.location
+                               additionalAttributes:nullptr
+                                              input:input
+                                      withSelection:YES];
 }
 
 - (void)cut:(id)sender {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)_input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   [self copy:sender];
-  [TextInsertionUtils replaceText:@"" at:typedInput->textView.selectedRange additionalAttributes:nullptr input:typedInput  withSelection:YES];
+  [TextInsertionUtils replaceText:@""
+                               at:typedInput->textView.selectedRange
+             additionalAttributes:nullptr
+                            input:typedInput
+                    withSelection:YES];
 
   [typedInput anyTextMayHaveBeenModified];
 }
diff --git a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewComponentDescriptor.h b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewComponentDescriptor.h
index ddffc42..eae9472 100644
--- a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewComponentDescriptor.h
+++ b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewComponentDescriptor.h
@@ -1,17 +1,19 @@
 #pragma once
-#include <react/debug/react_native_assert.h>
+#include <ReactNativeEnriched/EnrichedTextInputViewShadowNode.h>
 #include <ReactNativeEnriched/Props.h>
+#include <react/debug/react_native_assert.h>
 #include <react/renderer/core/ConcreteComponentDescriptor.h>
-#include <ReactNativeEnriched/EnrichedTextInputViewShadowNode.h>
 
 namespace facebook::react {
-class EnrichedTextInputViewComponentDescriptor final : public ConcreteComponentDescriptor<EnrichedTextInputViewShadowNode> {
-  public:
-    using ConcreteComponentDescriptor::ConcreteComponentDescriptor;
-    void adopt(ShadowNode &shadowNode) const override {
-      react_native_assert(dynamic_cast<EnrichedTextInputViewShadowNode *>(&shadowNode));
-      ConcreteComponentDescriptor::adopt(shadowNode);
-    }
+class EnrichedTextInputViewComponentDescriptor final
+    : public ConcreteComponentDescriptor<EnrichedTextInputViewShadowNode> {
+public:
+  using ConcreteComponentDescriptor::ConcreteComponentDescriptor;
+  void adopt(ShadowNode &shadowNode) const override {
+    react_native_assert(
+        dynamic_cast<EnrichedTextInputViewShadowNode *>(&shadowNode));
+    ConcreteComponentDescriptor::adopt(shadowNode);
+  }
 };
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.h b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.h
index 1e3c5ff..9789e9b 100644
--- a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.h
+++ b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.h
@@ -1,10 +1,10 @@
 #pragma once
+#include <ReactNativeEnriched/EnrichedTextInputViewState.h>
 #include <ReactNativeEnriched/EventEmitters.h>
 #include <ReactNativeEnriched/Props.h>
-#include <ReactNativeEnriched/EnrichedTextInputViewState.h>
+#include <jsi/jsi.h>
 #include <react/renderer/components/view/ConcreteViewShadowNode.h>
 #include <react/renderer/core/LayoutConstraints.h>
-#include <jsi/jsi.h>
 
 namespace facebook::react {
 
@@ -13,28 +13,32 @@ JSI_EXPORT extern const char EnrichedTextInputViewComponentName[];
 /*
  * `ShadowNode` for <EnrichedTextInputView> component.
  */
-class EnrichedTextInputViewShadowNode : public ConcreteViewShadowNode<
-        EnrichedTextInputViewComponentName,
-        EnrichedTextInputViewProps,
-        EnrichedTextInputViewEventEmitter,
-        EnrichedTextInputViewState> {
-    public:
-    using ConcreteViewShadowNode::ConcreteViewShadowNode;
-    EnrichedTextInputViewShadowNode(const ShadowNodeFragment& fragment, const ShadowNodeFamily::Shared& family, ShadowNodeTraits traits);
-    EnrichedTextInputViewShadowNode(const ShadowNode& sourceShadowNode, const ShadowNodeFragment& fragment);
-    void dirtyLayoutIfNeeded();
-    Size measureContent(const LayoutContext& layoutContext, const LayoutConstraints& layoutConstraints) const override;
-    
+class EnrichedTextInputViewShadowNode
+    : public ConcreteViewShadowNode<
+          EnrichedTextInputViewComponentName, EnrichedTextInputViewProps,
+          EnrichedTextInputViewEventEmitter, EnrichedTextInputViewState> {
+public:
+  using ConcreteViewShadowNode::ConcreteViewShadowNode;
+  EnrichedTextInputViewShadowNode(const ShadowNodeFragment &fragment,
+                                  const ShadowNodeFamily::Shared &family,
+                                  ShadowNodeTraits traits);
+  EnrichedTextInputViewShadowNode(const ShadowNode &sourceShadowNode,
+                                  const ShadowNodeFragment &fragment);
+  void dirtyLayoutIfNeeded();
+  Size
+  measureContent(const LayoutContext &layoutContext,
+                 const LayoutConstraints &layoutConstraints) const override;
 
-    static ShadowNodeTraits BaseTraits() {
-      auto traits = ConcreteViewShadowNode::BaseTraits();
-      traits.set(ShadowNodeTraits::Trait::LeafYogaNode);
-      traits.set(ShadowNodeTraits::Trait::MeasurableYogaNode);
-      return traits;
-    }
+  static ShadowNodeTraits BaseTraits() {
+    auto traits = ConcreteViewShadowNode::BaseTraits();
+    traits.set(ShadowNodeTraits::Trait::LeafYogaNode);
+    traits.set(ShadowNodeTraits::Trait::MeasurableYogaNode);
+    return traits;
+  }
 
-    private:
-    int localForceHeightRecalculationCounter_;
+private:
+  int localForceHeightRecalculationCounter_;
+  id setupMockTextInputView_() const;
 };
 
 } // namespace facebook::react
diff --git a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.mm b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.mm
index 647d5f1..6d56056 100644
--- a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.mm
+++ b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewShadowNode.mm
@@ -1,26 +1,39 @@
 #import "EnrichedTextInputViewShadowNode.h"
+#import "CoreText/CoreText.h"
 #import <EnrichedTextInputView.h>
+#import <React/RCTShadowView+Layout.h>
 #import <react/utils/ManagedObjectWrapper.h>
 #import <yoga/Yoga.h>
-#import <React/RCTShadowView+Layout.h>
-#import "CoreText/CoreText.h"
 
 namespace facebook::react {
 
-extern const char EnrichedTextInputViewComponentName[] = "EnrichedTextInputView";
+extern const char EnrichedTextInputViewComponentName[] =
+    "EnrichedTextInputView";
 
 EnrichedTextInputViewShadowNode::EnrichedTextInputViewShadowNode(
-  const ShadowNodeFragment& fragment,
-  const ShadowNodeFamily::Shared& family,
-  ShadowNodeTraits traits
-): ConcreteViewShadowNode(fragment, family, traits) {
+    const ShadowNodeFragment &fragment, const ShadowNodeFamily::Shared &family,
+    ShadowNodeTraits traits)
+    : ConcreteViewShadowNode(fragment, family, traits) {
   localForceHeightRecalculationCounter_ = 0;
 }
 
+// mock input is used for the first measure calls that need to be done when the
+// real input isn't defined yet
+id EnrichedTextInputViewShadowNode::setupMockTextInputView_() const {
+  // it's rendered far away from the viewport
+  const int veryFarAway = 20000;
+  const int mockSize = 1000;
+  EnrichedTextInputView *mockTextInputView_ = [[EnrichedTextInputView alloc]
+      initWithFrame:(CGRectMake(veryFarAway, veryFarAway, mockSize, mockSize))];
+  const auto props = this->getProps();
+  mockTextInputView_->blockEmitting = YES;
+  [mockTextInputView_ updateProps:props oldProps:nullptr];
+  return mockTextInputView_;
+}
+
 EnrichedTextInputViewShadowNode::EnrichedTextInputViewShadowNode(
-  const ShadowNode& sourceShadowNode,
-  const ShadowNodeFragment& fragment
-): ConcreteViewShadowNode(sourceShadowNode, fragment) {
+    const ShadowNode &sourceShadowNode, const ShadowNodeFragment &fragment)
+    : ConcreteViewShadowNode(sourceShadowNode, fragment) {
   dirtyLayoutIfNeeded();
 }
 
@@ -28,56 +41,60 @@ void EnrichedTextInputViewShadowNode::dirtyLayoutIfNeeded() {
   const auto state = this->getStateData();
   const int receivedCounter = state.getForceHeightRecalculationCounter();
 
-  if(receivedCounter > localForceHeightRecalculationCounter_) {
+  if (receivedCounter > localForceHeightRecalculationCounter_) {
     localForceHeightRecalculationCounter_ = receivedCounter;
     YGNodeMarkDirty(&yogaNode_);
   }
 }
 
-Size EnrichedTextInputViewShadowNode::measureContent(const LayoutContext& layoutContext, const LayoutConstraints& layoutConstraints) const {
+Size EnrichedTextInputViewShadowNode::measureContent(
+    const LayoutContext &layoutContext,
+    const LayoutConstraints &layoutConstraints) const {
   const auto state = this->getStateData();
   const auto componentRef = state.getComponentViewRef();
-  RCTInternalGenericWeakWrapper *weakWrapper = (RCTInternalGenericWeakWrapper *)unwrapManagedObject(componentRef);
+  RCTInternalGenericWeakWrapper *weakWrapper =
+      (RCTInternalGenericWeakWrapper *)unwrapManagedObject(componentRef);
 
-  if(weakWrapper != nullptr) {
+  if (weakWrapper != nullptr) {
     id componentObject = weakWrapper.object;
-    EnrichedTextInputView *typedComponentObject = (EnrichedTextInputView *) componentObject;
+    EnrichedTextInputView *typedComponentObject =
+        (EnrichedTextInputView *)componentObject;
 
-    if(typedComponentObject != nullptr) {
+    if (typedComponentObject != nullptr) {
       __block CGSize estimatedSize;
 
       // synchronously dispatch to main thread if needed
-      if([NSThread isMainThread]) {
-        estimatedSize = [typedComponentObject measureSize:layoutConstraints.maximumSize.width];
+      if ([NSThread isMainThread]) {
+        estimatedSize = [typedComponentObject
+            measureSize:layoutConstraints.maximumSize.width];
       } else {
         dispatch_sync(dispatch_get_main_queue(), ^{
-          estimatedSize = [typedComponentObject measureSize:layoutConstraints.maximumSize.width];
+          estimatedSize = [typedComponentObject
+              measureSize:layoutConstraints.maximumSize.width];
         });
       }
 
-      return {
-        estimatedSize.width,
-        MIN(estimatedSize.height, layoutConstraints.maximumSize.height)
-      };
+      return {estimatedSize.width,
+              MIN(estimatedSize.height, layoutConstraints.maximumSize.height)};
     }
   } else {
-    // on the very first call there is no componentView that we can query for the component height
-    // thus, a little heuristic: just put a height that is exactly height of letter "I" with default apple font and size from props
-    // in a lot of cases it will be the desired height
-    // in others, the jump on the second call will at least be smaller
-    const auto props = this->getProps();
-    const auto &typedProps = *std::static_pointer_cast<EnrichedTextInputViewProps const>(props);
-    NSAttributedString *attrStr = [[NSAttributedString alloc] initWithString:@"I" attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:typedProps.fontSize]}];
-    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrStr);
-    const CGSize &suggestedSize = CTFramesetterSuggestFrameSizeWithConstraints(
-      framesetter,
-      CFRangeMake(0, 1),
-      nullptr,
-      CGSizeMake(layoutConstraints.maximumSize.width, DBL_MAX),
-      nullptr
-    );
-    
-    return {suggestedSize.width, suggestedSize.height};
+    __block CGSize estimatedSize;
+
+    // synchronously dispatch to main thread if needed
+    if ([NSThread isMainThread]) {
+      EnrichedTextInputView *mockTextInputView = setupMockTextInputView_();
+      estimatedSize =
+          [mockTextInputView measureSize:layoutConstraints.maximumSize.width];
+    } else {
+      dispatch_sync(dispatch_get_main_queue(), ^{
+        EnrichedTextInputView *mockTextInputView = setupMockTextInputView_();
+        estimatedSize =
+            [mockTextInputView measureSize:layoutConstraints.maximumSize.width];
+      });
+    }
+
+    return {estimatedSize.width,
+            MIN(estimatedSize.height, layoutConstraints.maximumSize.height)};
   }
 
   return Size();
diff --git a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewState.h b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewState.h
index 4d5ac6a..3da93fe 100644
--- a/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewState.h
+++ b/node_modules/react-native-enriched/ios/internals/EnrichedTextInputViewState.h
@@ -5,13 +5,15 @@ namespace facebook::react {
 
 class EnrichedTextInputViewState {
 public:
-  EnrichedTextInputViewState(): forceHeightRecalculationCounter_(0), componentViewRef_(nullptr) {}
+  EnrichedTextInputViewState()
+      : forceHeightRecalculationCounter_(0), componentViewRef_(nullptr) {}
   EnrichedTextInputViewState(int counter, std::shared_ptr<void> ref) {
     forceHeightRecalculationCounter_ = counter;
     componentViewRef_ = ref;
   }
   int getForceHeightRecalculationCounter() const;
   std::shared_ptr<void> getComponentViewRef() const;
+
 private:
   int forceHeightRecalculationCounter_{};
   std::shared_ptr<void> componentViewRef_{};
diff --git a/node_modules/react-native-enriched/ios/styles/BlockQuoteStyle.mm b/node_modules/react-native-enriched/ios/styles/BlockQuoteStyle.mm
index 4c04cbb..f8d039c 100644
--- a/node_modules/react-native-enriched/ios/styles/BlockQuoteStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/BlockQuoteStyle.mm
@@ -1,136 +1,184 @@
-#import "StyleHeaders.h"
+#import "ColorExtension.h"
 #import "EnrichedTextInputView.h"
 #import "OccurenceUtils.h"
 #import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
-#import "ColorExtension.h"
 
 @implementation BlockQuoteStyle {
   EnrichedTextInputView *_input;
+  NSArray *_stylesToExclude;
 }
 
-+ (StyleType)getStyleType { return BlockQuote; }
++ (StyleType)getStyleType {
+  return BlockQuote;
+}
+
++ (BOOL)isParagraphStyle {
+  return YES;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
   _input = (EnrichedTextInputView *)input;
+  _stylesToExclude = @[ @(InlineCode), @(Mention), @(Link) ];
   return self;
 }
 
 - (CGFloat)getHeadIndent {
   // rectangle width + gap
-  return [_input->config blockquoteBorderWidth] + [_input->config blockquoteGapWidth];
+  return [_input->config blockquoteBorderWidth] +
+         [_input->config blockquoteGapWidth];
 }
 
 // the range will already be the full paragraph/s range
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
-  // if we fill empty lines with zero width spaces, we need to offset later ranges
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
+  // if we fill empty lines with zero width spaces, we need to offset later
+  // ranges
   NSInteger offset = 0;
   NSRange preModificationRange = _input->textView.selectedRange;
 
   // to not emit any space filling selection/text changes
   _input->blockEmitting = YES;
 
-  for(NSValue *value in paragraphs) {
-    NSRange pRange = NSMakeRange([value rangeValue].location + offset, [value rangeValue].length);
-    
-    // length 0 with first line, length 1 and newline with some empty lines in the middle
-    if(pRange.length == 0 ||
-      (pRange.length == 1 &&
-      [[NSCharacterSet newlineCharacterSet] characterIsMember: [_input->textView.textStorage.string characterAtIndex:pRange.location]])
-    ) {
-      [TextInsertionUtils insertText:@"\u200B" at:pRange.location additionalAttributes:nullptr input:_input withSelection:NO];
+  for (NSValue *value in paragraphs) {
+    NSRange pRange = NSMakeRange([value rangeValue].location + offset,
+                                 [value rangeValue].length);
+
+    // length 0 with first line, length 1 and newline with some empty lines in
+    // the middle
+    if (pRange.length == 0 ||
+        (pRange.length == 1 &&
+         [[NSCharacterSet newlineCharacterSet]
+             characterIsMember:[_input->textView.textStorage.string
+                                   characterAtIndex:pRange.location]])) {
+      [TextInsertionUtils insertText:@"\u200B"
+                                  at:pRange.location
+                additionalAttributes:nullptr
+                               input:_input
+                       withSelection:NO];
       pRange = NSMakeRange(pRange.location, pRange.length + 1);
       offset += 1;
     }
 
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:pRange options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.headIndent = [self getHeadIndent];
-        pStyle.firstLineHeadIndent = [self getHeadIndent];
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:pRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.headIndent = [self getHeadIndent];
+                  pStyle.firstLineHeadIndent = [self getHeadIndent];
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   // back to emitting
   _input->blockEmitting = NO;
 
-  if(preModificationRange.length == 0) {
-    // fix selection if only one line was possibly made a list and filled with a space
+  if (preModificationRange.length == 0) {
+    // fix selection if only one line was possibly made a list and filled with a
+    // space
     _input->textView.selectedRange = preModificationRange;
   } else {
     // in other cases, fix the selection with newly made offsets
-    _input->textView.selectedRange = NSMakeRange(preModificationRange.location, preModificationRange.length + offset);
+    _input->textView.selectedRange = NSMakeRange(
+        preModificationRange.location, preModificationRange.length + offset);
   }
 
   // also add typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
-  pStyle.headIndent = [self getHeadIndent];
-  pStyle.firstLineHeadIndent = [self getHeadIndent];
-  typingAttrs[NSParagraphStyleAttributeName] = pStyle;
-  _input->textView.typingAttributes = typingAttrs;
+  if (withTypingAttr) {
+    NSMutableDictionary *typingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    NSMutableParagraphStyle *pStyle =
+        [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+    pStyle.headIndent = [self getHeadIndent];
+    pStyle.firstLineHeadIndent = [self getHeadIndent];
+    typingAttrs[NSParagraphStyleAttributeName] = pStyle;
+    _input->textView.typingAttributes = typingAttrs;
+  }
 }
 
 // does pretty much the same as addAttributes
 - (void)addTypingAttributes {
-  [self addAttributes:_input->textView.selectedRange];
+  [self addAttributes:_input->textView.selectedRange withTypingAttr:YES];
 }
 
 - (void)removeAttributes:(NSRange)range {
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
 
-  for(NSValue *value in paragraphs) {
+  for (NSValue *value in paragraphs) {
     NSRange pRange = [value rangeValue];
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:pRange options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.headIndent = 0;
-        pStyle.firstLineHeadIndent = 0;
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:pRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.headIndent = 0;
+                  pStyle.firstLineHeadIndent = 0;
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   // also remove typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+  NSMutableDictionary *typingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  NSMutableParagraphStyle *pStyle =
+      [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
   pStyle.headIndent = 0;
   pStyle.firstLineHeadIndent = 0;
   typingAttrs[NSParagraphStyleAttributeName] = pStyle;
   _input->textView.typingAttributes = typingAttrs;
 }
 
-// needed for the sake of style conflicts, needs to do exactly the same as removeAttribtues
+// needed for the sake of style conflicts, needs to do exactly the same as
+// removeAttribtues
 - (void)removeTypingAttributes {
   [self removeAttributes:_input->textView.selectedRange];
 }
 
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text {
-  if([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
+  if ([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
     // backspace while the style is active
 
-    NSRange paragraphRange = [_input->textView.textStorage.string paragraphRangeForRange:_input->textView.selectedRange];
+    NSRange paragraphRange = [_input->textView.textStorage.string
+        paragraphRangeForRange:_input->textView.selectedRange];
 
-    if(NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
+    if (NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
       // a backspace on the very first input's line quote
-      // it doesn't run textVieDidChange so we need to manually remove attributes
+      // it doesn't run textVieDidChange so we need to manually remove
+      // attributes
       [self removeAttributes:paragraphRange];
       return YES;
-    } else if(range.location == paragraphRange.location - 1) {
-      // same case in other lines; here, the removed range location will be exactly 1 less than paragraph range location
+    } else if (range.location == paragraphRange.location - 1) {
+      // same case in other lines; here, the removed range location will be
+      // exactly 1 less than paragraph range location
       [self removeAttributes:paragraphRange];
       return YES;
     }
@@ -138,104 +186,106 @@
   return NO;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSParagraphStyle *pStyle = (NSParagraphStyle *)value;
-  return pStyle != nullptr && pStyle.headIndent == [self getHeadIndent] && pStyle.firstLineHeadIndent == [self getHeadIndent] && pStyle.textLists.count == 0;
+  return pStyle != nullptr && pStyle.headIndent == [self getHeadIndent] &&
+         pStyle.firstLineHeadIndent == [self getHeadIndent] &&
+         pStyle.textLists.count == 0;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input atIndex:range.location checkPrevious:YES
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
-}
-
-// gets ranges that aren't link, mention or inline code
-- (NSArray *)getProperColorRangesIn:(NSRange)range {
-  LinkStyle *linkStyle = _input->stylesDict[@([LinkStyle getStyleType])];
-  MentionStyle *mentionStyle = _input->stylesDict[@([MentionStyle getStyleType])];
-  InlineCodeStyle *codeStyle = _input->stylesDict[@([InlineCodeStyle getStyleType])];
-  
-  NSMutableArray *newRanges = [[NSMutableArray alloc] init];
-  int lastRangeLocation = range.location;
-  
-  for(int i = range.location; i < range.location + range.length; i++) {
-    NSRange currentRange = NSMakeRange(i, 1);
-    if([linkStyle detectStyle:currentRange] || [mentionStyle detectStyle:currentRange] || [codeStyle detectStyle:currentRange]) {
-      if(i - lastRangeLocation > 0) {
-        [newRanges addObject:[NSValue valueWithRange:NSMakeRange(lastRangeLocation, i - lastRangeLocation)]];
-      }
-      lastRangeLocation = i+1;
-    }
-  }
-  if(lastRangeLocation < range.location + range.length) {
-    [newRanges addObject:[NSValue valueWithRange:NSMakeRange(lastRangeLocation, range.location + range.length - lastRangeLocation)]];
-  }
-  
-  return newRanges;
+  return [OccurenceUtils all:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 // general checkup correcting blockquote color
-// since links, mentions and inline code affects coloring, the checkup gets done only outside of them
+// since links, mentions and inline code affects coloring, the checkup gets done
+// only outside of them
 - (void)manageBlockquoteColor {
-  if([[_input->config blockquoteColor] isEqualToColor:[_input->config primaryColor]]) {
+  if ([[_input->config blockquoteColor]
+          isEqualToColor:[_input->config primaryColor]]) {
     return;
   }
 
-  NSRange wholeRange = NSMakeRange(0, _input->textView.textStorage.string.length);
+  NSRange wholeRange =
+      NSMakeRange(0, _input->textView.textStorage.string.length);
 
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:wholeRange];
-  for(NSValue *pValue in paragraphs) {
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:wholeRange];
+  for (NSValue *pValue in paragraphs) {
     NSRange paragraphRange = [pValue rangeValue];
-    NSArray *properRanges = [self getProperColorRangesIn:paragraphRange];
+    NSArray *properRanges = [OccurenceUtils getRangesWithout:_stylesToExclude
+                                                   withInput:_input
+                                                     inRange:paragraphRange];
 
-    for(NSValue *value in properRanges) {
+    for (NSValue *value in properRanges) {
       NSRange currRange = [value rangeValue];
       BOOL selfDetected = [self detectStyle:currRange];
 
-      [_input->textView.textStorage enumerateAttribute:NSForegroundColorAttributeName inRange:currRange options:0
-        usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-          UIColor *newColor = nullptr;
-          BOOL colorApplied = [(UIColor *)value isEqualToColor:[_input->config blockquoteColor]];
-          
-          if(colorApplied && !selfDetected) {
-            newColor = [_input->config primaryColor];
-          } else if(!colorApplied && selfDetected) {
-            newColor = [_input->config blockquoteColor];
-          }
-      
-          if(newColor != nullptr) {
-            [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:newColor range:currRange];
-            [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:newColor range:currRange];
-            [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:newColor range:currRange];
-          }
-        }
-      ];
+      [_input->textView.textStorage
+          enumerateAttribute:NSForegroundColorAttributeName
+                     inRange:currRange
+                     options:0
+                  usingBlock:^(id _Nullable value, NSRange range,
+                               BOOL *_Nonnull stop) {
+                    UIColor *newColor = nullptr;
+                    BOOL colorApplied = [(UIColor *)value
+                        isEqualToColor:[_input->config blockquoteColor]];
+
+                    if (colorApplied && !selfDetected) {
+                      newColor = [_input->config primaryColor];
+                    } else if (!colorApplied && selfDetected) {
+                      newColor = [_input->config blockquoteColor];
+                    }
+
+                    if (newColor != nullptr) {
+                      [_input->textView.textStorage
+                          addAttribute:NSForegroundColorAttributeName
+                                 value:newColor
+                                 range:currRange];
+                      [_input->textView.textStorage
+                          addAttribute:NSUnderlineColorAttributeName
+                                 value:newColor
+                                 range:currRange];
+                      [_input->textView.textStorage
+                          addAttribute:NSStrikethroughColorAttributeName
+                                 value:newColor
+                                 range:currRange];
+                    }
+                  }];
     }
   }
 }
diff --git a/node_modules/react-native-enriched/ios/styles/BoldStyle.mm b/node_modules/react-native-enriched/ios/styles/BoldStyle.mm
index 2dd5073..aae3b40 100644
--- a/node_modules/react-native-enriched/ios/styles/BoldStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/BoldStyle.mm
@@ -1,13 +1,19 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 
 @implementation BoldStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return Bold; }
++ (StyleType)getStyleType {
+  return Bold;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -17,31 +23,39 @@
 
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [font setBold];
-        [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [_input->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [font setBold];
+                  [_input->textView.textStorage addAttribute:NSFontAttributeName
+                                                       value:newFont
+                                                       range:range];
+                }
+              }];
   [_input->textView.textStorage endEditing];
 }
 
 - (void)addTypingAttributes {
-  UIFont *currentFontAttr = (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  UIFont *currentFontAttr =
+      (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
     newTypingAttrs[NSFontAttributeName] = [currentFontAttr setBold];
     _input->textView.typingAttributes = newTypingAttrs;
   }
@@ -49,77 +63,97 @@
 
 - (void)removeAttributes:(NSRange)range {
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [font removeBold];
-        [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [_input->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [font removeBold];
+                  [_input->textView.textStorage addAttribute:NSFontAttributeName
+                                                       value:newFont
+                                                       range:range];
+                }
+              }];
   [_input->textView.textStorage endEditing];
 }
 
 - (void)removeTypingAttributes {
-  UIFont *currentFontAttr = (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  UIFont *currentFontAttr =
+      (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
     newTypingAttrs[NSFontAttributeName] = [currentFontAttr removeBold];
     _input->textView.typingAttributes = newTypingAttrs;
   }
 }
 
 - (BOOL)boldHeadingConflictsInRange:(NSRange)range type:(StyleType)type {
-  if(type == H1) {
-    if(![_input->config h1Bold]) { return NO; }
-  } else if(type == H2) {
-    if(![_input->config h2Bold]) { return NO; }
-  } else if(type == H3) {
-    if(![_input->config h3Bold]) { return NO; }
+  if (type == H1) {
+    if (![_input->config h1Bold]) {
+      return NO;
+    }
+  } else if (type == H2) {
+    if (![_input->config h2Bold]) {
+      return NO;
+    }
+  } else if (type == H3) {
+    if (![_input->config h3Bold]) {
+      return NO;
+    }
   }
 
   id<BaseStyleProtocol> headingStyle = _input->stylesDict[@(type)];
-  return range.length > 0
-    ? [headingStyle anyOccurence:range]
-    : [headingStyle detectStyle:range];
+  return range.length > 0 ? [headingStyle anyOccurence:range]
+                          : [headingStyle detectStyle:range];
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   UIFont *font = (UIFont *)value;
-  return font != nullptr && [font isBold] && ![self boldHeadingConflictsInRange:range type:H1] && ![self boldHeadingConflictsInRange:range type:H2] && ![self boldHeadingConflictsInRange:range type:H3];
+  return font != nullptr && [font isBold] &&
+         ![self boldHeadingConflictsInRange:range type:H1] &&
+         ![self boldHeadingConflictsInRange:range type:H2] &&
+         ![self boldHeadingConflictsInRange:range type:H3];
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:_input atIndex:range.location checkPrevious:NO
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:NO
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSFontAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSFontAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSFontAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSFontAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/CodeBlockStyle.mm b/node_modules/react-native-enriched/ios/styles/CodeBlockStyle.mm
new file mode 100644
index 0000000..1f5aa99
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/styles/CodeBlockStyle.mm
@@ -0,0 +1,304 @@
+#import "ColorExtension.h"
+#import "EnrichedTextInputView.h"
+#import "FontExtension.h"
+#import "OccurenceUtils.h"
+#import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
+#import "TextInsertionUtils.h"
+
+@implementation CodeBlockStyle {
+  EnrichedTextInputView *_input;
+  NSArray *_stylesToExclude;
+}
+
++ (StyleType)getStyleType {
+  return CodeBlock;
+}
+
++ (BOOL)isParagraphStyle {
+  return YES;
+}
+
+- (instancetype)initWithInput:(id)input {
+  self = [super init];
+  _input = (EnrichedTextInputView *)input;
+  _stylesToExclude = @[ @(InlineCode), @(Mention), @(Link) ];
+  return self;
+}
+
+- (void)applyStyle:(NSRange)range {
+  BOOL isStylePresent = [self detectStyle:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
+  } else {
+    isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
+  }
+}
+
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  NSTextList *codeBlockList =
+      [[NSTextList alloc] initWithMarkerFormat:@"codeblock" options:0];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
+  // if we fill empty lines with zero width spaces, we need to offset later
+  // ranges
+  NSInteger offset = 0;
+  NSRange preModificationRange = _input->textView.selectedRange;
+
+  // to not emit any space filling selection/text changes
+  _input->blockEmitting = YES;
+
+  for (NSValue *value in paragraphs) {
+    NSRange pRange = NSMakeRange([value rangeValue].location + offset,
+                                 [value rangeValue].length);
+    // length 0 with first line, length 1 and newline with some empty lines in
+    // the middle
+    if (pRange.length == 0 ||
+        (pRange.length == 1 &&
+         [[NSCharacterSet newlineCharacterSet]
+             characterIsMember:[_input->textView.textStorage.string
+                                   characterAtIndex:pRange.location]])) {
+      [TextInsertionUtils insertText:@"\u200B"
+                                  at:pRange.location
+                additionalAttributes:nullptr
+                               input:_input
+                       withSelection:NO];
+      pRange = NSMakeRange(pRange.location, pRange.length + 1);
+      offset += 1;
+    }
+
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:pRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[ codeBlockList ];
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
+  }
+
+  // back to emitting
+  _input->blockEmitting = NO;
+
+  if (preModificationRange.length == 0) {
+    // fix selection if only one line was possibly made a list and filled with a
+    // space
+    _input->textView.selectedRange = preModificationRange;
+  } else {
+    // in other cases, fix the selection with newly made offsets
+    _input->textView.selectedRange = NSMakeRange(
+        preModificationRange.location, preModificationRange.length + offset);
+  }
+
+  // also add typing attributes
+  if (withTypingAttr) {
+    NSMutableDictionary *typingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    NSMutableParagraphStyle *pStyle =
+        [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+    pStyle.textLists = @[ codeBlockList ];
+    typingAttrs[NSParagraphStyleAttributeName] = pStyle;
+
+    _input->textView.typingAttributes = typingAttrs;
+  }
+}
+
+- (void)addTypingAttributes {
+  [self addAttributes:_input->textView.selectedRange withTypingAttr:YES];
+}
+
+- (void)removeAttributes:(NSRange)range {
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
+
+  [_input->textView.textStorage beginEditing];
+
+  for (NSValue *value in paragraphs) {
+    NSRange pRange = [value rangeValue];
+
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:pRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[];
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
+  }
+
+  [_input->textView.textStorage endEditing];
+
+  // also remove typing attributes
+  NSMutableDictionary *typingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  NSMutableParagraphStyle *pStyle =
+      [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+  pStyle.textLists = @[];
+
+  typingAttrs[NSParagraphStyleAttributeName] = pStyle;
+
+  _input->textView.typingAttributes = typingAttrs;
+}
+
+- (void)removeTypingAttributes {
+  [self removeAttributes:_input->textView.selectedRange];
+}
+
+- (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text {
+  if ([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
+    // backspace while the style is active
+
+    NSRange paragraphRange = [_input->textView.textStorage.string
+        paragraphRangeForRange:_input->textView.selectedRange];
+
+    if (NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
+      // a backspace on the very first input's line quote
+      // it doesn't run textVieDidChange so we need to manually remove
+      // attributes
+      [self removeAttributes:paragraphRange];
+      return YES;
+    }
+  }
+  return NO;
+}
+
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
+  NSParagraphStyle *paragraph = (NSParagraphStyle *)value;
+  return paragraph != nullptr && paragraph.textLists.count == 1 &&
+         [paragraph.textLists.firstObject.markerFormat
+             isEqualToString:@"codeblock"];
+}
+
+- (BOOL)detectStyle:(NSRange)range {
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
+  } else {
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
+  }
+}
+
+- (BOOL)anyOccurence:(NSRange)range {
+  return [OccurenceUtils any:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
+}
+
+- (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
+  return [OccurenceUtils all:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
+}
+
+- (void)manageCodeBlockFontAndColor {
+  if ([[_input->config codeBlockFgColor]
+          isEqualToColor:[_input->config primaryColor]]) {
+    return;
+  }
+
+  NSRange wholeRange =
+      NSMakeRange(0, _input->textView.textStorage.string.length);
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:wholeRange];
+
+  for (NSValue *pValue in paragraphs) {
+    NSRange paragraphRange = [pValue rangeValue];
+    NSArray *properRanges = [OccurenceUtils getRangesWithout:_stylesToExclude
+                                                   withInput:_input
+                                                     inRange:paragraphRange];
+
+    for (NSValue *value in properRanges) {
+      NSRange currRange = [value rangeValue];
+      BOOL selfDetected = [self detectStyle:currRange];
+
+      [_input->textView.textStorage
+          enumerateAttribute:NSFontAttributeName
+                     inRange:currRange
+                     options:0
+                  usingBlock:^(id _Nullable value, NSRange range,
+                               BOOL *_Nonnull stop) {
+                    UIFont *currentFont = (UIFont *)value;
+                    UIFont *newFont = nullptr;
+
+                    BOOL isCodeFont = [[currentFont familyName]
+                        isEqualToString:[[_input->config monospacedFont]
+                                            familyName]];
+
+                    if (isCodeFont && !selfDetected) {
+                      newFont = [[[_input->config primaryFont]
+                          withFontTraits:currentFont]
+                          setSize:currentFont.pointSize];
+                    } else if (!isCodeFont && selfDetected) {
+                      newFont = [[[_input->config monospacedFont]
+                          withFontTraits:currentFont]
+                          setSize:currentFont.pointSize];
+                    }
+
+                    if (newFont != nullptr) {
+                      [_input->textView.textStorage
+                          addAttribute:NSFontAttributeName
+                                 value:newFont
+                                 range:range];
+                    }
+                  }];
+
+      [_input->textView.textStorage
+          enumerateAttribute:NSForegroundColorAttributeName
+                     inRange:currRange
+                     options:0
+                  usingBlock:^(id _Nullable value, NSRange range,
+                               BOOL *_Nonnull stop) {
+                    UIColor *newColor = nullptr;
+                    BOOL colorApplied = [(UIColor *)value
+                        isEqualToColor:[_input->config codeBlockFgColor]];
+
+                    if (colorApplied && !selfDetected) {
+                      newColor = [_input->config primaryColor];
+                    } else if (!colorApplied && selfDetected) {
+                      newColor = [_input->config codeBlockFgColor];
+                    }
+
+                    if (newColor != nullptr) {
+                      [_input->textView.textStorage
+                          addAttribute:NSForegroundColorAttributeName
+                                 value:newColor
+                                 range:range];
+                    }
+                  }];
+    }
+  }
+}
+
+@end
diff --git a/node_modules/react-native-enriched/ios/styles/H1Style.mm b/node_modules/react-native-enriched/ios/styles/H1Style.mm
index 9a8c4de..ca22c11 100644
--- a/node_modules/react-native-enriched/ios/styles/H1Style.mm
+++ b/node_modules/react-native-enriched/ios/styles/H1Style.mm
@@ -1,9 +1,16 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
+#import "StyleHeaders.h"
 
 @implementation H1Style
-+ (StyleType)getStyleType { return H1; }
-- (CGFloat)getHeadingFontSize { return [((EnrichedTextInputView *)input)->config h1FontSize]; }
++ (StyleType)getStyleType {
+  return H1;
+}
++ (BOOL)isParagraphStyle {
+  return YES;
+}
+- (CGFloat)getHeadingFontSize {
+  return [((EnrichedTextInputView *)input)->config h1FontSize];
+}
 - (BOOL)isHeadingBold {
   return [((EnrichedTextInputView *)input)->config h1Bold];
 }
diff --git a/node_modules/react-native-enriched/ios/styles/H2Style.mm b/node_modules/react-native-enriched/ios/styles/H2Style.mm
index 1913c2f..a943b96 100644
--- a/node_modules/react-native-enriched/ios/styles/H2Style.mm
+++ b/node_modules/react-native-enriched/ios/styles/H2Style.mm
@@ -1,9 +1,16 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
+#import "StyleHeaders.h"
 
 @implementation H2Style
-+ (StyleType)getStyleType { return H2; }
-- (CGFloat)getHeadingFontSize { return [((EnrichedTextInputView *)input)->config h2FontSize]; }
++ (StyleType)getStyleType {
+  return H2;
+}
++ (BOOL)isParagraphStyle {
+  return YES;
+}
+- (CGFloat)getHeadingFontSize {
+  return [((EnrichedTextInputView *)input)->config h2FontSize];
+}
 - (BOOL)isHeadingBold {
   return [((EnrichedTextInputView *)input)->config h2Bold];
 }
diff --git a/node_modules/react-native-enriched/ios/styles/H3Style.mm b/node_modules/react-native-enriched/ios/styles/H3Style.mm
index f7b55bc..e6c5765 100644
--- a/node_modules/react-native-enriched/ios/styles/H3Style.mm
+++ b/node_modules/react-native-enriched/ios/styles/H3Style.mm
@@ -1,9 +1,16 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
+#import "StyleHeaders.h"
 
 @implementation H3Style
-+ (StyleType)getStyleType { return H3; }
-- (CGFloat)getHeadingFontSize { return [((EnrichedTextInputView *)input)->config h3FontSize]; }
++ (StyleType)getStyleType {
+  return H3;
+}
++ (BOOL)isParagraphStyle {
+  return YES;
+}
+- (CGFloat)getHeadingFontSize {
+  return [((EnrichedTextInputView *)input)->config h3FontSize];
+}
 - (BOOL)isHeadingBold {
   return [((EnrichedTextInputView *)input)->config h3Bold];
 }
diff --git a/node_modules/react-native-enriched/ios/styles/HeadingStyleBase.mm b/node_modules/react-native-enriched/ios/styles/HeadingStyleBase.mm
index 4d3beac..6e86672 100644
--- a/node_modules/react-native-enriched/ios/styles/HeadingStyleBase.mm
+++ b/node_modules/react-native-enriched/ios/styles/HeadingStyleBase.mm
@@ -1,15 +1,21 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
 
 @implementation HeadingStyleBase
 
 // mock values since H1/2/3Style classes anyway are used
-+ (StyleType)getStyleType { return None; }
-- (CGFloat)getHeadingFontSize { return 0; }
-- (BOOL)isHeadingBold { return false; }
++ (StyleType)getStyleType {
+  return None;
+}
+- (CGFloat)getHeadingFontSize {
+  return 0;
+}
+- (BOOL)isHeadingBold {
+  return false;
+}
 
 - (EnrichedTextInputView *)typedInput {
   return (EnrichedTextInputView *)input;
@@ -25,41 +31,54 @@
 // but if the paragraph is empty it still is of length 0
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
 // the range will already be the proper full paragraph/s range
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   [[self typedInput]->textView.textStorage beginEditing];
-  [[self typedInput]->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [font setSize:[self getHeadingFontSize]];
-        if([self isHeadingBold]) {
-          newFont = [newFont setBold];
-        }
-        [[self typedInput]->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [[self typedInput]->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [font setSize:[self getHeadingFontSize]];
+                  if ([self isHeadingBold]) {
+                    newFont = [newFont setBold];
+                  }
+                  [[self typedInput]->textView.textStorage
+                      addAttribute:NSFontAttributeName
+                             value:newFont
+                             range:range];
+                }
+              }];
   [[self typedInput]->textView.textStorage endEditing];
 
   // also toggle typing attributes
-  [self addTypingAttributes];
+  if (withTypingAttr) {
+    [self addTypingAttributes];
+  }
 }
 
-// will always be called on empty paragraphs so only typing attributes can be changed
+// will always be called on empty paragraphs so only typing attributes can be
+// changed
 - (void)addTypingAttributes {
-  UIFont *currentFontAttr = (UIFont *)[self typedInput]->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [[self typedInput]->textView.typingAttributes mutableCopy];
+  UIFont *currentFontAttr =
+      (UIFont *)[self typedInput]
+          ->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [[self typedInput]->textView.typingAttributes mutableCopy];
     UIFont *newFont = [currentFontAttr setSize:[self getHeadingFontSize]];
-    if([self isHeadingBold]) {
+    if ([self isHeadingBold]) {
       newFont = [newFont setBold];
     }
     newTypingAttrs[NSFontAttributeName] = newFont;
@@ -69,28 +88,41 @@
 
 // we need to remove the style from the whole paragraph
 - (void)removeAttributes:(NSRange)range {
-  NSRange paragraphRange = [[self typedInput]->textView.textStorage.string paragraphRangeForRange:range];
+  NSRange paragraphRange = [[self typedInput]->textView.textStorage.string
+      paragraphRangeForRange:range];
 
   [[self typedInput]->textView.textStorage beginEditing];
-  [[self typedInput]->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:paragraphRange options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      if([self styleCondition:value :range]) {
-        UIFont *newFont = [(UIFont *)value setSize:[[[self typedInput]->config primaryFontSize] floatValue]];
-        if([self isHeadingBold]) {
-          newFont = [newFont removeBold];
-        }
-        [[self typedInput]->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [[self typedInput]->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:paragraphRange
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                if ([self styleCondition:value:range]) {
+                  UIFont *newFont = [(UIFont *)value
+                      setSize:[[[self typedInput]->config primaryFontSize]
+                                  floatValue]];
+                  if ([self isHeadingBold]) {
+                    newFont = [newFont removeBold];
+                  }
+                  [[self typedInput]->textView.textStorage
+                      addAttribute:NSFontAttributeName
+                             value:newFont
+                             range:range];
+                }
+              }];
   [[self typedInput]->textView.textStorage endEditing];
 
   // typing attributes still need to be removed
-  UIFont *currentFontAttr = (UIFont *)[self typedInput]->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [[self typedInput]->textView.typingAttributes mutableCopy];
-    UIFont *newFont = [currentFontAttr setSize:[[[self typedInput]->config primaryFontSize] floatValue]];
-    if([self isHeadingBold]) {
+  UIFont *currentFontAttr =
+      (UIFont *)[self typedInput]
+          ->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [[self typedInput]->textView.typingAttributes mutableCopy];
+    UIFont *newFont = [currentFontAttr
+        setSize:[[[self typedInput]->config primaryFontSize] floatValue]];
+    if ([self isHeadingBold]) {
       newFont = [newFont removeBold];
     }
     newTypingAttrs[NSFontAttributeName] = newFont;
@@ -99,58 +131,67 @@
 }
 
 - (void)removeTypingAttributes {
-  // all the heading still needs to be removed because this function may be called in conflicting styles logic
-  // typing attributes already get removed in there as well
+  // all the heading still needs to be removed because this function may be
+  // called in conflicting styles logic typing attributes already get removed in
+  // there as well
   [self removeAttributes:[self typedInput]->textView.selectedRange];
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   UIFont *font = (UIFont *)value;
   return font != nullptr && font.pointSize == [self getHeadingFontSize];
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:[self typedInput] inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:[self typedInput]
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:[self typedInput] atIndex:range.location checkPrevious:YES
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:[self typedInput]
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSFontAttributeName withInput:[self typedInput] inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSFontAttributeName
+                   withInput:[self typedInput]
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSFontAttributeName withInput:[self typedInput] inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSFontAttributeName
+                   withInput:[self typedInput]
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 // used to make sure headings dont persist after a newline is placed
 - (BOOL)handleNewlinesInRange:(NSRange)range replacementText:(NSString *)text {
   // in a heading and a new text ends with a newline
-  if(
-    [self detectStyle:[self typedInput]->textView.selectedRange] &&
-    text.length > 0 &&
-    [[NSCharacterSet newlineCharacterSet] characterIsMember: [text characterAtIndex:text.length-1]]
-  ) {
+  if ([self detectStyle:[self typedInput]->textView.selectedRange] &&
+      text.length > 0 &&
+      [[NSCharacterSet newlineCharacterSet]
+          characterIsMember:[text characterAtIndex:text.length - 1]]) {
     // do the replacement manually
-    [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:[self typedInput] withSelection:YES];
+    [TextInsertionUtils replaceText:text
+                                 at:range
+               additionalAttributes:nullptr
+                              input:[self typedInput]
+                      withSelection:YES];
     // remove the attribtues at the new selection
     [self removeAttributes:[self typedInput]->textView.selectedRange];
     return YES;
@@ -158,19 +199,23 @@
   return NO;
 }
 
-// backspacing a line after a heading "into" a heading will not result in the text attaining heading attributes
-// so, we do it manually
+// backspacing a line after a heading "into" a heading will not result in the
+// text attaining heading attributes so, we do it manually
 - (void)handleImproperHeadings {
-  NSArray *occurences = [self findAllOccurences:NSMakeRange(0, [self typedInput]->textView.textStorage.string.length)];
-  for(StylePair *pair in occurences) {
+  NSArray *occurences = [self
+      findAllOccurences:NSMakeRange(0,
+                                    [self typedInput]
+                                        ->textView.textStorage.string.length)];
+  for (StylePair *pair in occurences) {
     NSRange occurenceRange = [pair.rangeValue rangeValue];
-    NSRange paragraphRange = [[self typedInput]->textView.textStorage.string paragraphRangeForRange:occurenceRange];
-    if(!NSEqualRanges(occurenceRange, paragraphRange)) {
-      // we have a heading but it does not span its whole paragraph - let's fix it
-      [self addAttributes:paragraphRange];
+    NSRange paragraphRange = [[self typedInput]->textView.textStorage.string
+        paragraphRangeForRange:occurenceRange];
+    if (!NSEqualRanges(occurenceRange, paragraphRange)) {
+      // we have a heading but it does not span its whole paragraph - let's fix
+      // it
+      [self addAttributes:paragraphRange withTypingAttr:NO];
     }
   }
 }
 
 @end
-
diff --git a/node_modules/react-native-enriched/ios/styles/ImageStyle.mm b/node_modules/react-native-enriched/ios/styles/ImageStyle.mm
new file mode 100644
index 0000000..8606fa8
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/styles/ImageStyle.mm
@@ -0,0 +1,160 @@
+#import "EnrichedTextInputView.h"
+#import "ImageAttachment.h"
+#import "MediaAttachment.h"
+#import "OccurenceUtils.h"
+#import "StyleHeaders.h"
+#import "TextInsertionUtils.h"
+
+// custom NSAttributedStringKey to differentiate the image
+static NSString *const ImageAttributeName = @"ImageAttributeName";
+
+@implementation ImageStyle {
+  EnrichedTextInputView *_input;
+}
+
++ (StyleType)getStyleType {
+  return Image;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
+
+- (instancetype)initWithInput:(id)input {
+  self = [super init];
+  _input = (EnrichedTextInputView *)input;
+  return self;
+}
+
+- (void)applyStyle:(NSRange)range {
+  // no-op for image
+}
+
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  // no-op for image
+}
+
+- (void)addTypingAttributes {
+  // no-op for image
+}
+
+- (void)removeAttributes:(NSRange)range {
+  [_input->textView.textStorage beginEditing];
+  [_input->textView.textStorage removeAttribute:ImageAttributeName range:range];
+  [_input->textView.textStorage removeAttribute:NSAttachmentAttributeName
+                                          range:range];
+  [_input->textView.textStorage endEditing];
+}
+
+- (void)removeTypingAttributes {
+  NSMutableDictionary *currentAttributes =
+      [_input->textView.typingAttributes mutableCopy];
+  [currentAttributes removeObjectForKey:ImageAttributeName];
+  [currentAttributes removeObjectForKey:NSAttachmentAttributeName];
+  _input->textView.typingAttributes = currentAttributes;
+}
+
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
+  return [value isKindOfClass:[ImageData class]];
+}
+
+- (BOOL)anyOccurence:(NSRange)range {
+  return [OccurenceUtils any:ImageAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
+}
+
+- (BOOL)detectStyle:(NSRange)range {
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:ImageAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
+  } else {
+    return [OccurenceUtils detect:ImageAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
+  }
+}
+
+- (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
+  return [OccurenceUtils all:ImageAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
+}
+
+- (ImageData *)getImageDataAt:(NSUInteger)location {
+  NSRange imageRange = NSMakeRange(0, 0);
+  NSRange inputRange = NSMakeRange(0, _input->textView.textStorage.length);
+
+  // don't search at the very end of input
+  NSUInteger searchLocation = location;
+  if (searchLocation == _input->textView.textStorage.length) {
+    return nullptr;
+  }
+
+  ImageData *imageData =
+      [_input->textView.textStorage attribute:ImageAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&imageRange
+                                      inRange:inputRange];
+
+  return imageData;
+}
+
+- (void)addImageAtRange:(NSRange)range
+              imageData:(ImageData *)imageData
+          withSelection:(BOOL)withSelection {
+  if (!imageData)
+    return;
+
+  ImageAttachment *attachment =
+      [[ImageAttachment alloc] initWithImageData:imageData];
+  attachment.delegate = _input;
+
+  NSDictionary *attributes =
+      @{NSAttachmentAttributeName : attachment, ImageAttributeName : imageData};
+
+  // Use the Object Replacement Character for Image.
+  // This tells TextKit "something non-text goes here".
+  NSString *placeholderChar = @"\uFFFC";
+
+  if (range.length == 0) {
+    [TextInsertionUtils insertText:placeholderChar
+                                at:range.location
+              additionalAttributes:attributes
+                             input:_input
+                     withSelection:withSelection];
+  } else {
+    [TextInsertionUtils replaceText:placeholderChar
+                                 at:range
+               additionalAttributes:attributes
+                              input:_input
+                      withSelection:withSelection];
+  }
+}
+
+- (void)addImage:(NSString *)uri width:(CGFloat)width height:(CGFloat)height {
+  ImageData *data = [[ImageData alloc] init];
+  data.uri = uri;
+  data.width = width;
+  data.height = height;
+
+  [self addImageAtRange:_input->textView.selectedRange
+              imageData:data
+          withSelection:YES];
+}
+
+@end
diff --git a/node_modules/react-native-enriched/ios/styles/InlineCodeStyle.mm b/node_modules/react-native-enriched/ios/styles/InlineCodeStyle.mm
index 94d8ad0..3bc7d0a 100644
--- a/node_modules/react-native-enriched/ios/styles/InlineCodeStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/InlineCodeStyle.mm
@@ -1,15 +1,21 @@
-#import "StyleHeaders.h"
+#import "ColorExtension.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
 #import "ParagraphsUtils.h"
-#import "ColorExtension.h"
+#import "StyleHeaders.h"
 
 @implementation InlineCodeStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return InlineCode; }
++ (StyleType)getStyleType {
+  return InlineCode;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -19,48 +25,76 @@
 
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   // we don't want to apply inline code to newline characters, it looks bad
-  NSArray *nonNewlineRanges = [ParagraphsUtils getNonNewlineRangesIn:_input->textView range:range];
+  NSArray *nonNewlineRanges =
+      [ParagraphsUtils getNonNewlineRangesIn:_input->textView range:range];
 
-  for(NSValue *value in nonNewlineRanges) {
+  for (NSValue *value in nonNewlineRanges) {
     NSRange currentRange = [value rangeValue];
     [_input->textView.textStorage beginEditing];
 
-    [_input->textView.textStorage addAttribute:NSBackgroundColorAttributeName value:[[_input->config inlineCodeBgColor] colorWithAlphaIfNotTransparent:0.4] range:currentRange];
-    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config inlineCodeFgColor] range:currentRange];
-    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config inlineCodeFgColor] range:currentRange];
-    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config inlineCodeFgColor] range:currentRange];
-    [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:currentRange options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        UIFont *font = (UIFont *)value;
-        if(font != nullptr) {
-          UIFont *newFont = [[[_input->config monospacedFont] withFontTraits:font] setSize:font.pointSize];
-          [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-        }
-      }
-    ];
+    [_input->textView.textStorage
+        addAttribute:NSBackgroundColorAttributeName
+               value:[[_input->config inlineCodeBgColor]
+                         colorWithAlphaIfNotTransparent:0.4]
+               range:currentRange];
+    [_input->textView.textStorage
+        addAttribute:NSForegroundColorAttributeName
+               value:[_input->config inlineCodeFgColor]
+               range:currentRange];
+    [_input->textView.textStorage
+        addAttribute:NSUnderlineColorAttributeName
+               value:[_input->config inlineCodeFgColor]
+               range:currentRange];
+    [_input->textView.textStorage
+        addAttribute:NSStrikethroughColorAttributeName
+               value:[_input->config inlineCodeFgColor]
+               range:currentRange];
+    [_input->textView.textStorage
+        enumerateAttribute:NSFontAttributeName
+                   inRange:currentRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  UIFont *font = (UIFont *)value;
+                  if (font != nullptr) {
+                    UIFont *newFont = [[[_input->config monospacedFont]
+                        withFontTraits:font] setSize:font.pointSize];
+                    [_input->textView.textStorage
+                        addAttribute:NSFontAttributeName
+                               value:newFont
+                               range:range];
+                  }
+                }];
 
     [_input->textView.textStorage endEditing];
   }
 }
 
 - (void)addTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  newTypingAttrs[NSBackgroundColorAttributeName] = [[_input->config inlineCodeBgColor] colorWithAlphaIfNotTransparent:0.4];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config inlineCodeFgColor];
-  newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config inlineCodeFgColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config inlineCodeFgColor];
-  UIFont* currentFont = (UIFont *)newTypingAttrs[NSFontAttributeName];
-  if(currentFont != nullptr) {
-    newTypingAttrs[NSFontAttributeName] = [[[_input->config monospacedFont] withFontTraits:currentFont] setSize:currentFont.pointSize];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  newTypingAttrs[NSBackgroundColorAttributeName] =
+      [[_input->config inlineCodeBgColor] colorWithAlphaIfNotTransparent:0.4];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config inlineCodeFgColor];
+  newTypingAttrs[NSUnderlineColorAttributeName] =
+      [_input->config inlineCodeFgColor];
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config inlineCodeFgColor];
+  UIFont *currentFont = (UIFont *)newTypingAttrs[NSFontAttributeName];
+  if (currentFont != nullptr) {
+    newTypingAttrs[NSFontAttributeName] = [[[_input->config monospacedFont]
+        withFontTraits:currentFont] setSize:currentFont.pointSize];
   }
   _input->textView.typingAttributes = newTypingAttrs;
 }
@@ -68,100 +102,131 @@
 - (void)removeAttributes:(NSRange)range {
   [_input->textView.textStorage beginEditing];
 
-  [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName range:range];
-  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config primaryColor] range:range];
-  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config primaryColor] range:range];
-  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config primaryColor] range:range];
-  [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [[[_input->config primaryFont] withFontTraits:font] setSize:font.pointSize];
-        [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName
+                                          range:range];
+  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:range];
+  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:range];
+  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:range];
+  [_input->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [[[_input->config primaryFont]
+                      withFontTraits:font] setSize:font.pointSize];
+                  [_input->textView.textStorage addAttribute:NSFontAttributeName
+                                                       value:newFont
+                                                       range:range];
+                }
+              }];
 
   [_input->textView.textStorage endEditing];
 }
 
 - (void)removeTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
   [newTypingAttrs removeObjectForKey:NSBackgroundColorAttributeName];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config primaryColor];
   newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
-  UIFont* currentFont = (UIFont *)newTypingAttrs[NSFontAttributeName];
-  if(currentFont != nullptr) {
-    newTypingAttrs[NSFontAttributeName] = [[[_input->config primaryFont] withFontTraits:currentFont] setSize:currentFont.pointSize];
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config primaryColor];
+  UIFont *currentFont = (UIFont *)newTypingAttrs[NSFontAttributeName];
+  if (currentFont != nullptr) {
+    newTypingAttrs[NSFontAttributeName] = [[[_input->config primaryFont]
+        withFontTraits:currentFont] setSize:currentFont.pointSize];
   }
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
 // making sure no newlines get inline code style, it looks bad
 - (void)handleNewlines {
-  for(int i = 0; i < _input->textView.textStorage.string.length; i++) {
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:[_input->textView.textStorage.string characterAtIndex:i]]) {
+  for (int i = 0; i < _input->textView.textStorage.string.length; i++) {
+    if ([[NSCharacterSet newlineCharacterSet]
+            characterIsMember:[_input->textView.textStorage.string
+                                  characterAtIndex:i]]) {
       NSRange mockRange = NSMakeRange(0, 0);
-      // can't use detect style because it intentionally doesn't take newlines into consideration
-      UIColor *bgColor = [_input->textView.textStorage attribute:NSBackgroundColorAttributeName atIndex:i effectiveRange:&mockRange];
-      if([self styleCondition:bgColor :NSMakeRange(i, 1)]) {
+      // can't use detect style because it intentionally doesn't take newlines
+      // into consideration
+      UIColor *bgColor =
+          [_input->textView.textStorage attribute:NSBackgroundColorAttributeName
+                                          atIndex:i
+                                   effectiveRange:&mockRange];
+      if ([self styleCondition:bgColor:NSMakeRange(i, 1)]) {
         [self removeAttributes:NSMakeRange(i, 1)];
       }
     }
   }
 }
 
-// emojis don't retain monospace font attribute so we check for the background color if there is no mention
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+// emojis don't retain monospace font attribute so we check for the background
+// color if there is no mention
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   UIColor *bgColor = (UIColor *)value;
   MentionStyle *mStyle = _input->stylesDict[@([MentionStyle getStyleType])];
   return bgColor != nullptr && mStyle != nullptr && ![mStyle detectStyle:range];
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
+  if (range.length >= 1) {
     // detect only in non-newline characters
-    NSArray *nonNewlineRanges = [ParagraphsUtils getNonNewlineRangesIn:_input->textView range:range];
-    if(nonNewlineRanges.count == 0) {
+    NSArray *nonNewlineRanges =
+        [ParagraphsUtils getNonNewlineRangesIn:_input->textView range:range];
+    if (nonNewlineRanges.count == 0) {
       return NO;
     }
 
     BOOL detected = YES;
-    for(NSValue *value in nonNewlineRanges) {
+    for (NSValue *value in nonNewlineRanges) {
       NSRange currentRange = [value rangeValue];
-      BOOL currentDetected = [OccurenceUtils detect:NSBackgroundColorAttributeName withInput:_input inRange:currentRange
-        withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-          return [self styleCondition:value :range];
-        }
-      ];
+      BOOL currentDetected =
+          [OccurenceUtils detect:NSBackgroundColorAttributeName
+                       withInput:_input
+                         inRange:currentRange
+                   withCondition:^BOOL(id _Nullable value, NSRange range) {
+                     return [self styleCondition:value:range];
+                   }];
       detected = detected && currentDetected;
     }
 
     return detected;
   } else {
-    return [OccurenceUtils detect:NSBackgroundColorAttributeName withInput:_input atIndex:range.location checkPrevious:NO
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSBackgroundColorAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:NO
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSBackgroundColorAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSBackgroundColorAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSBackgroundColorAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSBackgroundColorAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/ItalicStyle.mm b/node_modules/react-native-enriched/ios/styles/ItalicStyle.mm
index 6ec4deb..82ddf70 100644
--- a/node_modules/react-native-enriched/ios/styles/ItalicStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/ItalicStyle.mm
@@ -1,13 +1,19 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 
 @implementation ItalicStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return Italic; }
++ (StyleType)getStyleType {
+  return Italic;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -17,31 +23,39 @@
 
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [font setItalic];
-        [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [_input->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [font setItalic];
+                  [_input->textView.textStorage addAttribute:NSFontAttributeName
+                                                       value:newFont
+                                                       range:range];
+                }
+              }];
   [_input->textView.textStorage endEditing];
 }
 
 - (void)addTypingAttributes {
-  UIFont *currentFontAttr = (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  UIFont *currentFontAttr =
+      (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
     newTypingAttrs[NSFontAttributeName] = [currentFontAttr setItalic];
     _input->textView.typingAttributes = newTypingAttrs;
   }
@@ -49,62 +63,74 @@
 
 - (void)removeAttributes:(NSRange)range {
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage enumerateAttribute:NSFontAttributeName inRange:range options:0
-    usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      UIFont *font = (UIFont *)value;
-      if(font != nullptr) {
-        UIFont *newFont = [font removeItalic];
-        [_input->textView.textStorage addAttribute:NSFontAttributeName value:newFont range:range];
-      }
-    }
-  ];
+  [_input->textView.textStorage
+      enumerateAttribute:NSFontAttributeName
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                UIFont *font = (UIFont *)value;
+                if (font != nullptr) {
+                  UIFont *newFont = [font removeItalic];
+                  [_input->textView.textStorage addAttribute:NSFontAttributeName
+                                                       value:newFont
+                                                       range:range];
+                }
+              }];
   [_input->textView.textStorage endEditing];
 }
 
 - (void)removeTypingAttributes {
-  UIFont *currentFontAttr = (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
-  if(currentFontAttr != nullptr) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  UIFont *currentFontAttr =
+      (UIFont *)_input->textView.typingAttributes[NSFontAttributeName];
+  if (currentFontAttr != nullptr) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
     newTypingAttrs[NSFontAttributeName] = [currentFontAttr removeItalic];
     _input->textView.typingAttributes = newTypingAttrs;
   }
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   UIFont *font = (UIFont *)value;
   return font != nullptr && [font isItalic];
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSFontAttributeName withInput:_input atIndex:range.location checkPrevious:NO
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSFontAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:NO
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSFontAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSFontAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSFontAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSFontAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/LinkStyle.mm b/node_modules/react-native-enriched/ios/styles/LinkStyle.mm
index 69e8a2d..8270ffb 100644
--- a/node_modules/react-native-enriched/ios/styles/LinkStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/LinkStyle.mm
@@ -1,19 +1,27 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
 #import "UIView+React.h"
 #import "WordsUtils.h"
 
-// custom NSAttributedStringKeys to differentiate manually added and automatically detected links
+// custom NSAttributedStringKeys to differentiate manually added and
+// automatically detected links
 static NSString *const ManualLinkAttributeName = @"ManualLinkAttributeName";
-static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName";
+static NSString *const AutomaticLinkAttributeName =
+    @"AutomaticLinkAttributeName";
 
 @implementation LinkStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return Link; }
++ (StyleType)getStyleType {
+  return Link;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -25,7 +33,7 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
   // no-op for links
 }
 
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   // no-op for links
 }
 
@@ -37,25 +45,39 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 - (void)removeAttributes:(NSRange)range {
   NSArray<StylePair *> *links = [self findAllOccurences:range];
   [_input->textView.textStorage beginEditing];
-  for(StylePair *pair in links) {
-    NSRange linkRange = [self getFullLinkRangeAt:[pair.rangeValue rangeValue].location];
-    [_input->textView.textStorage removeAttribute:ManualLinkAttributeName range:linkRange];
-    [_input->textView.textStorage removeAttribute:AutomaticLinkAttributeName range:linkRange];
-    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config primaryColor] range:linkRange];
-    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config primaryColor] range:linkRange];
-    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config primaryColor] range:linkRange];
-    if([_input->config linkDecorationLine] == DecorationUnderline) {
-      [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName range:linkRange];
+  for (StylePair *pair in links) {
+    NSRange linkRange =
+        [self getFullLinkRangeAt:[pair.rangeValue rangeValue].location];
+    [_input->textView.textStorage removeAttribute:ManualLinkAttributeName
+                                            range:linkRange];
+    [_input->textView.textStorage removeAttribute:AutomaticLinkAttributeName
+                                            range:linkRange];
+    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:linkRange];
+    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:linkRange];
+    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:linkRange];
+    if ([_input->config linkDecorationLine] == DecorationUnderline) {
+      [_input->textView.textStorage
+          removeAttribute:NSUnderlineStyleAttributeName
+                    range:linkRange];
     }
   }
   [_input->textView.textStorage endEditing];
 
   // adjust typing attributes as well
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config primaryColor];
   newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
-  if([_input->config linkDecorationLine] == DecorationUnderline) {
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config primaryColor];
+  if ([_input->config linkDecorationLine] == DecorationUnderline) {
     [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
   }
   _input->textView.typingAttributes = newTypingAttrs;
@@ -63,41 +85,56 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 
 // used for conflicts, we have to remove the whole link
 - (void)removeTypingAttributes {
-  NSRange linkRange = [self getFullLinkRangeAt:_input->textView.selectedRange.location];
+  NSRange linkRange =
+      [self getFullLinkRangeAt:_input->textView.selectedRange.location];
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage removeAttribute:ManualLinkAttributeName range:linkRange];
-  [_input->textView.textStorage removeAttribute:AutomaticLinkAttributeName range:linkRange];
-  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config primaryColor] range:linkRange];
-  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config primaryColor] range:linkRange];
-  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config primaryColor] range:linkRange];
-  if([_input->config linkDecorationLine] == DecorationUnderline) {
-    [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName range:linkRange];
+  [_input->textView.textStorage removeAttribute:ManualLinkAttributeName
+                                          range:linkRange];
+  [_input->textView.textStorage removeAttribute:AutomaticLinkAttributeName
+                                          range:linkRange];
+  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:linkRange];
+  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:linkRange];
+  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:linkRange];
+  if ([_input->config linkDecorationLine] == DecorationUnderline) {
+    [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName
+                                            range:linkRange];
   }
   [_input->textView.textStorage endEditing];
 
   // adjust typing attributes as well
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config primaryColor];
   newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
-  if([_input->config linkDecorationLine] == DecorationUnderline) {
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config primaryColor];
+  if ([_input->config linkDecorationLine] == DecorationUnderline) {
     [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
   }
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSString *linkValue = (NSString *)value;
   return linkValue != nullptr;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    BOOL onlyLinks = [OccurenceUtils detectMultiple:@[ManualLinkAttributeName, AutomaticLinkAttributeName] withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    BOOL onlyLinks = [OccurenceUtils
+        detectMultiple:@[ ManualLinkAttributeName, AutomaticLinkAttributeName ]
+             withInput:_input
+               inRange:range
+         withCondition:^BOOL(id _Nullable value, NSRange range) {
+           return [self styleCondition:value:range];
+         }];
     return onlyLinks ? [self isSingleLinkIn:range] : NO;
   } else {
     return [self getLinkDataAt:range.location] != nullptr;
@@ -105,64 +142,87 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils anyMultiple:@[ManualLinkAttributeName, AutomaticLinkAttributeName] withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils
+        anyMultiple:@[ ManualLinkAttributeName, AutomaticLinkAttributeName ]
+          withInput:_input
+            inRange:range
+      withCondition:^BOOL(id _Nullable value, NSRange range) {
+        return [self styleCondition:value:range];
+      }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils allMultiple:@[ManualLinkAttributeName, AutomaticLinkAttributeName] withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils
+        allMultiple:@[ ManualLinkAttributeName, AutomaticLinkAttributeName ]
+          withInput:_input
+            inRange:range
+      withCondition:^BOOL(id _Nullable value, NSRange range) {
+        return [self styleCondition:value:range];
+      }];
 }
 
 // MARK: - Public non-standard methods
 
-- (void)addLink:(NSString*)text url:(NSString*)url range:(NSRange)range manual:(BOOL)manual {
-  NSString *currentText = [_input->textView.textStorage.string substringWithRange:range];
+- (void)addLink:(NSString *)text
+              url:(NSString *)url
+            range:(NSRange)range
+           manual:(BOOL)manual
+    withSelection:(BOOL)withSelection {
+  NSString *currentText =
+      [_input->textView.textStorage.string substringWithRange:range];
 
-  NSMutableDictionary<NSAttributedStringKey, id> *newAttrs = [[NSMutableDictionary<NSAttributedStringKey, id> alloc] init];
+  NSMutableDictionary<NSAttributedStringKey, id> *newAttrs =
+      [[NSMutableDictionary<NSAttributedStringKey, id> alloc] init];
   newAttrs[NSForegroundColorAttributeName] = [_input->config linkColor];
   newAttrs[NSUnderlineColorAttributeName] = [_input->config linkColor];
   newAttrs[NSStrikethroughColorAttributeName] = [_input->config linkColor];
-  if([_input->config linkDecorationLine] == DecorationUnderline) {
+  if ([_input->config linkDecorationLine] == DecorationUnderline) {
     newAttrs[NSUnderlineStyleAttributeName] = @(NSUnderlineStyleSingle);
   }
-  if(manual) {
+  if (manual) {
     newAttrs[ManualLinkAttributeName] = [url copy];
   } else {
     newAttrs[AutomaticLinkAttributeName] = [url copy];
   }
 
-  if(range.length == 0) {
+  if (range.length == 0) {
     // insert link
-    [TextInsertionUtils insertText:text at:range.location additionalAttributes:newAttrs input:_input withSelection:YES];
-  } else if([currentText isEqualToString:text]) {
+    [TextInsertionUtils insertText:text
+                                at:range.location
+              additionalAttributes:newAttrs
+                             input:_input
+                     withSelection:withSelection];
+  } else if ([currentText isEqualToString:text]) {
     // apply link attributes
     [_input->textView.textStorage addAttributes:newAttrs range:range];
-    // TextInsertionUtils take care of the selection but here we have to manually set it behind the link
-    // ONLY with manual links, automatic ones don't need the selection fix
-    if(manual) {
+    // TextInsertionUtils take care of the selection but here we have to
+    // manually set it behind the link ONLY with manual links, automatic ones
+    // don't need the selection fix
+    if (manual && withSelection) {
       [_input->textView reactFocus];
-      _input->textView.selectedRange = NSMakeRange(range.location + text.length, 0);
+      _input->textView.selectedRange =
+          NSMakeRange(range.location + text.length, 0);
     }
   } else {
     // replace text with link
-    [TextInsertionUtils replaceText:text at:range additionalAttributes:newAttrs input:_input withSelection:YES];
+    [TextInsertionUtils replaceText:text
+                                 at:range
+               additionalAttributes:newAttrs
+                              input:_input
+                      withSelection:withSelection];
   }
 
   // mandatory connected links check
-  NSDictionary *currentWord = [WordsUtils getCurrentWord:_input->textView.textStorage.string range:_input->textView.selectedRange];
-  if(currentWord != nullptr) {
+  NSDictionary *currentWord =
+      [WordsUtils getCurrentWord:_input->textView.textStorage.string
+                           range:_input->textView.selectedRange];
+  if (currentWord != nullptr) {
     // get word properties
     NSString *wordText = (NSString *)[currentWord objectForKey:@"word"];
     NSValue *wordRangeValue = (NSValue *)[currentWord objectForKey:@"range"];
-    if(wordText != nullptr && wordRangeValue != nullptr) {
-      [self removeConnectedLinksIfNeeded:wordText range:[wordRangeValue rangeValue]];
+    if (wordText != nullptr && wordRangeValue != nullptr) {
+      [self removeConnectedLinksIfNeeded:wordText
+                                   range:[wordRangeValue rangeValue]];
     }
   }
 
@@ -177,33 +237,34 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 
   // don't search at the very end of input
   NSUInteger searchLocation = location;
-  if(searchLocation == _input->textView.textStorage.length) {
+  if (searchLocation == _input->textView.textStorage.length) {
     return nullptr;
   }
 
-  NSString *manualUrl = [_input->textView.textStorage
-    attribute:ManualLinkAttributeName
-    atIndex:searchLocation
-    longestEffectiveRange: &manualLinkRange
-    inRange:inputRange
-  ];
-  NSString *automaticUrl = [_input->textView.textStorage
-    attribute:AutomaticLinkAttributeName
-    atIndex:searchLocation
-    longestEffectiveRange: &automaticLinkRange
-    inRange:inputRange
-  ];
-  
-  if((manualUrl == nullptr && automaticUrl == nullptr) || (manualLinkRange.length == 0 && automaticLinkRange.length == 0)) {
+  NSString *manualUrl =
+      [_input->textView.textStorage attribute:ManualLinkAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&manualLinkRange
+                                      inRange:inputRange];
+  NSString *automaticUrl =
+      [_input->textView.textStorage attribute:AutomaticLinkAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&automaticLinkRange
+                                      inRange:inputRange];
+
+  if ((manualUrl == nullptr && automaticUrl == nullptr) ||
+      (manualLinkRange.length == 0 && automaticLinkRange.length == 0)) {
     return nullptr;
   }
 
   NSString *linkUrl = manualUrl == nullptr ? automaticUrl : manualUrl;
-  NSRange linkRange = manualUrl == nullptr ? automaticLinkRange : manualLinkRange;
+  NSRange linkRange =
+      manualUrl == nullptr ? automaticLinkRange : manualLinkRange;
 
   LinkData *data = [[LinkData alloc] init];
   data.url = linkUrl;
-  data.text = [_input->textView.textStorage.string substringWithRange:linkRange];
+  data.text =
+      [_input->textView.textStorage.string substringWithRange:linkRange];
   return data;
 }
 
@@ -215,61 +276,68 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 
   // get the previous index if possible when at the very end of input
   NSUInteger searchLocation = location;
-  if(searchLocation == _input->textView.textStorage.length) {
-    if(searchLocation == 0) {
+  if (searchLocation == _input->textView.textStorage.length) {
+    if (searchLocation == 0) {
       return NSMakeRange(0, 0);
     } else {
       searchLocation = searchLocation - 1;
     }
   }
 
-  NSString *manualLink = [_input->textView.textStorage
-    attribute:ManualLinkAttributeName
-    atIndex:searchLocation
-    longestEffectiveRange: &manualLinkRange
-    inRange:inputRange
-  ];
-  NSString *automaticLink = [_input->textView.textStorage
-    attribute:AutomaticLinkAttributeName
-    atIndex:searchLocation
-    longestEffectiveRange: &automaticLinkRange
-    inRange:inputRange
-  ];
+  NSString *manualLink =
+      [_input->textView.textStorage attribute:ManualLinkAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&manualLinkRange
+                                      inRange:inputRange];
+  NSString *automaticLink =
+      [_input->textView.textStorage attribute:AutomaticLinkAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&automaticLinkRange
+                                      inRange:inputRange];
 
   return manualLink == nullptr
-    ? automaticLink == nullptr ? NSMakeRange(0, 0) : automaticLinkRange
-    : manualLinkRange;
+             ? automaticLink == nullptr ? NSMakeRange(0, 0) : automaticLinkRange
+             : manualLinkRange;
 }
 
 - (void)manageLinkTypingAttributes {
-  // link's typing attribtues need to be removed at ALL times whenever we have some link around
+  // link's typing attribtues need to be removed at ALL times whenever we have
+  // some link around
   BOOL removeAttrs = NO;
 
-  if(_input->textView.selectedRange.length == 0) {
+  if (_input->textView.selectedRange.length == 0) {
     // check before
-    if(_input->textView.selectedRange.location >= 1) {
-      if([self detectStyle:NSMakeRange(_input->textView.selectedRange.location - 1, 1)]) {
+    if (_input->textView.selectedRange.location >= 1) {
+      if ([self detectStyle:NSMakeRange(
+                                _input->textView.selectedRange.location - 1,
+                                1)]) {
         removeAttrs = YES;
       }
     }
     // check after
-    if(_input->textView.selectedRange.location < _input->textView.textStorage.length) {
-      if([self detectStyle:NSMakeRange(_input->textView.selectedRange.location, 1)]) {
+    if (_input->textView.selectedRange.location <
+        _input->textView.textStorage.length) {
+      if ([self detectStyle:NSMakeRange(_input->textView.selectedRange.location,
+                                        1)]) {
         removeAttrs = YES;
       }
     }
   } else {
-    if([self anyOccurence:_input->textView.selectedRange]) {
+    if ([self anyOccurence:_input->textView.selectedRange]) {
       removeAttrs = YES;
     }
   }
 
-  if(removeAttrs) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-    newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
-    newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-    newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
-    if([_input->config linkDecorationLine] == DecorationUnderline) {
+  if (removeAttrs) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    newTypingAttrs[NSForegroundColorAttributeName] =
+        [_input->config primaryColor];
+    newTypingAttrs[NSUnderlineColorAttributeName] =
+        [_input->config primaryColor];
+    newTypingAttrs[NSStrikethroughColorAttributeName] =
+        [_input->config primaryColor];
+    if ([_input->config linkDecorationLine] == DecorationUnderline) {
       [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
     }
     _input->textView.typingAttributes = newTypingAttrs;
@@ -278,8 +346,12 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 
 // handles detecting and removing automatic links
 - (void)handleAutomaticLinks:(NSString *)word inRange:(NSRange)wordRange {
-  InlineCodeStyle *inlineCodeStyle = [_input->stylesDict objectForKey:@([InlineCodeStyle getStyleType])];
-  MentionStyle *mentionStyle = [_input->stylesDict objectForKey:@([MentionStyle getStyleType])];
+  InlineCodeStyle *inlineCodeStyle =
+      [_input->stylesDict objectForKey:@([InlineCodeStyle getStyleType])];
+  MentionStyle *mentionStyle =
+      [_input->stylesDict objectForKey:@([MentionStyle getStyleType])];
+  CodeBlockStyle *codeBlockStyle =
+      [_input->stylesDict objectForKey:@([CodeBlockStyle getStyleType])];
 
   if (inlineCodeStyle == nullptr || mentionStyle == nullptr) {
     return;
@@ -295,61 +367,85 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
     return;
   }
 
+  // we don't recognize links in codeblocks
+  if ([codeBlockStyle anyOccurence:wordRange]) {
+    return;
+  }
+
   // remove connected different links
   [self removeConnectedLinksIfNeeded:word range:wordRange];
 
   // we don't recognize automatic links along manual ones
   __block BOOL manualLinkPresent = NO;
-  [_input->textView.textStorage enumerateAttribute:ManualLinkAttributeName inRange:wordRange options:0
-    usingBlock:^(id value, NSRange range, BOOL *stop) {
-      NSString *urlValue = (NSString *)value;
-      if(urlValue != nullptr) {
-        manualLinkPresent = YES;
-        *stop = YES;
-      }
-  }];
-  if(manualLinkPresent) {
+  [_input->textView.textStorage
+      enumerateAttribute:ManualLinkAttributeName
+                 inRange:wordRange
+                 options:0
+              usingBlock:^(id value, NSRange range, BOOL *stop) {
+                NSString *urlValue = (NSString *)value;
+                if (urlValue != nullptr) {
+                  manualLinkPresent = YES;
+                  *stop = YES;
+                }
+              }];
+  if (manualLinkPresent) {
     return;
   }
 
-  NSRegularExpression *fullRegex = [NSRegularExpression regularExpressionWithPattern:@"http(s)?:\\/\\/www\\.[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
-      options:0
-      error:nullptr
-  ];
-  NSRegularExpression *wwwRegex = [NSRegularExpression regularExpressionWithPattern:@"www\\.[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
-      options:0
-      error:nullptr
-  ];
-  NSRegularExpression *bareRegex = [NSRegularExpression regularExpressionWithPattern:@"[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
-      options:0
-      error:nullptr
-  ];
+  NSRegularExpression *fullRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"http(s)?:\\/\\/"
+                                   @"www\\.[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-"
+                                   @"z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
+                           options:0
+                             error:nullptr];
+  NSRegularExpression *wwwRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"www\\.[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-"
+                                   @"z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
+                           options:0
+                             error:nullptr];
+  NSRegularExpression *bareRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-z]{2,"
+                                   @"6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)"
+                           options:0
+                             error:nullptr];
 
   NSString *regexPassedUrl = nullptr;
 
-  if ([fullRegex numberOfMatchesInString:word options:0 range:NSMakeRange(0, word.length)]) {
+  if ([fullRegex numberOfMatchesInString:word
+                                 options:0
+                                   range:NSMakeRange(0, word.length)]) {
     regexPassedUrl = word;
-  } else if ([wwwRegex numberOfMatchesInString:word options:0 range:NSMakeRange(0, word.length)]) {
+  } else if ([wwwRegex numberOfMatchesInString:word
+                                       options:0
+                                         range:NSMakeRange(0, word.length)]) {
     regexPassedUrl = word;
-  } else if ([bareRegex numberOfMatchesInString:word options:0 range:NSMakeRange(0, word.length)]) {
+  } else if ([bareRegex numberOfMatchesInString:word
+                                        options:0
+                                          range:NSMakeRange(0, word.length)]) {
     regexPassedUrl = word;
   } else if ([self anyOccurence:wordRange]) {
-    // there was some automatic link (because anyOccurence is true and we are sure there are no manual links)
-    // still, it didn't pass any regex - needs to be removed
+    // there was some automatic link (because anyOccurence is true and we are
+    // sure there are no manual links) still, it didn't pass any regex - needs
+    // to be removed
     [self removeAttributes:wordRange];
   }
 
-  if(regexPassedUrl != nullptr) {
+  if (regexPassedUrl != nullptr) {
     // add style only if needed
     BOOL addStyle = YES;
-    if([self detectStyle:wordRange]) {
+    if ([self detectStyle:wordRange]) {
       LinkData *currentData = [self getLinkDataAt:wordRange.location];
-      if(currentData != nullptr && currentData.url != nullptr && [currentData.url isEqualToString:regexPassedUrl]) {
+      if (currentData != nullptr && currentData.url != nullptr &&
+          [currentData.url isEqualToString:regexPassedUrl]) {
         addStyle = NO;
       }
     }
-    if(addStyle) {
-      [self addLink:word url:regexPassedUrl range:wordRange manual:NO];
+    if (addStyle) {
+      [self addLink:word
+                    url:regexPassedUrl
+                  range:wordRange
+                 manual:NO
+          withSelection:NO];
       // emit onLinkDetected if style was added
       [_input emitOnLinkDetectedEvent:word url:regexPassedUrl range:wordRange];
     }
@@ -364,56 +460,82 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
   __block NSInteger manualLinkMinIdx = -1;
   __block NSInteger manualLinkMaxIdx = -1;
 
-  [_input->textView.textStorage enumerateAttribute:ManualLinkAttributeName inRange:wordRange options:0
-    usingBlock:^(id value, NSRange range, BOOL *stop) {
-      NSString *urlValue = (NSString *)value;
-      if (urlValue != nullptr) {
-        NSInteger linkMin = range.location;
-        NSInteger linkMax = range.location + range.length - 1;
-        if (manualLinkMinIdx == -1 || linkMin < manualLinkMinIdx) {
-          manualLinkMinIdx = linkMin;
-          manualLinkMinValue = value;
-        }
-        if (manualLinkMaxIdx == -1 || linkMax > manualLinkMaxIdx) {
-          manualLinkMaxIdx = linkMax;
-          manualLinkMaxValue = value;
-        }
-      }
-  }];
+  [_input->textView.textStorage
+      enumerateAttribute:ManualLinkAttributeName
+                 inRange:wordRange
+                 options:0
+              usingBlock:^(id value, NSRange range, BOOL *stop) {
+                NSString *urlValue = (NSString *)value;
+                if (urlValue != nullptr) {
+                  NSInteger linkMin = range.location;
+                  NSInteger linkMax = range.location + range.length - 1;
+                  if (manualLinkMinIdx == -1 || linkMin < manualLinkMinIdx) {
+                    manualLinkMinIdx = linkMin;
+                    manualLinkMinValue = value;
+                  }
+                  if (manualLinkMaxIdx == -1 || linkMax > manualLinkMaxIdx) {
+                    manualLinkMaxIdx = linkMax;
+                    manualLinkMaxValue = value;
+                  }
+                }
+              }];
 
   // no manual links
-  if(manualLinkMinIdx == -1 || manualLinkMaxIdx == -1) {
+  if (manualLinkMinIdx == -1 || manualLinkMaxIdx == -1) {
     return;
   }
 
   // heuristic for refreshing manual links:
   // we update the Manual attribute between the bounds of existing ones
   // we do that only if the bounds point to the same url
-  // this way manual link gets "extended" only if some characters were added inside it
-  if([manualLinkMinValue isEqualToString:manualLinkMaxValue]) {
-    NSRange newRange = NSMakeRange(manualLinkMinIdx, manualLinkMaxIdx - manualLinkMinIdx + 1);
-    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config linkColor] range:newRange];
-    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config linkColor] range:newRange];
-    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config linkColor] range:newRange];
-    if([_input->config linkDecorationLine] == DecorationUnderline) {
-      [_input->textView.textStorage addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:newRange];
+  // this way manual link gets "extended" only if some characters were added
+  // inside it
+  if ([manualLinkMinValue isEqualToString:manualLinkMaxValue]) {
+    NSRange newRange =
+        NSMakeRange(manualLinkMinIdx, manualLinkMaxIdx - manualLinkMinIdx + 1);
+    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                         value:[_input->config linkColor]
+                                         range:newRange];
+    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                         value:[_input->config linkColor]
+                                         range:newRange];
+    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                         value:[_input->config linkColor]
+                                         range:newRange];
+    if ([_input->config linkDecorationLine] == DecorationUnderline) {
+      [_input->textView.textStorage addAttribute:NSUnderlineStyleAttributeName
+                                           value:@(NSUnderlineStyleSingle)
+                                           range:newRange];
     }
-    [_input->textView.textStorage addAttribute:ManualLinkAttributeName value:manualLinkMinValue range:newRange];
+    [_input->textView.textStorage addAttribute:ManualLinkAttributeName
+                                         value:manualLinkMinValue
+                                         range:newRange];
   }
 
   // link typing attributes need to be fixed after these changes
   [self manageLinkTypingAttributes];
 }
 
-// replacing whole input (that starts with a link) with a manually typed letter improperly applies link's attributes to all the following text
-- (BOOL)handleLeadingLinkReplacement:(NSRange)range replacementText:(NSString *)text {
+// replacing whole input (that starts with a link) with a manually typed letter
+// improperly applies link's attributes to all the following text
+- (BOOL)handleLeadingLinkReplacement:(NSRange)range
+                     replacementText:(NSString *)text {
   // whole textView range gets replaced with a single letter
-  if(_input->textView.textStorage.string.length > 0 && NSEqualRanges(range, NSMakeRange(0, _input->textView.textStorage.string.length)) && text.length == 1) {
+  if (_input->textView.textStorage.string.length > 0 &&
+      NSEqualRanges(
+          range, NSMakeRange(0, _input->textView.textStorage.string.length)) &&
+      text.length == 1) {
     // first character detection is enough for the removal to be done
-    if([self detectStyle:NSMakeRange(0, 1)]) {
-      [self removeAttributes:NSMakeRange(0, _input->textView.textStorage.string.length)];
+    if ([self detectStyle:NSMakeRange(0, 1)]) {
+      [self
+          removeAttributes:NSMakeRange(
+                               0, _input->textView.textStorage.string.length)];
       // do the replacing manually
-      [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:_input withSelection:YES];
+      [TextInsertionUtils replaceText:text
+                                   at:range
+                 additionalAttributes:nullptr
+                                input:_input
+                        withSelection:YES];
       return YES;
     }
   }
@@ -429,32 +551,39 @@ static NSString *const AutomaticLinkAttributeName = @"AutomaticLinkAttributeName
 }
 
 - (void)removeConnectedLinksIfNeeded:(NSString *)word range:(NSRange)wordRange {
-  BOOL anyAutomatic = [OccurenceUtils any:AutomaticLinkAttributeName withInput:_input inRange:wordRange
-    withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
-  BOOL anyManual = [OccurenceUtils any:ManualLinkAttributeName withInput:_input inRange:wordRange
-    withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  BOOL anyAutomatic =
+      [OccurenceUtils any:AutomaticLinkAttributeName
+                withInput:_input
+                  inRange:wordRange
+            withCondition:^BOOL(id _Nullable value, NSRange range) {
+              return [self styleCondition:value:range];
+            }];
+  BOOL anyManual =
+      [OccurenceUtils any:ManualLinkAttributeName
+                withInput:_input
+                  inRange:wordRange
+            withCondition:^BOOL(id _Nullable value, NSRange range) {
+              return [self styleCondition:value:range];
+            }];
 
   // both manual and automatic links are somewhere - delete!
-  if(anyAutomatic && anyManual) {
+  if (anyAutomatic && anyManual) {
     [self removeAttributes:wordRange];
     [self manageLinkTypingAttributes];
   }
 
-  // we are now sure there is only one type of link there - and make sure it covers the whole word
-  BOOL onlyLinks = [OccurenceUtils detectMultiple:@[ManualLinkAttributeName, AutomaticLinkAttributeName] withInput:_input inRange:wordRange
-    withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  // we are now sure there is only one type of link there - and make sure it
+  // covers the whole word
+  BOOL onlyLinks = [OccurenceUtils
+      detectMultiple:@[ ManualLinkAttributeName, AutomaticLinkAttributeName ]
+           withInput:_input
+             inRange:wordRange
+       withCondition:^BOOL(id _Nullable value, NSRange range) {
+         return [self styleCondition:value:range];
+       }];
 
   // only one link might be present!
-  if(onlyLinks && ![self isSingleLinkIn:wordRange]) {
+  if (onlyLinks && ![self isSingleLinkIn:wordRange]) {
     [self removeAttributes:wordRange];
     [self manageLinkTypingAttributes];
   }
diff --git a/node_modules/react-native-enriched/ios/styles/MentionStyle.mm b/node_modules/react-native-enriched/ios/styles/MentionStyle.mm
index f0ec496..a60b687 100644
--- a/node_modules/react-native-enriched/ios/styles/MentionStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/MentionStyle.mm
@@ -1,22 +1,28 @@
-#import "StyleHeaders.h"
+#import "ColorExtension.h"
 #import "EnrichedTextInputView.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
-#import "WordsUtils.h"
 #import "UIView+React.h"
-#import "ColorExtension.h"
+#import "WordsUtils.h"
 
 // custom NSAttributedStringKey to differentiate from links
 static NSString *const MentionAttributeName = @"MentionAttributeName";
 
 @implementation MentionStyle {
-  EnrichedTextInputView*_input;
+  EnrichedTextInputView *_input;
   NSValue *_activeMentionRange;
   NSString *_activeMentionIndicator;
   BOOL _blockMentionEditing;
 }
 
-+ (StyleType)getStyleType { return Mention; }
++ (StyleType)getStyleType {
+  return Mention;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -31,7 +37,7 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
   // no-op for mentions
 }
 
-- (void)addAttributes:(NSRange)range {
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
   // no-op for mentions
 }
 
@@ -45,28 +51,43 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 
   NSArray<StylePair *> *mentions = [self findAllOccurences:range];
   [_input->textView.textStorage beginEditing];
-  for(StylePair *pair in mentions) {
-    NSRange mentionRange = [self getFullMentionRangeAt:[pair.rangeValue rangeValue].location];
-    [_input->textView.textStorage removeAttribute:MentionAttributeName range:mentionRange];
-    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-    [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName range:mentionRange];
-    
-    if([self stylePropsWithParams:pair.styleValue].decorationLine == DecorationUnderline) {
-      [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName range:mentionRange];
+  for (StylePair *pair in mentions) {
+    NSRange mentionRange =
+        [self getFullMentionRangeAt:[pair.rangeValue rangeValue].location];
+    [_input->textView.textStorage removeAttribute:MentionAttributeName
+                                            range:mentionRange];
+    [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:mentionRange];
+    [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:mentionRange];
+    [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                         value:[_input->config primaryColor]
+                                         range:mentionRange];
+    [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName
+                                            range:mentionRange];
+
+    if ([self stylePropsWithParams:pair.styleValue].decorationLine ==
+        DecorationUnderline) {
+      [_input->textView.textStorage
+          removeAttribute:NSUnderlineStyleAttributeName
+                    range:mentionRange];
       someMentionHadUnderline = YES;
     }
   }
   [_input->textView.textStorage endEditing];
 
   // remove typing attributes as well
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config primaryColor];
   newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config primaryColor];
   [newTypingAttrs removeObjectForKey:NSBackgroundColorAttributeName];
-  if(someMentionHadUnderline) {
+  if (someMentionHadUnderline) {
     [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
   }
   _input->textView.typingAttributes = newTypingAttrs;
@@ -74,73 +95,94 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 
 // used for conflicts, we have to remove the whole mention
 - (void)removeTypingAttributes {
-  NSRange mentionRange = [self getFullMentionRangeAt:_input->textView.selectedRange.location];
+  NSRange mentionRange =
+      [self getFullMentionRangeAt:_input->textView.selectedRange.location];
   [_input->textView.textStorage beginEditing];
-  [_input->textView.textStorage removeAttribute:MentionAttributeName range:mentionRange];
-  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName value:[_input->config primaryColor] range:mentionRange];
-  [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName range:mentionRange];
+  [_input->textView.textStorage removeAttribute:MentionAttributeName
+                                          range:mentionRange];
+  [_input->textView.textStorage addAttribute:NSForegroundColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:mentionRange];
+  [_input->textView.textStorage addAttribute:NSUnderlineColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:mentionRange];
+  [_input->textView.textStorage addAttribute:NSStrikethroughColorAttributeName
+                                       value:[_input->config primaryColor]
+                                       range:mentionRange];
+  [_input->textView.textStorage removeAttribute:NSBackgroundColorAttributeName
+                                          range:mentionRange];
 
   MentionParams *params = [self getMentionParamsAt:mentionRange.location];
-  if([self stylePropsWithParams:params].decorationLine == DecorationUnderline) {
-    [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName range:mentionRange];
+  if ([self stylePropsWithParams:params].decorationLine ==
+      DecorationUnderline) {
+    [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName
+                                            range:mentionRange];
   }
   [_input->textView.textStorage endEditing];
 
   // remove typing attributes as well
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  newTypingAttrs[NSForegroundColorAttributeName] =
+      [_input->config primaryColor];
   newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-  newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
+  newTypingAttrs[NSStrikethroughColorAttributeName] =
+      [_input->config primaryColor];
   [newTypingAttrs removeObjectForKey:NSBackgroundColorAttributeName];
-  if([self stylePropsWithParams:params].decorationLine == DecorationUnderline) {
+  if ([self stylePropsWithParams:params].decorationLine ==
+      DecorationUnderline) {
     [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
   }
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   MentionParams *params = (MentionParams *)value;
   return params != nullptr;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:MentionAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:MentionAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
     return [self getMentionParamsAt:range.location] != nullptr;
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:MentionAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:MentionAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:MentionAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:MentionAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 // MARK: - Public non-standard methods
 
-- (void)addMention:(NSString *)indicator text:(NSString *)text attributes:(NSString *)attributes {
-  if(_activeMentionRange == nullptr) {
+- (void)addMention:(NSString *)indicator
+              text:(NSString *)text
+        attributes:(NSString *)attributes {
+  if (_activeMentionRange == nullptr) {
     return;
   }
 
-  // we block callbacks resulting from manageMentionEditing while we tamper with them here
+  // we block callbacks resulting from manageMentionEditing while we tamper with
+  // them here
   _blockMentionEditing = YES;
 
   MentionParams *params = [[MentionParams alloc] init];
@@ -148,27 +190,35 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
   params.indicator = indicator;
   params.attributes = attributes;
 
-  MentionStyleProps *styleProps = [_input->config mentionStylePropsForIndicator:indicator];
+  MentionStyleProps *styleProps =
+      [_input->config mentionStylePropsForIndicator:indicator];
 
   NSMutableDictionary *newAttrs = [@{
-    MentionAttributeName: params,
-    NSForegroundColorAttributeName: styleProps.color,
-    NSUnderlineColorAttributeName: styleProps.color,
-    NSStrikethroughColorAttributeName: styleProps.color,
-    NSBackgroundColorAttributeName: [styleProps.backgroundColor colorWithAlphaIfNotTransparent:0.4],
+    MentionAttributeName : params,
+    NSForegroundColorAttributeName : styleProps.color,
+    NSUnderlineColorAttributeName : styleProps.color,
+    NSStrikethroughColorAttributeName : styleProps.color,
+    NSBackgroundColorAttributeName :
+        [styleProps.backgroundColor colorWithAlphaIfNotTransparent:0.4],
   } mutableCopy];
 
-  if(styleProps.decorationLine == DecorationUnderline) {
+  if (styleProps.decorationLine == DecorationUnderline) {
     newAttrs[NSUnderlineStyleAttributeName] = @(NSUnderlineStyleSingle);
   }
 
   // add a single space after the mention
   NSString *newText = [NSString stringWithFormat:@"%@ ", text];
   NSRange rangeToBeReplaced = [_activeMentionRange rangeValue];
-  [TextInsertionUtils replaceText:newText at:rangeToBeReplaced additionalAttributes:nullptr input:_input withSelection:YES];
+  [TextInsertionUtils replaceText:newText
+                               at:rangeToBeReplaced
+             additionalAttributes:nullptr
+                            input:_input
+                    withSelection:YES];
 
   // THEN, add the attributes to not apply them on the space
-  [_input->textView.textStorage addAttributes:newAttrs range:NSMakeRange(rangeToBeReplaced.location, text.length)];
+  [_input->textView.textStorage
+      addAttributes:newAttrs
+              range:NSMakeRange(rangeToBeReplaced.location, text.length)];
 
   // mention editing should finish
   [self removeActiveMentionRange];
@@ -180,17 +230,19 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 - (void)addMentionAtRange:(NSRange)range params:(MentionParams *)params {
   _blockMentionEditing = YES;
 
-  MentionStyleProps *styleProps = [_input->config mentionStylePropsForIndicator:params.indicator];
+  MentionStyleProps *styleProps =
+      [_input->config mentionStylePropsForIndicator:params.indicator];
 
   NSMutableDictionary *newAttrs = [@{
-    MentionAttributeName: params,
-    NSForegroundColorAttributeName: styleProps.color,
-    NSUnderlineColorAttributeName: styleProps.color,
-    NSStrikethroughColorAttributeName: styleProps.color,
-    NSBackgroundColorAttributeName: [styleProps.backgroundColor colorWithAlphaIfNotTransparent:0.4],
+    MentionAttributeName : params,
+    NSForegroundColorAttributeName : styleProps.color,
+    NSUnderlineColorAttributeName : styleProps.color,
+    NSStrikethroughColorAttributeName : styleProps.color,
+    NSBackgroundColorAttributeName :
+        [styleProps.backgroundColor colorWithAlphaIfNotTransparent:0.4],
   } mutableCopy];
 
-  if(styleProps.decorationLine == DecorationUnderline) {
+  if (styleProps.decorationLine == DecorationUnderline) {
     newAttrs[NSUnderlineStyleAttributeName] = @(NSUnderlineStyleSingle);
   }
 
@@ -205,32 +257,44 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
   BOOL addSpaceBefore = NO;
   BOOL addSpaceAfter = NO;
 
-  if(currentRange.location > 0) {
-    unichar charBefore = [_input->textView.textStorage.string characterAtIndex:(currentRange.location - 1)];
-    if(![[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:charBefore]) {
+  if (currentRange.location > 0) {
+    unichar charBefore = [_input->textView.textStorage.string
+        characterAtIndex:(currentRange.location - 1)];
+    if (![[NSCharacterSet whitespaceAndNewlineCharacterSet]
+            characterIsMember:charBefore]) {
       addSpaceBefore = YES;
     }
   }
 
-  if(currentRange.location + currentRange.length < _input->textView.textStorage.string.length) {
-    unichar charAfter = [_input->textView.textStorage.string characterAtIndex:(currentRange.location + currentRange.length)];
-    if(![[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:charAfter]) {
+  if (currentRange.location + currentRange.length <
+      _input->textView.textStorage.string.length) {
+    unichar charAfter = [_input->textView.textStorage.string
+        characterAtIndex:(currentRange.location + currentRange.length)];
+    if (![[NSCharacterSet whitespaceAndNewlineCharacterSet]
+            characterIsMember:charAfter]) {
       addSpaceAfter = YES;
     }
   }
 
-  NSString *finalString = [NSString stringWithFormat:@"%@%@%@",
-    addSpaceBefore ? @" " : @"",
-    indicator,
-    addSpaceAfter ? @" " : @""
-  ];
+  NSString *finalString =
+      [NSString stringWithFormat:@"%@%@%@", addSpaceBefore ? @" " : @"",
+                                 indicator, addSpaceAfter ? @" " : @""];
 
-  NSRange newSelect = NSMakeRange(currentRange.location + finalString.length + (addSpaceAfter ? -1 : 0), 0);
+  NSRange newSelect = NSMakeRange(
+      currentRange.location + finalString.length + (addSpaceAfter ? -1 : 0), 0);
 
-  if(currentRange.length == 0) {
-    [TextInsertionUtils insertText:finalString at:currentRange.location additionalAttributes:nullptr input:_input withSelection:NO];
+  if (currentRange.length == 0) {
+    [TextInsertionUtils insertText:finalString
+                                at:currentRange.location
+              additionalAttributes:nullptr
+                             input:_input
+                     withSelection:NO];
   } else {
-    [TextInsertionUtils replaceText:finalString at:currentRange additionalAttributes:nullptr input:_input withSelection:NO];
+    [TextInsertionUtils replaceText:finalString
+                                 at:currentRange
+               additionalAttributes:nullptr
+                              input:_input
+                      withSelection:NO];
   }
 
   [_input->textView reactFocus];
@@ -240,32 +304,38 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 // handles removing no longer valid mentions
 - (void)handleExistingMentions {
   // unfortunately whole text needs to be checked for them
-  // checking the modified words doesn't work because mention's text can have any number of spaces, which makes one mention any number of words long
+  // checking the modified words doesn't work because mention's text can have
+  // any number of spaces, which makes one mention any number of words long
 
-  NSRange wholeText = NSMakeRange(0, _input->textView.textStorage.string.length);
+  NSRange wholeText =
+      NSMakeRange(0, _input->textView.textStorage.string.length);
   // get menntions in ascending range.location order
-  NSArray<StylePair *> *mentions = [[self findAllOccurences:wholeText] sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) {
-    NSRange range1 = [((StylePair *)obj1).rangeValue rangeValue];
-    NSRange range2 = [((StylePair *)obj2).rangeValue rangeValue];
-    if(range1.location < range2.location) {
-      return NSOrderedAscending;
-    } else {
-      return NSOrderedDescending;
-    }
-  }];
+  NSArray<StylePair *> *mentions = [[self findAllOccurences:wholeText]
+      sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1,
+                                                     id _Nonnull obj2) {
+        NSRange range1 = [((StylePair *)obj1).rangeValue rangeValue];
+        NSRange range2 = [((StylePair *)obj2).rangeValue rangeValue];
+        if (range1.location < range2.location) {
+          return NSOrderedAscending;
+        } else {
+          return NSOrderedDescending;
+        }
+      }];
 
   // set of ranges to have their mentions removed - aren't valid anymore
   NSMutableSet<NSValue *> *rangesToRemove = [[NSMutableSet alloc] init];
 
-  for(NSInteger i = 0; i < mentions.count; i++) {
+  for (NSInteger i = 0; i < mentions.count; i++) {
     StylePair *mention = mentions[i];
     NSRange currentRange = [mention.rangeValue rangeValue];
     NSString *currentText = ((MentionParams *)mention.styleValue).text;
-    // check locations with the previous mention if it exists - if they got merged they need to be removed
-    if(i > 0) {
-      NSRange prevRange = [((StylePair*)mentions[i-1]).rangeValue rangeValue];
+    // check locations with the previous mention if it exists - if they got
+    // merged they need to be removed
+    if (i > 0) {
+      NSRange prevRange =
+          [((StylePair *)mentions[i - 1]).rangeValue rangeValue];
       // mentions merged - both need to go out
-      if(prevRange.location + prevRange.length == currentRange.location) {
+      if (prevRange.location + prevRange.length == currentRange.location) {
         [rangesToRemove addObject:[NSValue valueWithRange:prevRange]];
         [rangesToRemove addObject:[NSValue valueWithRange:currentRange]];
         continue;
@@ -273,13 +343,14 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
     }
 
     // check for text, any modifications to it makes mention invalid
-    NSString *existingText = [_input->textView.textStorage.string substringWithRange:currentRange];
-    if(![existingText isEqualToString:currentText]) {
+    NSString *existingText =
+        [_input->textView.textStorage.string substringWithRange:currentRange];
+    if (![existingText isEqualToString:currentText]) {
       [rangesToRemove addObject:[NSValue valueWithRange:currentRange]];
     }
   }
 
-  for(NSValue *value in rangesToRemove) {
+  for (NSValue *value in rangesToRemove) {
     [self removeAttributes:[value rangeValue]];
   }
 }
@@ -287,113 +358,124 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 // manages active mention range, which in turn emits proper onMention event
 - (void)manageMentionEditing {
   // no actions performed when block is active
-  if(_blockMentionEditing) {
+  if (_blockMentionEditing) {
     return;
   }
 
   // we don't take longer selections into consideration
-  if(_input->textView.selectedRange.length > 0) {
-    [self removeActiveMentionRange];
-    return;
-  }
-  
-  // get the current word if it exists
-  // we can be using current word only thanks to the fact that ongoing mentions are always one word (in contrast to ready, added mentions)
-  NSDictionary *currentWord = [WordsUtils getCurrentWord:_input->textView.textStorage.string range:_input->textView.selectedRange];
-  if(currentWord == nullptr) {
-    [self removeActiveMentionRange];
-    return;
-  }
-  
-  // get word properties
-  NSString *wordText = (NSString *)[currentWord objectForKey:@"word"];
-  NSValue *wordRangeValue = (NSValue *)[currentWord objectForKey:@"range"];
-  if(wordText == nullptr || wordRangeValue == nullptr) {
+  if (_input->textView.selectedRange.length > 0) {
     [self removeActiveMentionRange];
     return;
   }
-  NSRange wordRange = [wordRangeValue rangeValue];
 
-  // check for mentionIndicators - no sign of them means we shouldn't be editing a mention
-  unichar firstChar = [wordText characterAtIndex:0];
-  if(![[_input->config mentionIndicators] containsObject: @(firstChar)]) {
+  // get the text (and its range) that could be an editable mention
+  NSArray *mentionCandidate = [self getMentionCandidate];
+  if (mentionCandidate == nullptr) {
     [self removeActiveMentionRange];
     return;
   }
-  
-  // check for existing mentions - we don't edit them
-  if([self detectStyle:wordRange]) {
-    [self removeActiveMentionRange];
-    return;
-  }
-  
-  // get conflicting style classes
-  LinkStyle* linkStyle = [_input->stylesDict objectForKey:@([LinkStyle getStyleType])];
-  InlineCodeStyle* inlineCodeStyle = [_input->stylesDict objectForKey:@([InlineCodeStyle getStyleType])];
-  if(linkStyle == nullptr || inlineCodeStyle == nullptr) {
-    [self removeActiveMentionRange];
-    return;
+  NSString *candidateText = mentionCandidate[0];
+  NSRange candidateRange = [(NSValue *)mentionCandidate[1] rangeValue];
+
+  // get style classes that the mention shouldn't be recognized in, together
+  // with other mentions
+  NSArray *conflicts =
+      _input->conflictingStyles[@([MentionStyle getStyleType])];
+  NSArray *blocks = _input->blockingStyles[@([MentionStyle getStyleType])];
+  NSArray *allConflicts = [[conflicts arrayByAddingObjectsFromArray:blocks]
+      arrayByAddingObject:@([MentionStyle getStyleType])];
+  BOOL conflictingStyle = NO;
+
+  for (NSNumber *styleType in allConflicts) {
+    id<BaseStyleProtocol> styleClass = _input->stylesDict[styleType];
+    if (styleClass != nullptr && [styleClass anyOccurence:candidateRange]) {
+      conflictingStyle = YES;
+      break;
+    }
   }
 
-  // if there is any sign of conflicting style classes, stop editing a mention
-  if([linkStyle anyOccurence:wordRange] || [inlineCodeStyle anyOccurence:wordRange]) {
+  // if any of the conflicting styles were present, don't edit the mention
+  if (conflictingStyle) {
     [self removeActiveMentionRange];
     return;
   }
 
   // everything checks out - we are indeed editing a mention
-  [self setActiveMentionRange:wordRange text:wordText];
+  [self setActiveMentionRange:candidateRange text:candidateText];
 }
 
 // used to fix mentions' typing attributes
 - (void)manageMentionTypingAttributes {
-  // same as with links, mentions' typing attributes need to be constantly removed whenever we are somewhere near
+  // same as with links, mentions' typing attributes need to be constantly
+  // removed whenever we are somewhere near
   BOOL removeAttrs = NO;
   MentionParams *params;
 
-  if(_input->textView.selectedRange.length == 0) {
+  if (_input->textView.selectedRange.length == 0) {
     // check before
-    if(_input->textView.selectedRange.location >= 1) {
-      if([self detectStyle:NSMakeRange(_input->textView.selectedRange.location - 1, 1)]) {
+    if (_input->textView.selectedRange.location >= 1) {
+      if ([self detectStyle:NSMakeRange(
+                                _input->textView.selectedRange.location - 1,
+                                1)]) {
         removeAttrs = YES;
-        params = [self getMentionParamsAt:_input->textView.selectedRange.location - 1];
+        params = [self
+            getMentionParamsAt:_input->textView.selectedRange.location - 1];
       }
     }
     // check after
-    if(_input->textView.selectedRange.location < _input->textView.textStorage.length) {
-      if([self detectStyle:NSMakeRange(_input->textView.selectedRange.location, 1)]) {
+    if (_input->textView.selectedRange.location <
+        _input->textView.textStorage.length) {
+      if ([self detectStyle:NSMakeRange(_input->textView.selectedRange.location,
+                                        1)]) {
         removeAttrs = YES;
-        params = [self getMentionParamsAt:_input->textView.selectedRange.location];
+        params =
+            [self getMentionParamsAt:_input->textView.selectedRange.location];
       }
     }
   } else {
-    if([self anyOccurence:_input->textView.selectedRange]) {
+    if ([self anyOccurence:_input->textView.selectedRange]) {
       removeAttrs = YES;
     }
   }
 
-  if(removeAttrs) {
-    NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-    newTypingAttrs[NSForegroundColorAttributeName] = [_input->config primaryColor];
-    newTypingAttrs[NSUnderlineColorAttributeName] = [_input->config primaryColor];
-    newTypingAttrs[NSStrikethroughColorAttributeName] = [_input->config primaryColor];
+  if (removeAttrs) {
+    NSMutableDictionary *newTypingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    newTypingAttrs[NSForegroundColorAttributeName] =
+        [_input->config primaryColor];
+    newTypingAttrs[NSUnderlineColorAttributeName] =
+        [_input->config primaryColor];
+    newTypingAttrs[NSStrikethroughColorAttributeName] =
+        [_input->config primaryColor];
     [newTypingAttrs removeObjectForKey:NSBackgroundColorAttributeName];
-    if([self stylePropsWithParams:params].decorationLine == DecorationUnderline) {
+    if ([self stylePropsWithParams:params].decorationLine ==
+        DecorationUnderline) {
       [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
     }
     _input->textView.typingAttributes = newTypingAttrs;
   }
 }
 
-// replacing whole input (that starts with a mention) with a manually typed letter improperly applies mention's attributes to all the following text
-- (BOOL)handleLeadingMentionReplacement:(NSRange)range replacementText:(NSString *)text {
+// replacing whole input (that starts with a mention) with a manually typed
+// letter improperly applies mention's attributes to all the following text
+- (BOOL)handleLeadingMentionReplacement:(NSRange)range
+                        replacementText:(NSString *)text {
   // whole textView range gets replaced with a single letter
-  if(_input->textView.textStorage.string.length > 0 && NSEqualRanges(range, NSMakeRange(0, _input->textView.textStorage.string.length)) && text.length == 1) {
+  if (_input->textView.textStorage.string.length > 0 &&
+      NSEqualRanges(
+          range, NSMakeRange(0, _input->textView.textStorage.string.length)) &&
+      text.length == 1) {
     // first character detection is enough for the removal to be done
-    if([self detectStyle:NSMakeRange(0, 1)]) {
-      [self removeAttributes:NSMakeRange(0, _input->textView.textStorage.string.length)];
+    if ([self detectStyle:NSMakeRange(0, 1)]) {
+      [self
+          removeAttributes:NSMakeRange(
+                               0, _input->textView.textStorage.string.length)];
       // do the replacing manually
-      [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:_input withSelection:YES];
+      [TextInsertionUtils replaceText:text
+                                   at:range
+                 additionalAttributes:nullptr
+                                input:_input
+                        withSelection:YES];
       return YES;
     }
   }
@@ -407,16 +489,15 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 
   // don't search at the very end of input
   NSUInteger searchLocation = location;
-  if(searchLocation == _input->textView.textStorage.length) {
+  if (searchLocation == _input->textView.textStorage.length) {
     return nullptr;
   }
 
-  MentionParams *value = [_input->textView.textStorage
-   attribute:MentionAttributeName
-   atIndex:searchLocation
-   longestEffectiveRange: &mentionRange
-   inRange:inputRange
-  ];
+  MentionParams *value =
+      [_input->textView.textStorage attribute:MentionAttributeName
+                                      atIndex:searchLocation
+                        longestEffectiveRange:&mentionRange
+                                      inRange:inputRange];
   return value;
 }
 
@@ -431,20 +512,18 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 
   // get the previous index if possible when at the very end of input
   NSUInteger searchLocation = location;
-  if(searchLocation == _input->textView.textStorage.length) {
-    if(searchLocation == 0) {
+  if (searchLocation == _input->textView.textStorage.length) {
+    if (searchLocation == 0) {
       return mentionRange;
     } else {
       searchLocation = searchLocation - 1;
     }
   }
 
-  [_input->textView.textStorage
-   attribute:MentionAttributeName
-   atIndex:searchLocation
-   longestEffectiveRange: &mentionRange
-   inRange:inputRange
-  ];
+  [_input->textView.textStorage attribute:MentionAttributeName
+                                  atIndex:searchLocation
+                    longestEffectiveRange:&mentionRange
+                                  inRange:inputRange];
   return mentionRange;
 }
 
@@ -454,18 +533,154 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
   return [_input->config mentionStylePropsForIndicator:params.indicator];
 }
 
-// both used for setting the active mention range + indicator and fires proper onMention event
+// finds if any word/words around current selection are eligible to be edited as
+// mentions since we allow for a single space inside an edited mention, we have
+// take both current and the previous word into account
+- (NSArray *)getMentionCandidate {
+  NSDictionary *currentWord, *previousWord;
+  NSString *currentWordText, *previousWordText, *finalText;
+  NSValue *currentWordRange, *previousWordRange;
+  NSRange finalRange;
+
+  // word at the current selection
+  currentWord = [WordsUtils getCurrentWord:_input->textView.textStorage.string
+                                     range:_input->textView.selectedRange];
+  if (currentWord != nullptr) {
+    currentWordText = (NSString *)[currentWord objectForKey:@"word"];
+    currentWordRange = (NSValue *)[currentWord objectForKey:@"range"];
+  }
+
+  if (currentWord != nullptr) {
+    // current word exists
+    unichar currentFirstChar = [currentWordText characterAtIndex:0];
+
+    if ([[_input->config mentionIndicators]
+            containsObject:@(currentFirstChar)]) {
+      // current word exists and has a mention indicator; no need to check for
+      // the previous word
+      finalText = currentWordText;
+      finalRange = [currentWordRange rangeValue];
+    } else {
+      // current word exists but no traces of mention indicator; get the
+      // previous word
+
+      NSInteger previousWordSearchLocation =
+          [currentWordRange rangeValue].location - 1;
+      if (previousWordSearchLocation < 0) {
+        // previous word can't exist
+        return nullptr;
+      }
+
+      unichar separatorChar = [_input->textView.textStorage.string
+          characterAtIndex:previousWordSearchLocation];
+      if (![[NSCharacterSet whitespaceCharacterSet]
+              characterIsMember:separatorChar]) {
+        // we want to check for the previous word ONLY if the separating
+        // character was a space newlines don't make it
+        return nullptr;
+      }
+
+      previousWord = [WordsUtils
+          getCurrentWord:_input->textView.textStorage.string
+                   range:NSMakeRange(previousWordSearchLocation, 0)];
+
+      if (previousWord != nullptr) {
+        // previous word exists; get its properties
+        previousWordText = (NSString *)[previousWord objectForKey:@"word"];
+        previousWordRange = (NSValue *)[previousWord objectForKey:@"range"];
+
+        // check for the mention indicators in the previous word
+        unichar previousFirstChar = [previousWordText characterAtIndex:0];
+
+        if ([[_input->config mentionIndicators]
+                containsObject:@(previousFirstChar)]) {
+          // previous word has a proper mention indicator: treat both words as
+          // an editable mention
+          finalText = [NSString
+              stringWithFormat:@"%@ %@", previousWordText, currentWordText];
+          // range length is both words' lengths + 1 for a space between them
+          finalRange =
+              NSMakeRange([previousWordRange rangeValue].location,
+                          [previousWordRange rangeValue].length +
+                              [currentWordRange rangeValue].length + 1);
+        } else {
+          // neither current nor previous words have a mention indicator
+          return nullptr;
+        }
+      } else {
+        // previous word doesn't exist and no mention indicators in the current
+        // word
+        return nullptr;
+      }
+    }
+  } else {
+    // current word doesn't exist; try getting the previous one
+
+    NSInteger previousWordSearchLocation =
+        _input->textView.selectedRange.location - 1;
+    if (previousWordSearchLocation < 0) {
+      // previous word can't exist
+      return nullptr;
+    }
+
+    unichar separatorChar = [_input->textView.textStorage.string
+        characterAtIndex:previousWordSearchLocation];
+    if (![[NSCharacterSet whitespaceCharacterSet]
+            characterIsMember:separatorChar]) {
+      // we want to check for the previous word ONLY if the separating character
+      // was a space newlines don't make it
+      return nullptr;
+    }
+
+    previousWord =
+        [WordsUtils getCurrentWord:_input->textView.textStorage.string
+                             range:NSMakeRange(previousWordSearchLocation, 0)];
+
+    if (previousWord != nullptr) {
+      // previous word exists; get its properties
+      previousWordText = (NSString *)[previousWord objectForKey:@"word"];
+      previousWordRange = (NSValue *)[previousWord objectForKey:@"range"];
+
+      // check for the mention indicators in the previous word
+      unichar previousFirstChar = [previousWordText characterAtIndex:0];
+
+      if ([[_input->config mentionIndicators]
+              containsObject:@(previousFirstChar)]) {
+        // previous word has a proper mention indicator; treat previous word + a
+        // space as a editable mention
+        finalText = [NSString stringWithFormat:@"%@ ", previousWordText];
+        // the range length is previous word length + 1 for a space
+        finalRange = NSMakeRange([previousWordRange rangeValue].location,
+                                 [previousWordRange rangeValue].length + 1);
+      } else {
+        // no current word, previous has no mention indicators
+        return nullptr;
+      }
+    } else {
+      // no current word, no previous word
+      return nullptr;
+    }
+  }
+
+  return @[ finalText, [NSValue valueWithRange:finalRange] ];
+}
+
+// both used for setting the active mention range + indicator and fires proper
+// onMention event
 - (void)setActiveMentionRange:(NSRange)range text:(NSString *)text {
-  NSString *indicatorString = [NSString stringWithFormat:@"%C", [text characterAtIndex:0]];
-  NSString *textString = [text substringWithRange:NSMakeRange(1, text.length - 1)];
+  NSString *indicatorString =
+      [NSString stringWithFormat:@"%C", [text characterAtIndex:0]];
+  NSString *textString =
+      [text substringWithRange:NSMakeRange(1, text.length - 1)];
   _activeMentionIndicator = indicatorString;
   _activeMentionRange = [NSValue valueWithRange:range];
   [_input emitOnMentionEvent:indicatorString text:textString];
 }
 
-// removes stored mention range + indicator, which means that we no longer edit a mention and onMention event gets fired
+// removes stored mention range + indicator, which means that we no longer edit
+// a mention and onMention event gets fired
 - (void)removeActiveMentionRange {
-  if(_activeMentionIndicator != nullptr && _activeMentionRange != nullptr) {
+  if (_activeMentionIndicator != nullptr && _activeMentionRange != nullptr) {
     NSString *indicatorCopy = [_activeMentionIndicator copy];
     _activeMentionIndicator = nullptr;
     _activeMentionRange = nullptr;
@@ -474,4 +689,3 @@ static NSString *const MentionAttributeName = @"MentionAttributeName";
 }
 
 @end
-
diff --git a/node_modules/react-native-enriched/ios/styles/OrderedListStyle.mm b/node_modules/react-native-enriched/ios/styles/OrderedListStyle.mm
index c4234a4..d9c918e 100644
--- a/node_modules/react-native-enriched/ios/styles/OrderedListStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/OrderedListStyle.mm
@@ -1,20 +1,27 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
 #import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
 
 @implementation OrderedListStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return OrderedList; }
++ (StyleType)getStyleType {
+  return OrderedList;
+}
+
++ (BOOL)isParagraphStyle {
+  return YES;
+}
 
 - (CGFloat)getHeadIndent {
   // lists are drawn manually
   // margin before marker + gap between marker and paragraph
-  return [_input->config orderedListMarginLeft] + [_input->config orderedListGapWidth];
+  return [_input->config orderedListMarginLeft] +
+         [_input->config orderedListGapWidth];
 }
 
 - (instancetype)initWithInput:(id)input {
@@ -25,18 +32,24 @@
 
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
 // we assume correct paragraph range is already given
-- (void)addAttributes:(NSRange)range {
-  NSTextList *numberBullet = [[NSTextList alloc] initWithMarkerFormat:NSTextListMarkerDecimal options:0];
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
-  // if we fill empty lines with zero width spaces, we need to offset later ranges
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  NSTextList *numberBullet =
+      [[NSTextList alloc] initWithMarkerFormat:NSTextListMarkerDecimal
+                                       options:0];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
+  // if we fill empty lines with zero width spaces, we need to offset later
+  // ranges
   NSInteger offset = 0;
   // needed for range adjustments
   NSRange preModificationRange = _input->textView.selectedRange;
@@ -44,80 +57,111 @@
   // let's not emit some weird selection changes or text/html changes
   _input->blockEmitting = YES;
 
-  for(NSValue *value in paragraphs) {
+  for (NSValue *value in paragraphs) {
     // take previous offsets into consideration
-    NSRange fixedRange = NSMakeRange([value rangeValue].location + offset, [value rangeValue].length);
-    
-    // length 0 with first line, length 1 and newline with some empty lines in the middle
-    if(fixedRange.length == 0 ||
-      (fixedRange.length == 1 &&
-      [[NSCharacterSet newlineCharacterSet] characterIsMember: [_input->textView.textStorage.string characterAtIndex:fixedRange.location]])
-    ) {
-      [TextInsertionUtils insertText:@"\u200B" at:fixedRange.location additionalAttributes:nullptr input:_input withSelection:NO];
+    NSRange fixedRange = NSMakeRange([value rangeValue].location + offset,
+                                     [value rangeValue].length);
+
+    // length 0 with first line, length 1 and newline with some empty lines in
+    // the middle
+    if (fixedRange.length == 0 ||
+        (fixedRange.length == 1 &&
+         [[NSCharacterSet newlineCharacterSet]
+             characterIsMember:[_input->textView.textStorage.string
+                                   characterAtIndex:fixedRange.location]])) {
+      [TextInsertionUtils insertText:@"\u200B"
+                                  at:fixedRange.location
+                additionalAttributes:nullptr
+                               input:_input
+                       withSelection:NO];
       fixedRange = NSMakeRange(fixedRange.location, fixedRange.length + 1);
       offset += 1;
     }
 
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:fixedRange options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.textLists = @[numberBullet];
-        pStyle.headIndent = [self getHeadIndent];
-        pStyle.firstLineHeadIndent = [self getHeadIndent];
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:fixedRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[ numberBullet ];
+                  pStyle.headIndent = [self getHeadIndent];
+                  pStyle.firstLineHeadIndent = [self getHeadIndent];
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   // back to emitting
   _input->blockEmitting = NO;
 
-  if(preModificationRange.length == 0) {
-    // fix selection if only one line was possibly made a list and filled with a space
+  if (preModificationRange.length == 0) {
+    // fix selection if only one line was possibly made a list and filled with a
+    // space
     _input->textView.selectedRange = preModificationRange;
   } else {
     // in other cases, fix the selection with newly made offsets
-    _input->textView.selectedRange = NSMakeRange(preModificationRange.location, preModificationRange.length + offset);
+    _input->textView.selectedRange = NSMakeRange(
+        preModificationRange.location, preModificationRange.length + offset);
   }
 
   // also add typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
-  pStyle.textLists = @[numberBullet];
-  pStyle.headIndent = [self getHeadIndent];
-  pStyle.firstLineHeadIndent = [self getHeadIndent];
-  typingAttrs[NSParagraphStyleAttributeName] = pStyle;
-  _input->textView.typingAttributes = typingAttrs;
+  if (withTypingAttr) {
+    NSMutableDictionary *typingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    NSMutableParagraphStyle *pStyle =
+        [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+    pStyle.textLists = @[ numberBullet ];
+    pStyle.headIndent = [self getHeadIndent];
+    pStyle.firstLineHeadIndent = [self getHeadIndent];
+    typingAttrs[NSParagraphStyleAttributeName] = pStyle;
+    _input->textView.typingAttributes = typingAttrs;
+  }
 }
 
 // does pretty much the same as normal addAttributes, just need to get the range
 - (void)addTypingAttributes {
-  [self addAttributes:_input->textView.selectedRange];
+  [self addAttributes:_input->textView.selectedRange withTypingAttr:YES];
 }
 
 - (void)removeAttributes:(NSRange)range {
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
 
   [_input->textView.textStorage beginEditing];
 
-  for(NSValue *value in paragraphs) {
+  for (NSValue *value in paragraphs) {
     NSRange range = [value rangeValue];
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:range options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.textLists = @[];
-        pStyle.headIndent = 0;
-        pStyle.firstLineHeadIndent = 0;
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:range
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[];
+                  pStyle.headIndent = 0;
+                  pStyle.firstLineHeadIndent = 0;
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   [_input->textView.textStorage endEditing];
 
   // also remove typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+  NSMutableDictionary *typingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  NSMutableParagraphStyle *pStyle =
+      [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
   pStyle.textLists = @[];
   pStyle.headIndent = 0;
   pStyle.firstLineHeadIndent = 0;
@@ -125,24 +169,28 @@
   _input->textView.typingAttributes = typingAttrs;
 }
 
-// needed for the sake of style conflicts, needs to do exactly the same as removeAttribtues
+// needed for the sake of style conflicts, needs to do exactly the same as
+// removeAttribtues
 - (void)removeTypingAttributes {
   [self removeAttributes:_input->textView.selectedRange];
 }
 
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text {
-  if([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
+  if ([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
     // backspace while the style is active
 
-    NSRange paragraphRange = [_input->textView.textStorage.string paragraphRangeForRange:_input->textView.selectedRange];
+    NSRange paragraphRange = [_input->textView.textStorage.string
+        paragraphRangeForRange:_input->textView.selectedRange];
 
-    if(NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
+    if (NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
       // a backspace on the very first input's line list point
-      // it doesn't run textVieDidChange so we need to manually remove attributes
+      // it doesn't run textVieDidChange so we need to manually remove
+      // attributes
       [self removeAttributes:paragraphRange];
       return YES;
-    } else if(range.location == paragraphRange.location - 1) {
-      // same case in other lines; here, the removed range location will be exactly 1 less than paragraph range location
+    } else if (range.location == paragraphRange.location - 1) {
+      // same case in other lines; here, the removed range location will be
+      // exactly 1 less than paragraph range location
       [self removeAttributes:paragraphRange];
       return YES;
     }
@@ -150,24 +198,36 @@
   return NO;
 }
 
-- (BOOL)tryHandlingListShorcutInRange:(NSRange)range replacementText:(NSString *)text {
-  NSRange paragraphRange = [_input->textView.textStorage.string paragraphRangeForRange:range];
-  // a dot was added - check if we are both at the paragraph beginning + 1 character (which we want to be a dash)
-  if([text isEqualToString:@"."] && range.location - 1 == paragraphRange.location) {
-    unichar charBefore = [_input->textView.textStorage.string characterAtIndex:range.location - 1];
-    if(charBefore == '1') {
+- (BOOL)tryHandlingListShorcutInRange:(NSRange)range
+                      replacementText:(NSString *)text {
+  NSRange paragraphRange =
+      [_input->textView.textStorage.string paragraphRangeForRange:range];
+  // a dot was added - check if we are both at the paragraph beginning + 1
+  // character (which we want to be a dash)
+  if ([text isEqualToString:@"."] &&
+      range.location - 1 == paragraphRange.location) {
+    unichar charBefore = [_input->textView.textStorage.string
+        characterAtIndex:range.location - 1];
+    if (charBefore == '1') {
       // we got a match - add a list if possible
-      if([_input handleStyleBlocksAndConflicts:[[self class] getStyleType] range:paragraphRange]) {
+      if ([_input handleStyleBlocksAndConflicts:[[self class] getStyleType]
+                                          range:paragraphRange]) {
         // don't emit during the replacing
         _input->blockEmitting = YES;
 
         // remove the number
-        [TextInsertionUtils replaceText:@"" at:NSMakeRange(paragraphRange.location, 1) additionalAttributes:nullptr input:_input withSelection:YES];
+        [TextInsertionUtils replaceText:@""
+                                     at:NSMakeRange(paragraphRange.location, 1)
+                   additionalAttributes:nullptr
+                                  input:_input
+                          withSelection:YES];
 
         _input->blockEmitting = NO;
 
         // add attributes on the paragraph
-        [self addAttributes:NSMakeRange(paragraphRange.location, paragraphRange.length - 1)];
+        [self addAttributes:NSMakeRange(paragraphRange.location,
+                                        paragraphRange.length - 1)
+             withTypingAttr:YES];
         return YES;
       }
     }
@@ -175,41 +235,48 @@
   return NO;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSParagraphStyle *paragraph = (NSParagraphStyle *)value;
-  return paragraph != nullptr && paragraph.textLists.count == 1 && paragraph.textLists.firstObject.markerFormat == NSTextListMarkerDecimal;
+  return paragraph != nullptr && paragraph.textLists.count == 1 &&
+         paragraph.textLists.firstObject.markerFormat ==
+             NSTextListMarkerDecimal;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input atIndex:range.location checkPrevious:YES
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/StrikethroughStyle.mm b/node_modules/react-native-enriched/ios/styles/StrikethroughStyle.mm
index 8293238..9cf96d3 100644
--- a/node_modules/react-native-enriched/ios/styles/StrikethroughStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/StrikethroughStyle.mm
@@ -1,12 +1,18 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 
 @implementation StrikethroughStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return Strikethrough; }
++ (StyleType)getStyleType {
+  return Strikethrough;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -15,69 +21,82 @@
 }
 
 - (void)applyStyle:(NSRange)range {
-  BOOL isStylePresent = [self detectStyle: range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  BOOL isStylePresent = [self detectStyle:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
-  [_input->textView.textStorage addAttribute:NSStrikethroughStyleAttributeName value:@(NSUnderlineStyleSingle) range:range];
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  [_input->textView.textStorage addAttribute:NSStrikethroughStyleAttributeName
+                                       value:@(NSUnderlineStyleSingle)
+                                       range:range];
 }
 
 - (void)addTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
   newTypingAttrs[NSStrikethroughStyleAttributeName] = @(NSUnderlineStyleSingle);
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
 - (void)removeAttributes:(NSRange)range {
-  [_input->textView.textStorage removeAttribute:NSStrikethroughStyleAttributeName range:range];
+  [_input->textView.textStorage
+      removeAttribute:NSStrikethroughStyleAttributeName
+                range:range];
 }
 
 - (void)removeTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  [newTypingAttrs removeObjectForKey: NSStrikethroughStyleAttributeName];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  [newTypingAttrs removeObjectForKey:NSStrikethroughStyleAttributeName];
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSNumber *strikethroughStyle = (NSNumber *)value;
-  return strikethroughStyle != nullptr && [strikethroughStyle intValue] != NSUnderlineStyleNone;
+  return strikethroughStyle != nullptr &&
+         [strikethroughStyle intValue] != NSUnderlineStyleNone;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSStrikethroughStyleAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSStrikethroughStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSStrikethroughStyleAttributeName withInput:_input atIndex:range.location checkPrevious:NO
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSStrikethroughStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:NO
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSStrikethroughStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSStrikethroughStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSStrikethroughStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSStrikethroughStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/UnderlineStyle.mm b/node_modules/react-native-enriched/ios/styles/UnderlineStyle.mm
index f36aa08..9805047 100644
--- a/node_modules/react-native-enriched/ios/styles/UnderlineStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/UnderlineStyle.mm
@@ -1,12 +1,18 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "OccurenceUtils.h"
+#import "StyleHeaders.h"
 
 @implementation UnderlineStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return Underline; }
++ (StyleType)getStyleType {
+  return Underline;
+}
+
++ (BOOL)isParagraphStyle {
+  return NO;
+}
 
 - (instancetype)initWithInput:(id)input {
   self = [super init];
@@ -15,58 +21,68 @@
 }
 
 - (void)applyStyle:(NSRange)range {
-  BOOL isStylePresent = [self detectStyle: range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  BOOL isStylePresent = [self detectStyle:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
-- (void)addAttributes:(NSRange)range {
-  [_input->textView.textStorage addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:range];
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  [_input->textView.textStorage addAttribute:NSUnderlineStyleAttributeName
+                                       value:@(NSUnderlineStyleSingle)
+                                       range:range];
 }
 
 - (void)addTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
   newTypingAttrs[NSUnderlineStyleAttributeName] = @(NSUnderlineStyleSingle);
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
 - (void)removeAttributes:(NSRange)range {
-  [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName range:range];
+  [_input->textView.textStorage removeAttribute:NSUnderlineStyleAttributeName
+                                          range:range];
 }
 
 - (void)removeTypingAttributes {
-  NSMutableDictionary *newTypingAttrs = [_input->textView.typingAttributes mutableCopy];
-  [newTypingAttrs removeObjectForKey: NSUnderlineStyleAttributeName];
+  NSMutableDictionary *newTypingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  [newTypingAttrs removeObjectForKey:NSUnderlineStyleAttributeName];
   _input->textView.typingAttributes = newTypingAttrs;
 }
 
 - (BOOL)underlinedLinkConflictsInRange:(NSRange)range {
   BOOL conflicted = NO;
-  if([_input->config linkDecorationLine] == DecorationUnderline) {
+  if ([_input->config linkDecorationLine] == DecorationUnderline) {
     LinkStyle *linkStyle = _input->stylesDict[@([LinkStyle getStyleType])];
-    conflicted = range.length > 0
-      ? [linkStyle anyOccurence:range]
-      : [linkStyle detectStyle:range];
+    conflicted = range.length > 0 ? [linkStyle anyOccurence:range]
+                                  : [linkStyle detectStyle:range];
   }
   return conflicted;
 }
 
 - (BOOL)underlinedMentionConflictsInRange:(NSRange)range {
   BOOL conflicted = NO;
-  MentionStyle *mentionStyle = _input->stylesDict[@([MentionStyle getStyleType])];
-  if(range.length == 0) {
-    if([mentionStyle detectStyle:range]) {
+  MentionStyle *mentionStyle =
+      _input->stylesDict[@([MentionStyle getStyleType])];
+  if (range.length == 0) {
+    if ([mentionStyle detectStyle:range]) {
       MentionParams *params = [mentionStyle getMentionParamsAt:range.location];
-      conflicted = [_input->config mentionStylePropsForIndicator:params.indicator].decorationLine == DecorationUnderline;
+      conflicted =
+          [_input->config mentionStylePropsForIndicator:params.indicator]
+              .decorationLine == DecorationUnderline;
     }
   } else {
     NSArray *occurences = [mentionStyle findAllOccurences:range];
-    for(StylePair *pair in occurences) {
-      MentionParams *params = [mentionStyle getMentionParamsAt:[pair.rangeValue rangeValue].location];
-      if([_input->config mentionStylePropsForIndicator:params.indicator].decorationLine == DecorationUnderline) {
+    for (StylePair *pair in occurences) {
+      MentionParams *params = [mentionStyle
+          getMentionParamsAt:[pair.rangeValue rangeValue].location];
+      if ([_input->config mentionStylePropsForIndicator:params.indicator]
+              .decorationLine == DecorationUnderline) {
         conflicted = YES;
         break;
       }
@@ -75,41 +91,49 @@
   return conflicted;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSNumber *underlineStyle = (NSNumber *)value;
-  return underlineStyle != nullptr && [underlineStyle intValue] != NSUnderlineStyleNone && ![self underlinedLinkConflictsInRange:range] && ![self underlinedMentionConflictsInRange:range];
+  return underlineStyle != nullptr &&
+         [underlineStyle intValue] != NSUnderlineStyleNone &&
+         ![self underlinedLinkConflictsInRange:range] &&
+         ![self underlinedMentionConflictsInRange:range];
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSUnderlineStyleAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSUnderlineStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSUnderlineStyleAttributeName withInput:_input atIndex:range.location checkPrevious:NO
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSUnderlineStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:NO
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSUnderlineStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSUnderlineStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSUnderlineStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSUnderlineStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/styles/UnorderedListStyle.mm b/node_modules/react-native-enriched/ios/styles/UnorderedListStyle.mm
index c550b5e..9fb2f7b 100644
--- a/node_modules/react-native-enriched/ios/styles/UnorderedListStyle.mm
+++ b/node_modules/react-native-enriched/ios/styles/UnorderedListStyle.mm
@@ -1,20 +1,27 @@
-#import "StyleHeaders.h"
 #import "EnrichedTextInputView.h"
 #import "FontExtension.h"
 #import "OccurenceUtils.h"
 #import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
 
 @implementation UnorderedListStyle {
   EnrichedTextInputView *_input;
 }
 
-+ (StyleType)getStyleType { return UnorderedList; }
++ (StyleType)getStyleType {
+  return UnorderedList;
+}
+
++ (BOOL)isParagraphStyle {
+  return YES;
+}
 
 - (CGFloat)getHeadIndent {
   // lists are drawn manually
   // margin before bullet + gap between bullet and paragraph
-  return [_input->config unorderedListMarginLeft] + [_input->config unorderedListGapWidth];
+  return [_input->config unorderedListMarginLeft] +
+         [_input->config unorderedListGapWidth];
 }
 
 - (instancetype)initWithInput:(id)input {
@@ -25,18 +32,23 @@
 
 - (void)applyStyle:(NSRange)range {
   BOOL isStylePresent = [self detectStyle:range];
-  if(range.length >= 1) {
-    isStylePresent ? [self removeAttributes:range] : [self addAttributes:range];
+  if (range.length >= 1) {
+    isStylePresent ? [self removeAttributes:range]
+                   : [self addAttributes:range withTypingAttr:YES];
   } else {
     isStylePresent ? [self removeTypingAttributes] : [self addTypingAttributes];
   }
 }
 
 // we assume correct paragraph range is already given
-- (void)addAttributes:(NSRange)range {
-  NSTextList *bullet = [[NSTextList alloc] initWithMarkerFormat:NSTextListMarkerDisc options:0];
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
-  // if we fill empty lines with zero width spaces, we need to offset later ranges
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr {
+  NSTextList *bullet =
+      [[NSTextList alloc] initWithMarkerFormat:NSTextListMarkerDisc options:0];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
+  // if we fill empty lines with zero width spaces, we need to offset later
+  // ranges
   NSInteger offset = 0;
   // needed for range adjustments
   NSRange preModificationRange = _input->textView.selectedRange;
@@ -44,80 +56,111 @@
   // let's not emit some weird selection changes or text/html changes
   _input->blockEmitting = YES;
 
-  for(NSValue *value in paragraphs) {
+  for (NSValue *value in paragraphs) {
     // take previous offsets into consideration
-    NSRange fixedRange = NSMakeRange([value rangeValue].location + offset, [value rangeValue].length);
-    
-    // length 0 with first line, length 1 and newline with some empty lines in the middle
-    if(fixedRange.length == 0 ||
-      (fixedRange.length == 1 &&
-      [[NSCharacterSet newlineCharacterSet] characterIsMember: [_input->textView.textStorage.string characterAtIndex:fixedRange.location]])
-    ) {
-      [TextInsertionUtils insertText:@"\u200B" at:fixedRange.location additionalAttributes:nullptr input:_input withSelection:NO];
+    NSRange fixedRange = NSMakeRange([value rangeValue].location + offset,
+                                     [value rangeValue].length);
+
+    // length 0 with first line, length 1 and newline with some empty lines in
+    // the middle
+    if (fixedRange.length == 0 ||
+        (fixedRange.length == 1 &&
+         [[NSCharacterSet newlineCharacterSet]
+             characterIsMember:[_input->textView.textStorage.string
+                                   characterAtIndex:fixedRange.location]])) {
+      [TextInsertionUtils insertText:@"\u200B"
+                                  at:fixedRange.location
+                additionalAttributes:nullptr
+                               input:_input
+                       withSelection:NO];
       fixedRange = NSMakeRange(fixedRange.location, fixedRange.length + 1);
       offset += 1;
     }
 
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:fixedRange options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.textLists = @[bullet];
-        pStyle.headIndent = [self getHeadIndent];
-        pStyle.firstLineHeadIndent = [self getHeadIndent];
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:fixedRange
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[ bullet ];
+                  pStyle.headIndent = [self getHeadIndent];
+                  pStyle.firstLineHeadIndent = [self getHeadIndent];
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   // back to emitting
   _input->blockEmitting = NO;
 
-  if(preModificationRange.length == 0) {
-    // fix selection if only one line was possibly made a list and filled with a space
+  if (preModificationRange.length == 0) {
+    // fix selection if only one line was possibly made a list and filled with a
+    // space
     _input->textView.selectedRange = preModificationRange;
   } else {
     // in other cases, fix the selection with newly made offsets
-    _input->textView.selectedRange = NSMakeRange(preModificationRange.location, preModificationRange.length + offset);
+    _input->textView.selectedRange = NSMakeRange(
+        preModificationRange.location, preModificationRange.length + offset);
   }
 
   // also add typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
-  pStyle.textLists = @[bullet];
-  pStyle.headIndent = [self getHeadIndent];
-  pStyle.firstLineHeadIndent = [self getHeadIndent];
-  typingAttrs[NSParagraphStyleAttributeName] = pStyle;
-  _input->textView.typingAttributes = typingAttrs;
+  if (withTypingAttr) {
+    NSMutableDictionary *typingAttrs =
+        [_input->textView.typingAttributes mutableCopy];
+    NSMutableParagraphStyle *pStyle =
+        [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+    pStyle.textLists = @[ bullet ];
+    pStyle.headIndent = [self getHeadIndent];
+    pStyle.firstLineHeadIndent = [self getHeadIndent];
+    typingAttrs[NSParagraphStyleAttributeName] = pStyle;
+    _input->textView.typingAttributes = typingAttrs;
+  }
 }
 
 // does pretty much the same as normal addAttributes, just need to get the range
 - (void)addTypingAttributes {
-  [self addAttributes:_input->textView.selectedRange];
+  [self addAttributes:_input->textView.selectedRange withTypingAttr:YES];
 }
 
 - (void)removeAttributes:(NSRange)range {
-  NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView range:range];
+  NSArray *paragraphs =
+      [ParagraphsUtils getSeparateParagraphsRangesIn:_input->textView
+                                               range:range];
 
   [_input->textView.textStorage beginEditing];
 
-  for(NSValue *value in paragraphs) {
+  for (NSValue *value in paragraphs) {
     NSRange range = [value rangeValue];
-    [_input->textView.textStorage enumerateAttribute:NSParagraphStyleAttributeName inRange:range options:0
-      usingBlock:^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        NSMutableParagraphStyle *pStyle = [(NSParagraphStyle *)value mutableCopy];
-        pStyle.textLists = @[];
-        pStyle.headIndent = 0;
-        pStyle.firstLineHeadIndent = 0;
-        [_input->textView.textStorage addAttribute:NSParagraphStyleAttributeName value:pStyle range:range];
-      }
-    ];
+    [_input->textView.textStorage
+        enumerateAttribute:NSParagraphStyleAttributeName
+                   inRange:range
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  NSMutableParagraphStyle *pStyle =
+                      [(NSParagraphStyle *)value mutableCopy];
+                  pStyle.textLists = @[];
+                  pStyle.headIndent = 0;
+                  pStyle.firstLineHeadIndent = 0;
+                  [_input->textView.textStorage
+                      addAttribute:NSParagraphStyleAttributeName
+                             value:pStyle
+                             range:range];
+                }];
   }
 
   [_input->textView.textStorage endEditing];
 
   // also remove typing attributes
-  NSMutableDictionary *typingAttrs = [_input->textView.typingAttributes mutableCopy];
-  NSMutableParagraphStyle *pStyle = [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
+  NSMutableDictionary *typingAttrs =
+      [_input->textView.typingAttributes mutableCopy];
+  NSMutableParagraphStyle *pStyle =
+      [typingAttrs[NSParagraphStyleAttributeName] mutableCopy];
   pStyle.textLists = @[];
   pStyle.headIndent = 0;
   pStyle.firstLineHeadIndent = 0;
@@ -125,24 +168,28 @@
   _input->textView.typingAttributes = typingAttrs;
 }
 
-// needed for the sake of style conflicts, needs to do exactly the same as removeAttribtues
+// needed for the sake of style conflicts, needs to do exactly the same as
+// removeAttribtues
 - (void)removeTypingAttributes {
   [self removeAttributes:_input->textView.selectedRange];
 }
 
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text {
-  if([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
+  if ([self detectStyle:_input->textView.selectedRange] && text.length == 0) {
     // backspace while the style is active
 
-    NSRange paragraphRange = [_input->textView.textStorage.string paragraphRangeForRange:_input->textView.selectedRange];
+    NSRange paragraphRange = [_input->textView.textStorage.string
+        paragraphRangeForRange:_input->textView.selectedRange];
 
-    if(NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
+    if (NSEqualRanges(_input->textView.selectedRange, NSMakeRange(0, 0))) {
       // a backspace on the very first input's line list point
-      // it doesn't run textVieDidChange so we need to manually remove attributes
+      // it doesn't run textVieDidChange so we need to manually remove
+      // attributes
       [self removeAttributes:paragraphRange];
       return YES;
-    } else if(range.location == paragraphRange.location - 1) {
-      // same case in other lines; here, the removed range location will be exactly 1 less than paragraph range location
+    } else if (range.location == paragraphRange.location - 1) {
+      // same case in other lines; here, the removed range location will be
+      // exactly 1 less than paragraph range location
       [self removeAttributes:paragraphRange];
       return YES;
     }
@@ -150,24 +197,36 @@
   return NO;
 }
 
-- (BOOL)tryHandlingListShorcutInRange:(NSRange)range replacementText:(NSString *)text {
-  NSRange paragraphRange = [_input->textView.textStorage.string paragraphRangeForRange:range];
-  // space was added - check if we are both at the paragraph beginning + 1 character (which we want to be a dash)
-  if([text isEqualToString:@" "] && range.location - 1 == paragraphRange.location) {
-    unichar charBefore = [_input->textView.textStorage.string characterAtIndex:range.location - 1];
-    if(charBefore == '-') {
+- (BOOL)tryHandlingListShorcutInRange:(NSRange)range
+                      replacementText:(NSString *)text {
+  NSRange paragraphRange =
+      [_input->textView.textStorage.string paragraphRangeForRange:range];
+  // space was added - check if we are both at the paragraph beginning + 1
+  // character (which we want to be a dash)
+  if ([text isEqualToString:@" "] &&
+      range.location - 1 == paragraphRange.location) {
+    unichar charBefore = [_input->textView.textStorage.string
+        characterAtIndex:range.location - 1];
+    if (charBefore == '-') {
       // we got a match - add a list if possible
-      if([_input handleStyleBlocksAndConflicts:[[self class] getStyleType] range:paragraphRange]) {
+      if ([_input handleStyleBlocksAndConflicts:[[self class] getStyleType]
+                                          range:paragraphRange]) {
         // don't emit during the replacing
         _input->blockEmitting = YES;
 
         // remove the dash
-        [TextInsertionUtils replaceText:@"" at:NSMakeRange(paragraphRange.location, 1) additionalAttributes:nullptr input:_input withSelection:YES];
+        [TextInsertionUtils replaceText:@""
+                                     at:NSMakeRange(paragraphRange.location, 1)
+                   additionalAttributes:nullptr
+                                  input:_input
+                          withSelection:YES];
 
         _input->blockEmitting = NO;
 
         // add attributes on the dashless paragraph
-        [self addAttributes:NSMakeRange(paragraphRange.location, paragraphRange.length - 1)];
+        [self addAttributes:NSMakeRange(paragraphRange.location,
+                                        paragraphRange.length - 1)
+             withTypingAttr:YES];
         return YES;
       }
     }
@@ -175,41 +234,47 @@
   return NO;
 }
 
-- (BOOL)styleCondition:(id _Nullable)value :(NSRange)range {
+- (BOOL)styleCondition:(id _Nullable)value:(NSRange)range {
   NSParagraphStyle *paragraph = (NSParagraphStyle *)value;
-  return paragraph != nullptr && paragraph.textLists.count == 1 && paragraph.textLists.firstObject.markerFormat == NSTextListMarkerDisc;
+  return paragraph != nullptr && paragraph.textLists.count == 1 &&
+         paragraph.textLists.firstObject.markerFormat == NSTextListMarkerDisc;
 }
 
 - (BOOL)detectStyle:(NSRange)range {
-  if(range.length >= 1) {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input inRange:range
-      withCondition: ^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+  if (range.length >= 1) {
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          inRange:range
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   } else {
-    return [OccurenceUtils detect:NSParagraphStyleAttributeName withInput:_input atIndex:range.location checkPrevious:YES
-      withCondition:^BOOL(id  _Nullable value, NSRange range) {
-        return [self styleCondition:value :range];
-      }
-    ];
+    return [OccurenceUtils detect:NSParagraphStyleAttributeName
+                        withInput:_input
+                          atIndex:range.location
+                    checkPrevious:YES
+                    withCondition:^BOOL(id _Nullable value, NSRange range) {
+                      return [self styleCondition:value:range];
+                    }];
   }
 }
 
 - (BOOL)anyOccurence:(NSRange)range {
-  return [OccurenceUtils any:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils any:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 - (NSArray<StylePair *> *_Nullable)findAllOccurences:(NSRange)range {
-  return [OccurenceUtils all:NSParagraphStyleAttributeName withInput:_input inRange:range
-    withCondition:^BOOL(id  _Nullable value, NSRange range) {
-      return [self styleCondition:value :range];
-    }
-  ];
+  return [OccurenceUtils all:NSParagraphStyleAttributeName
+                   withInput:_input
+                     inRange:range
+               withCondition:^BOOL(id _Nullable value, NSRange range) {
+                 return [self styleCondition:value:range];
+               }];
 }
 
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/BaseStyleProtocol.h b/node_modules/react-native-enriched/ios/utils/BaseStyleProtocol.h
index 82e5988..5e08e55 100644
--- a/node_modules/react-native-enriched/ios/utils/BaseStyleProtocol.h
+++ b/node_modules/react-native-enriched/ios/utils/BaseStyleProtocol.h
@@ -1,12 +1,13 @@
 #pragma once
-#import "StyleTypeEnum.h"
 #import "StylePair.h"
+#import "StyleTypeEnum.h"
 
 @protocol BaseStyleProtocol <NSObject>
 + (StyleType)getStyleType;
++ (BOOL)isParagraphStyle;
 - (instancetype _Nonnull)initWithInput:(id _Nonnull)input;
 - (void)applyStyle:(NSRange)range;
-- (void)addAttributes:(NSRange)range;
+- (void)addAttributes:(NSRange)range withTypingAttr:(BOOL)withTypingAttr;
 - (void)removeAttributes:(NSRange)range;
 - (void)addTypingAttributes;
 - (void)removeTypingAttributes;
diff --git a/node_modules/react-native-enriched/ios/utils/ColorExtension.mm b/node_modules/react-native-enriched/ios/utils/ColorExtension.mm
index cc57014..0cc59b7 100644
--- a/node_modules/react-native-enriched/ios/utils/ColorExtension.mm
+++ b/node_modules/react-native-enriched/ios/utils/ColorExtension.mm
@@ -4,11 +4,13 @@
 - (BOOL)isEqualToColor:(UIColor *)otherColor {
   CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();
 
-  UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {
-    if(CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {
+  UIColor * (^convertColorToRGBSpace)(UIColor *) = ^(UIColor *color) {
+    if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) ==
+        kCGColorSpaceModelMonochrome) {
       const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);
-      CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};
-      CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );
+      CGFloat components[4] = {oldComponents[0], oldComponents[0],
+                               oldComponents[0], oldComponents[1]};
+      CGColorRef colorRef = CGColorCreate(colorSpaceRGB, components);
 
       UIColor *color = [UIColor colorWithCGColor:colorRef];
       CGColorRelease(colorRef);
@@ -29,7 +31,7 @@
   CGFloat alpha = 0.0;
   [self getRed:nil green:nil blue:nil alpha:&alpha];
   if (alpha > 0.0) {
-      return [self colorWithAlphaComponent:newAlpha];
+    return [self colorWithAlphaComponent:newAlpha];
   }
   return self;
 }
diff --git a/node_modules/react-native-enriched/ios/utils/FontExtension.mm b/node_modules/react-native-enriched/ios/utils/FontExtension.mm
index 3a664e5..b90069c 100644
--- a/node_modules/react-native-enriched/ios/utils/FontExtension.mm
+++ b/node_modules/react-native-enriched/ios/utils/FontExtension.mm
@@ -4,16 +4,19 @@
 @implementation UIFont (FontExtension)
 
 - (BOOL)isBold {
-  return (self.fontDescriptor.symbolicTraits & UIFontDescriptorTraitBold) == UIFontDescriptorTraitBold;
+  return (self.fontDescriptor.symbolicTraits & UIFontDescriptorTraitBold) ==
+         UIFontDescriptorTraitBold;
 }
 
 - (UIFont *)setBold {
-  if([self isBold]) {
+  if ([self isBold]) {
     return self;
   }
-  UIFontDescriptorSymbolicTraits newTraits = (self.fontDescriptor.symbolicTraits | UIFontDescriptorTraitBold);
-  UIFontDescriptor *fontDescriptor = [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
-  if(fontDescriptor != nullptr) {
+  UIFontDescriptorSymbolicTraits newTraits =
+      (self.fontDescriptor.symbolicTraits | UIFontDescriptorTraitBold);
+  UIFontDescriptor *fontDescriptor =
+      [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
+  if (fontDescriptor != nullptr) {
     return [UIFont fontWithDescriptor:fontDescriptor size:0];
   } else {
     RCTLogWarn(@"[EnrichedTextInput]: Couldn't apply bold trait to the font.");
@@ -22,68 +25,80 @@
 }
 
 - (UIFont *)removeBold {
-  if(![self isBold]) {
+  if (![self isBold]) {
     return self;
   }
-  UIFontDescriptorSymbolicTraits newTraits = (self.fontDescriptor.symbolicTraits ^ UIFontDescriptorTraitBold);
-  UIFontDescriptor *fontDescriptor = [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
-  if(fontDescriptor != nullptr) {
+  UIFontDescriptorSymbolicTraits newTraits =
+      (self.fontDescriptor.symbolicTraits ^ UIFontDescriptorTraitBold);
+  UIFontDescriptor *fontDescriptor =
+      [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
+  if (fontDescriptor != nullptr) {
     return [UIFont fontWithDescriptor:fontDescriptor size:0];
   } else {
-    RCTLogWarn(@"[EnrichedTextInput]: Couldn't remove bold trait from the font.");
+    RCTLogWarn(
+        @"[EnrichedTextInput]: Couldn't remove bold trait from the font.");
     return self;
   }
 }
 
 - (BOOL)isItalic {
-  return (self.fontDescriptor.symbolicTraits & UIFontDescriptorTraitItalic) == UIFontDescriptorTraitItalic;
+  return (self.fontDescriptor.symbolicTraits & UIFontDescriptorTraitItalic) ==
+         UIFontDescriptorTraitItalic;
 }
 
 - (UIFont *)setItalic {
-  if([self isItalic]) {
+  if ([self isItalic]) {
     return self;
   }
-  UIFontDescriptorSymbolicTraits newTraits = (self.fontDescriptor.symbolicTraits | UIFontDescriptorTraitItalic);
-  UIFontDescriptor *fontDescriptor = [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
-  if(fontDescriptor != nullptr) {
+  UIFontDescriptorSymbolicTraits newTraits =
+      (self.fontDescriptor.symbolicTraits | UIFontDescriptorTraitItalic);
+  UIFontDescriptor *fontDescriptor =
+      [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
+  if (fontDescriptor != nullptr) {
     return [UIFont fontWithDescriptor:fontDescriptor size:0];
   } else {
-    RCTLogWarn(@"[EnrichedTextInput]: Couldn't apply italic trait to the font.");
+    RCTLogWarn(
+        @"[EnrichedTextInput]: Couldn't apply italic trait to the font.");
     return self;
   }
 }
 
 - (UIFont *)removeItalic {
-  if(![self isItalic]) {
+  if (![self isItalic]) {
     return self;
   }
-  UIFontDescriptorSymbolicTraits newTraits = (self.fontDescriptor.symbolicTraits ^ UIFontDescriptorTraitItalic);
-  UIFontDescriptor *fontDescriptor = [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
-  if(fontDescriptor != nullptr) {
+  UIFontDescriptorSymbolicTraits newTraits =
+      (self.fontDescriptor.symbolicTraits ^ UIFontDescriptorTraitItalic);
+  UIFontDescriptor *fontDescriptor =
+      [self.fontDescriptor fontDescriptorWithSymbolicTraits:newTraits];
+  if (fontDescriptor != nullptr) {
     return [UIFont fontWithDescriptor:fontDescriptor size:0];
   } else {
-    RCTLogWarn(@"[EnrichedTextInput]: Couldn't remove italic trait from the font.");
+    RCTLogWarn(
+        @"[EnrichedTextInput]: Couldn't remove italic trait from the font.");
     return self;
   }
 }
 
 - (UIFont *)withFontTraits:(UIFont *)from {
-  UIFont* newFont = self;
-  if([from isBold]) {
+  UIFont *newFont = self;
+  if ([from isBold]) {
     newFont = [newFont setBold];
   }
-  if([from isItalic]) {
+  if ([from isItalic]) {
     newFont = [newFont setItalic];
   }
   return newFont;
 }
 
 - (UIFont *)setSize:(CGFloat)size {
-  UIFontDescriptor *newFontDescriptor = [self.fontDescriptor fontDescriptorWithSize:size];
-  if(newFontDescriptor != nullptr) {
+  UIFontDescriptor *newFontDescriptor =
+      [self.fontDescriptor fontDescriptorWithSize:size];
+  if (newFontDescriptor != nullptr) {
     return [UIFont fontWithDescriptor:newFontDescriptor size:0];
   } else {
-    RCTLogWarn(@"[EnrichedTextInput]: Couldn't apply heading style to the font.");
+    RCTLogWarn(
+        @"[EnrichedTextInput]: Couldn't apply heading style to the font.");
     return self;
   }
 }
diff --git a/node_modules/react-native-enriched/ios/utils/ImageData.h b/node_modules/react-native-enriched/ios/utils/ImageData.h
new file mode 100644
index 0000000..266ec62
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/utils/ImageData.h
@@ -0,0 +1,10 @@
+#pragma once
+#import <UIKit/UIKit.h>
+
+@interface ImageData : NSObject
+
+@property NSString *uri;
+@property CGFloat width;
+@property CGFloat height;
+
+@end
diff --git a/node_modules/react-native-enriched/ios/utils/ImageData.mm b/node_modules/react-native-enriched/ios/utils/ImageData.mm
new file mode 100644
index 0000000..e5a6d61
--- /dev/null
+++ b/node_modules/react-native-enriched/ios/utils/ImageData.mm
@@ -0,0 +1,4 @@
+#import "ImageData.h"
+
+@implementation ImageData
+@end
diff --git a/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.h b/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.h
index 6f54c6c..e8e217a 100644
--- a/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.h
+++ b/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.h
@@ -2,5 +2,5 @@
 #import <UIKit/UIKit.h>
 
 @interface NSLayoutManager (LayoutManagerExtension)
-@property (nonatomic, weak) id input;
+@property(nonatomic, weak) id input;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.mm b/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.mm
index 26a9cbc..2b011bd 100644
--- a/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.mm
+++ b/node_modules/react-native-enriched/ios/utils/LayoutManagerExtension.mm
@@ -1,8 +1,9 @@
 #import "LayoutManagerExtension.h"
-#import <objc/runtime.h>
+#import "ColorExtension.h"
 #import "EnrichedTextInputView.h"
-#import "StyleHeaders.h"
 #import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
+#import <objc/runtime.h>
 
 @implementation NSLayoutManager (LayoutManagerExtension)
 
@@ -13,12 +14,8 @@ static void const *kInputKey = &kInputKey;
 }
 
 - (void)setInput:(id)value {
-  objc_setAssociatedObject(
-    self,
-    kInputKey,
-    value,
-    OBJC_ASSOCIATION_RETAIN_NONATOMIC
-  );
+  objc_setAssociatedObject(self, kInputKey, value,
+                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 }
 
 + (void)load {
@@ -30,127 +27,355 @@ static void const *kInputKey = &kInputKey;
     Method originalMethod = class_getInstanceMethod(myClass, originalSelector);
     Method swizzledMethod = class_getInstanceMethod(myClass, swizzledSelector);
 
-    BOOL didAddMethod = class_addMethod(myClass, originalSelector,
-      method_getImplementation(swizzledMethod),
-      method_getTypeEncoding(swizzledMethod)
-    );
+    BOOL didAddMethod = class_addMethod(
+        myClass, originalSelector, method_getImplementation(swizzledMethod),
+        method_getTypeEncoding(swizzledMethod));
 
-    if(didAddMethod) {
+    if (didAddMethod) {
       class_replaceMethod(myClass, swizzledSelector,
-        method_getImplementation(originalMethod),
-        method_getTypeEncoding(originalMethod)
-      );
+                          method_getImplementation(originalMethod),
+                          method_getTypeEncoding(originalMethod));
     } else {
       method_exchangeImplementations(originalMethod, swizzledMethod);
     }
   });
 }
 
-- (void)my_drawBackgroundForGlyphRange:(NSRange)glyphRange atPoint:(CGPoint)origin {
+- (void)my_drawBackgroundForGlyphRange:(NSRange)glyphRange
+                               atPoint:(CGPoint)origin {
   [self my_drawBackgroundForGlyphRange:glyphRange atPoint:origin];
 
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)self.input;
-  if(typedInput == nullptr) { return; }
-  
-  BlockQuoteStyle *bqStyle = typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
-  if(bqStyle == nullptr) { return; }
-  
-  NSRange inputRange = NSMakeRange(0, typedInput->textView.textStorage.length);
-  
-  // it isn't the most performant but we have to check for all the blockquotes each time and redraw them
-  NSArray *allBlockquotes = [bqStyle findAllOccurences:inputRange];
-  
-  for(StylePair *pair in allBlockquotes) {
-    NSRange paragraphRange = [typedInput->textView.textStorage.string paragraphRangeForRange:[pair.rangeValue rangeValue]];
-    NSRange paragraphGlyphRange = [self glyphRangeForCharacterRange:paragraphRange actualCharacterRange:nullptr];
-    [self enumerateLineFragmentsForGlyphRange:paragraphGlyphRange
-      usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer * _Nonnull textContainer, NSRange glyphRange, BOOL * _Nonnull stop) {
-        CGFloat paddingLeft = origin.x;
-        CGFloat paddingTop = origin.y;
-        CGFloat x = paddingLeft;
-        CGFloat y = paddingTop + rect.origin.y;
-        CGFloat width = [typedInput->config blockquoteBorderWidth];
-        CGFloat height = rect.size.height;
-        
-        CGRect lineRect = CGRectMake(x, y, width, height);
-        [[typedInput->config blockquoteBorderColor] setFill];
-        UIRectFill(lineRect);
-      }
-    ];
+  if (typedInput == nullptr) {
+    return;
   }
 
-  UnorderedListStyle *ulStyle = typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
-  OrderedListStyle *olStyle = typedInput->stylesDict[@([OrderedListStyle getStyleType])];
-  if(ulStyle == nullptr || olStyle == nullptr) { return; }
+  NSRange visibleCharRange = [self characterRangeForGlyphRange:glyphRange
+                                              actualGlyphRange:NULL];
+
+  [self drawBlockQuotes:typedInput
+                 origin:origin
+       visibleCharRange:visibleCharRange];
+  [self drawLists:typedInput origin:origin visibleCharRange:visibleCharRange];
+  [self drawCodeBlocks:typedInput
+                origin:origin
+      visibleCharRange:visibleCharRange];
+}
+
+- (void)drawCodeBlocks:(EnrichedTextInputView *)typedInput
+                origin:(CGPoint)origin
+      visibleCharRange:(NSRange)visibleCharRange {
+  CodeBlockStyle *codeBlockStyle =
+      typedInput->stylesDict[@([CodeBlockStyle getStyleType])];
+  if (codeBlockStyle == nullptr) {
+    return;
+  }
+
+  NSArray<StylePair *> *allCodeBlocks =
+      [codeBlockStyle findAllOccurences:visibleCharRange];
+  NSArray<StylePair *> *mergedCodeBlocks =
+      [self mergeContiguousStylePairs:allCodeBlocks];
+  UIColor *bgColor = [[typedInput->config codeBlockBgColor]
+      colorWithAlphaIfNotTransparent:0.4];
+  CGFloat radius = [typedInput->config codeBlockBorderRadius];
+  [bgColor setFill];
+
+  for (StylePair *pair in mergedCodeBlocks) {
+    NSRange blockCharacterRange = [pair.rangeValue rangeValue];
+    if (blockCharacterRange.length == 0)
+      continue;
+
+    NSArray *paragraphs =
+        [ParagraphsUtils getSeparateParagraphsRangesIn:typedInput->textView
+                                                 range:blockCharacterRange];
+    if (paragraphs.count == 0)
+      continue;
+
+    NSRange firstParagraphRange =
+        [((NSValue *)[paragraphs firstObject]) rangeValue];
+    NSRange lastParagraphRange =
+        [((NSValue *)[paragraphs lastObject]) rangeValue];
+
+    for (NSValue *paragraphValue in paragraphs) {
+      NSRange paragraphCharacterRange = [paragraphValue rangeValue];
+
+      BOOL isFirstParagraph =
+          NSEqualRanges(paragraphCharacterRange, firstParagraphRange);
+      BOOL isLastParagraph =
+          NSEqualRanges(paragraphCharacterRange, lastParagraphRange);
+
+      NSRange paragraphGlyphRange =
+          [self glyphRangeForCharacterRange:paragraphCharacterRange
+                       actualCharacterRange:NULL];
+
+      __block BOOL isFirstLineOfParagraph = YES;
+
+      [self
+          enumerateLineFragmentsForGlyphRange:paragraphGlyphRange
+                                   usingBlock:^(
+                                       CGRect rect, CGRect usedRect,
+                                       NSTextContainer *_Nonnull textContainer,
+                                       NSRange glyphRange,
+                                       BOOL *_Nonnull stop) {
+                                     CGRect lineBgRect = rect;
+                                     lineBgRect.origin.x = origin.x;
+                                     lineBgRect.origin.y += origin.y;
+                                     lineBgRect.size.width =
+                                         textContainer.size.width;
+
+                                     UIRectCorner cornersForThisLine = 0;
+
+                                     if (isFirstParagraph &&
+                                         isFirstLineOfParagraph) {
+                                       cornersForThisLine =
+                                           UIRectCornerTopLeft |
+                                           UIRectCornerTopRight;
+                                     }
+
+                                     BOOL isLastLineOfParagraph =
+                                         (NSMaxRange(glyphRange) >=
+                                          NSMaxRange(paragraphGlyphRange));
+
+                                     if (isLastParagraph &&
+                                         isLastLineOfParagraph) {
+                                       cornersForThisLine =
+                                           cornersForThisLine |
+                                           UIRectCornerBottomLeft |
+                                           UIRectCornerBottomRight;
+                                     }
+
+                                     UIBezierPath *path = [UIBezierPath
+                                         bezierPathWithRoundedRect:lineBgRect
+                                                 byRoundingCorners:
+                                                     cornersForThisLine
+                                                       cornerRadii:CGSizeMake(
+                                                                       radius,
+                                                                       radius)];
+                                     [path fill];
+
+                                     isFirstLineOfParagraph = NO;
+                                   }];
+    }
+  }
+}
+
+- (NSArray<StylePair *> *)mergeContiguousStylePairs:
+    (NSArray<StylePair *> *)pairs {
+  if (pairs.count == 0) {
+    return @[];
+  }
+
+  NSMutableArray<StylePair *> *mergedPairs = [[NSMutableArray alloc] init];
+  StylePair *currentPair = pairs[0];
+  NSRange currentRange = [currentPair.rangeValue rangeValue];
+  for (NSUInteger i = 1; i < pairs.count; i++) {
+    StylePair *nextPair = pairs[i];
+    NSRange nextRange = [nextPair.rangeValue rangeValue];
+
+    // The Gap Check:
+    // NSMaxRange(currentRange) is where the current block ends.
+    // nextRange.location is where the next block starts.
+    if (NSMaxRange(currentRange) == nextRange.location) {
+      // They touch perfectly (no gap). Merge them.
+      currentRange.length += nextRange.length;
+    } else {
+      // There is a gap (indices don't match).
+      // 1. Save the finished block.
+      StylePair *mergedPair = [[StylePair alloc] init];
+      mergedPair.rangeValue = [NSValue valueWithRange:currentRange];
+      mergedPair.styleValue = currentPair.styleValue;
+      [mergedPairs addObject:mergedPair];
+
+      // 2. Start a brand new block.
+      currentPair = nextPair;
+      currentRange = nextRange;
+    }
+  }
+
+  // Add the final block
+  StylePair *lastPair = [[StylePair alloc] init];
+  lastPair.rangeValue = [NSValue valueWithRange:currentRange];
+  lastPair.styleValue = currentPair.styleValue;
+  [mergedPairs addObject:lastPair];
+
+  return mergedPairs;
+}
+
+- (void)drawBlockQuotes:(EnrichedTextInputView *)typedInput
+                 origin:(CGPoint)origin
+       visibleCharRange:(NSRange)visibleCharRange {
+  BlockQuoteStyle *bqStyle =
+      typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
+  if (bqStyle == nullptr) {
+    return;
+  }
+
+  NSArray *allBlockquotes = [bqStyle findAllOccurences:visibleCharRange];
+
+  for (StylePair *pair in allBlockquotes) {
+    NSRange paragraphRange = [typedInput->textView.textStorage.string
+        paragraphRangeForRange:[pair.rangeValue rangeValue]];
+    NSRange paragraphGlyphRange =
+        [self glyphRangeForCharacterRange:paragraphRange
+                     actualCharacterRange:nullptr];
+    [self
+        enumerateLineFragmentsForGlyphRange:paragraphGlyphRange
+                                 usingBlock:^(
+                                     CGRect rect, CGRect usedRect,
+                                     NSTextContainer *_Nonnull textContainer,
+                                     NSRange glyphRange, BOOL *_Nonnull stop) {
+                                   CGFloat paddingLeft = origin.x;
+                                   CGFloat paddingTop = origin.y;
+                                   CGFloat x = paddingLeft;
+                                   CGFloat y = paddingTop + rect.origin.y;
+                                   CGFloat width =
+                                       [typedInput
+                                               ->config blockquoteBorderWidth];
+                                   CGFloat height = rect.size.height;
+
+                                   CGRect lineRect =
+                                       CGRectMake(x, y, width, height);
+                                   [[typedInput->config blockquoteBorderColor]
+                                       setFill];
+                                   UIRectFill(lineRect);
+                                 }];
+  }
+}
+
+- (void)drawLists:(EnrichedTextInputView *)typedInput
+              origin:(CGPoint)origin
+    visibleCharRange:(NSRange)visibleCharRange {
+  UnorderedListStyle *ulStyle =
+      typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
+  OrderedListStyle *olStyle =
+      typedInput->stylesDict[@([OrderedListStyle getStyleType])];
+  if (ulStyle == nullptr || olStyle == nullptr) {
+    return;
+  }
 
-  // also not the most performant but we redraw all the lists
   NSMutableArray *allLists = [[NSMutableArray alloc] init];
-  [allLists addObjectsFromArray:[ulStyle findAllOccurences:inputRange]];
-  [allLists addObjectsFromArray:[olStyle findAllOccurences:inputRange]];
+  [allLists addObjectsFromArray:[ulStyle findAllOccurences:visibleCharRange]];
+  [allLists addObjectsFromArray:[olStyle findAllOccurences:visibleCharRange]];
 
-  for(StylePair *pair in allLists) {
+  for (StylePair *pair in allLists) {
     NSParagraphStyle *pStyle = (NSParagraphStyle *)pair.styleValue;
     NSDictionary *markerAttributes = @{
-      NSFontAttributeName: [typedInput->config orderedListMarkerFont],
-      NSForegroundColorAttributeName: [typedInput->config orderedListMarkerColor]
+      NSFontAttributeName : [typedInput->config orderedListMarkerFont],
+      NSForegroundColorAttributeName :
+          [typedInput->config orderedListMarkerColor]
     };
 
-    NSArray *paragraphs = [ParagraphsUtils getSeparateParagraphsRangesIn:typedInput->textView range:[pair.rangeValue rangeValue]];
+    NSArray *paragraphs = [ParagraphsUtils
+        getSeparateParagraphsRangesIn:typedInput->textView
+                                range:[pair.rangeValue rangeValue]];
 
-    for(NSValue *paragraph in paragraphs) {
-      NSRange paragraphGlyphRange = [self glyphRangeForCharacterRange:[paragraph rangeValue] actualCharacterRange:nullptr];
+    for (NSValue *paragraph in paragraphs) {
+      NSRange paragraphGlyphRange =
+          [self glyphRangeForCharacterRange:[paragraph rangeValue]
+                       actualCharacterRange:nullptr];
 
-      [self enumerateLineFragmentsForGlyphRange:paragraphGlyphRange
-        usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer *container, NSRange lineGlyphRange, BOOL *stop) {
-          NSString *marker = [self markerForList:pStyle.textLists.firstObject charIndex:[self characterIndexForGlyphAtIndex:lineGlyphRange.location] input:typedInput];
+      [self
+          enumerateLineFragmentsForGlyphRange:paragraphGlyphRange
+                                   usingBlock:^(CGRect rect, CGRect usedRect,
+                                                NSTextContainer *container,
+                                                NSRange lineGlyphRange,
+                                                BOOL *stop) {
+                                     NSString *marker = [self
+                                         markerForList:pStyle.textLists
+                                                           .firstObject
+                                             charIndex:
+                                                 [self
+                                                     characterIndexForGlyphAtIndex:
+                                                         lineGlyphRange
+                                                             .location]
+                                                 input:typedInput];
 
-          if(pStyle.textLists.firstObject.markerFormat == NSTextListMarkerDecimal) {
-            CGFloat gapWidth = [typedInput->config orderedListGapWidth];
-            CGFloat markerWidth = [marker sizeWithAttributes:markerAttributes].width;
-            CGFloat markerX = usedRect.origin.x - gapWidth - markerWidth/2;
+                                     if (pStyle.textLists.firstObject
+                                             .markerFormat ==
+                                         NSTextListMarkerDecimal) {
+                                       CGFloat gapWidth =
+                                           [typedInput->config
+                                                   orderedListGapWidth];
+                                       CGFloat markerWidth =
+                                           [marker sizeWithAttributes:
+                                                       markerAttributes]
+                                               .width;
+                                       CGFloat markerX = usedRect.origin.x -
+                                                         gapWidth -
+                                                         markerWidth / 2;
 
-            [marker drawAtPoint:CGPointMake(markerX, usedRect.origin.y + origin.y) withAttributes:markerAttributes];
-          } else {
-            CGFloat gapWidth = [typedInput->config unorderedListGapWidth];
-            CGFloat bulletSize = [typedInput->config unorderedListBulletSize];
-            CGFloat bulletX = usedRect.origin.x - gapWidth - bulletSize/2;
-            CGFloat centerY = CGRectGetMidY(usedRect);
-            
-            CGContextRef context = UIGraphicsGetCurrentContext();
-            CGContextSaveGState(context); {
-              [[typedInput->config unorderedListBulletColor] setFill];
-              CGContextAddArc(context, bulletX, centerY, bulletSize/2, 0, 2 * M_PI, YES);
-              CGContextFillPath(context);
-            }
-            CGContextRestoreGState(context);
-          }
-          // only first line of a list gets its marker drawn
-          *stop = YES;
-        }
-      ];
+                                       [marker drawAtPoint:CGPointMake(
+                                                               markerX,
+                                                               usedRect.origin
+                                                                       .y +
+                                                                   origin.y)
+                                            withAttributes:markerAttributes];
+                                     } else {
+                                       CGFloat gapWidth =
+                                           [typedInput->config
+                                                   unorderedListGapWidth];
+                                       CGFloat bulletSize =
+                                           [typedInput->config
+                                                   unorderedListBulletSize];
+                                       CGFloat bulletX = usedRect.origin.x -
+                                                         gapWidth -
+                                                         bulletSize / 2;
+                                       CGFloat centerY =
+                                           CGRectGetMidY(usedRect);
+
+                                       CGContextRef context =
+                                           UIGraphicsGetCurrentContext();
+                                       CGContextSaveGState(context);
+                                       {
+                                         [[typedInput->config
+                                                 unorderedListBulletColor]
+                                             setFill];
+                                         CGContextAddArc(
+                                             context, bulletX, centerY,
+                                             bulletSize / 2, 0, 2 * M_PI, YES);
+                                         CGContextFillPath(context);
+                                       }
+                                       CGContextRestoreGState(context);
+                                     }
+                                     // only first line of a list gets its
+                                     // marker drawn
+                                     *stop = YES;
+                                   }];
     }
   }
 }
 
-- (NSString *)markerForList:(NSTextList *)list charIndex:(NSUInteger)index input:(EnrichedTextInputView *)input {
-  if(list.markerFormat == NSTextListMarkerDecimal) {
+- (NSString *)markerForList:(NSTextList *)list
+                  charIndex:(NSUInteger)index
+                      input:(EnrichedTextInputView *)input {
+  if (list.markerFormat == NSTextListMarkerDecimal) {
     NSString *fullText = input->textView.textStorage.string;
     NSInteger itemNumber = 1;
 
-    NSRange currentParagraph = [fullText paragraphRangeForRange:NSMakeRange(index, 0)];
-    if(currentParagraph.location > 0) {
-      OrderedListStyle *olStyle = input->stylesDict[@([OrderedListStyle getStyleType])];
+    NSRange currentParagraph =
+        [fullText paragraphRangeForRange:NSMakeRange(index, 0)];
+    if (currentParagraph.location > 0) {
+      OrderedListStyle *olStyle =
+          input->stylesDict[@([OrderedListStyle getStyleType])];
 
       NSInteger prevParagraphsCount = 0;
-      NSInteger recentParagraphLocation = [fullText paragraphRangeForRange:NSMakeRange(currentParagraph.location - 1, 0)].location;
+      NSInteger recentParagraphLocation =
+          [fullText
+              paragraphRangeForRange:NSMakeRange(currentParagraph.location - 1,
+                                                 0)]
+              .location;
 
       // seek for previous lists
-      while(true) {
-        if([olStyle detectStyle:NSMakeRange(recentParagraphLocation, 0)]) {
+      while (true) {
+        if ([olStyle detectStyle:NSMakeRange(recentParagraphLocation, 0)]) {
           prevParagraphsCount += 1;
 
-          if(recentParagraphLocation > 0) {
-            recentParagraphLocation = [fullText paragraphRangeForRange:NSMakeRange(recentParagraphLocation - 1, 0)].location;
+          if (recentParagraphLocation > 0) {
+            recentParagraphLocation =
+                [fullText
+                    paragraphRangeForRange:NSMakeRange(
+                                               recentParagraphLocation - 1, 0)]
+                    .location;
           } else {
             break;
           }
diff --git a/node_modules/react-native-enriched/ios/utils/MentionParams.h b/node_modules/react-native-enriched/ios/utils/MentionParams.h
index 7ea7841..698a31d 100644
--- a/node_modules/react-native-enriched/ios/utils/MentionParams.h
+++ b/node_modules/react-native-enriched/ios/utils/MentionParams.h
@@ -6,4 +6,3 @@
 @property NSString *indicator;
 @property NSString *attributes;
 @end
-
diff --git a/node_modules/react-native-enriched/ios/utils/MentionStyleProps.h b/node_modules/react-native-enriched/ios/utils/MentionStyleProps.h
index 7997f4a..d0d59dd 100644
--- a/node_modules/react-native-enriched/ios/utils/MentionStyleProps.h
+++ b/node_modules/react-native-enriched/ios/utils/MentionStyleProps.h
@@ -1,7 +1,7 @@
 #pragma once
-#import <UIKit/UIKit.h>
 #import "TextDecorationLineEnum.h"
 #import "string"
+#import <UIKit/UIKit.h>
 #import <folly/dynamic.h>
 
 @interface MentionStyleProps : NSObject
diff --git a/node_modules/react-native-enriched/ios/utils/MentionStyleProps.mm b/node_modules/react-native-enriched/ios/utils/MentionStyleProps.mm
index da35fc2..4dc933a 100644
--- a/node_modules/react-native-enriched/ios/utils/MentionStyleProps.mm
+++ b/node_modules/react-native-enriched/ios/utils/MentionStyleProps.mm
@@ -1,29 +1,35 @@
 #import "MentionStyleProps.h"
-#import <React/RCTConversions.h>
 #import "StringExtension.h"
+#import <React/RCTConversions.h>
 
 @implementation MentionStyleProps
 
-+ (MentionStyleProps *)getSingleMentionStylePropsFromFollyDynamic:(folly::dynamic)folly {
++ (MentionStyleProps *)getSingleMentionStylePropsFromFollyDynamic:
+    (folly::dynamic)folly {
   MentionStyleProps *nativeProps = [[MentionStyleProps alloc] init];
 
-  if(folly["color"].isNumber()) {
-    facebook::react::SharedColor color = facebook::react::SharedColor(facebook::react::Color(folly["color"].asInt()));
+  if (folly["color"].isNumber()) {
+    facebook::react::SharedColor color = facebook::react::SharedColor(
+        facebook::react::Color(folly["color"].asInt()));
     nativeProps.color = RCTUIColorFromSharedColor(color);
   } else {
     nativeProps.color = [UIColor blueColor];
   }
 
-  if(folly["backgroundColor"].isNumber()) {
-    facebook::react::SharedColor bgColor = facebook::react::SharedColor(facebook::react::Color(folly["backgroundColor"].asInt()));
+  if (folly["backgroundColor"].isNumber()) {
+    facebook::react::SharedColor bgColor = facebook::react::SharedColor(
+        facebook::react::Color(folly["backgroundColor"].asInt()));
     nativeProps.backgroundColor = RCTUIColorFromSharedColor(bgColor);
   } else {
     nativeProps.backgroundColor = [UIColor yellowColor];
   }
 
-  if(folly["textDecorationLine"].isString()) {
+  if (folly["textDecorationLine"].isString()) {
     std::string textDecorationLine = folly["textDecorationLine"].asString();
-    nativeProps.decorationLine = [[NSString fromCppString:textDecorationLine] isEqualToString:DecorationUnderline] ? DecorationUnderline : DecorationNone;
+    nativeProps.decorationLine = [[NSString fromCppString:textDecorationLine]
+                                     isEqualToString:DecorationUnderline]
+                                     ? DecorationUnderline
+                                     : DecorationNone;
   } else {
     nativeProps.decorationLine = DecorationUnderline;
   }
@@ -32,19 +38,21 @@
 }
 
 + (NSDictionary *)getSinglePropsFromFollyDynamic:(folly::dynamic)folly {
-  MentionStyleProps *nativeProps = [MentionStyleProps getSingleMentionStylePropsFromFollyDynamic:folly];
+  MentionStyleProps *nativeProps =
+      [MentionStyleProps getSingleMentionStylePropsFromFollyDynamic:folly];
   // the single props need to be somehow distinguishable in config
-  NSDictionary *dict = @{@"all": nativeProps};
+  NSDictionary *dict = @{@"all" : nativeProps};
   return dict;
 }
 
 + (NSDictionary *)getComplexPropsFromFollyDynamic:(folly::dynamic)folly {
   NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];
 
-  for(const auto& obj: folly.items()) {
-    if(obj.first.isString() && obj.second.isObject()) {
+  for (const auto &obj : folly.items()) {
+    if (obj.first.isString() && obj.second.isObject()) {
       std::string key = obj.first.asString();
-      MentionStyleProps *props = [MentionStyleProps getSingleMentionStylePropsFromFollyDynamic:obj.second];
+      MentionStyleProps *props = [MentionStyleProps
+          getSingleMentionStylePropsFromFollyDynamic:obj.second];
       dict[[NSString fromCppString:key]] = props;
     }
   }
@@ -53,4 +61,3 @@
 }
 
 @end
-
diff --git a/node_modules/react-native-enriched/ios/utils/OccurenceUtils.h b/node_modules/react-native-enriched/ios/utils/OccurenceUtils.h
index 885cb21..83cf12a 100644
--- a/node_modules/react-native-enriched/ios/utils/OccurenceUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/OccurenceUtils.h
@@ -1,43 +1,47 @@
 #pragma once
-#import "StylePair.h"
 #import "EnrichedTextInputView.h"
-
+#import "StylePair.h"
 
 @interface OccurenceUtils : NSObject
-+ (BOOL)detect
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (BOOL)detect
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  atIndex:(NSUInteger)index
-  checkPrevious:(BOOL)check
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (BOOL)detectMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (BOOL)any
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (BOOL)anyMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (NSArray<StylePair *> *_Nullable)all
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
-+ (NSArray<StylePair *> *_Nullable)allMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition;
++ (BOOL)detect:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition;
++ (BOOL)detect:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          atIndex:(NSUInteger)index
+    checkPrevious:(BOOL)check
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition;
++ (BOOL)detectMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+             withInput:(EnrichedTextInputView *_Nonnull)input
+               inRange:(NSRange)range
+         withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                     NSRange range))condition;
++ (BOOL)any:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition;
++ (BOOL)anyMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+          withInput:(EnrichedTextInputView *_Nonnull)input
+            inRange:(NSRange)range
+      withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                  NSRange range))condition;
++ (NSArray<StylePair *> *_Nullable)all:(NSAttributedStringKey _Nonnull)key
+                             withInput:(EnrichedTextInputView *_Nonnull)input
+                               inRange:(NSRange)range
+                         withCondition:(BOOL(NS_NOESCAPE ^
+                                             _Nonnull)(id _Nullable value,
+                                                       NSRange range))condition;
++ (NSArray<StylePair *> *_Nullable)
+      allMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition;
++ (NSArray *_Nonnull)getRangesWithout:(NSArray<NSNumber *> *_Nonnull)types
+                            withInput:(EnrichedTextInputView *_Nonnull)input
+                              inRange:(NSRange)range;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/OccurenceUtils.mm b/node_modules/react-native-enriched/ios/utils/OccurenceUtils.mm
index 796282e..43d5840 100644
--- a/node_modules/react-native-enriched/ios/utils/OccurenceUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/OccurenceUtils.mm
@@ -2,154 +2,224 @@
 
 @implementation OccurenceUtils
 
-+ (BOOL)detect
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
++ (BOOL)detect:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition {
   __block NSInteger totalLength = 0;
-  [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-    ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      if(condition(value, range)) {
-        totalLength += range.length;
-      }
-    }
-  ];
+  [input->textView.textStorage
+      enumerateAttribute:key
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                if (condition(value, range)) {
+                  totalLength += range.length;
+                }
+              }];
   return totalLength == range.length;
 }
 
 // checkPrevious flag is used for styles like lists or blockquotes
-// it means that first character of paragraph will be checked instead if the detection is not in input's selected range and at the end of the input
-+ (BOOL)detect
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  atIndex:(NSUInteger)index
-  checkPrevious:(BOOL)checkPrev
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
+// it means that first character of paragraph will be checked instead if the
+// detection is not in input's selected range and at the end of the input
++ (BOOL)detect:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          atIndex:(NSUInteger)index
+    checkPrevious:(BOOL)checkPrev
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition {
   NSRange detectionRange = NSMakeRange(index, 0);
   id attrValue;
-  if(NSEqualRanges(input->textView.selectedRange, detectionRange)) {
+  if (NSEqualRanges(input->textView.selectedRange, detectionRange)) {
     attrValue = input->textView.typingAttributes[key];
-  } else if(index == input->textView.textStorage.string.length) {
-    if(checkPrev) {
-      NSRange paragraphRange = [input->textView.textStorage.string paragraphRangeForRange:detectionRange];
-      if(paragraphRange.location == detectionRange.location) {
+  } else if (index == input->textView.textStorage.string.length) {
+    if (checkPrev) {
+      NSRange paragraphRange = [input->textView.textStorage.string
+          paragraphRangeForRange:detectionRange];
+      if (paragraphRange.location == detectionRange.location) {
         return NO;
       } else {
-        return [self detect:key withInput:input inRange:NSMakeRange(paragraphRange.location, 1) withCondition:condition];
+        return [self detect:key
+                  withInput:input
+                    inRange:NSMakeRange(paragraphRange.location, 1)
+              withCondition:condition];
       }
     } else {
       return NO;
     }
   } else {
     NSRange attrRange = NSMakeRange(0, 0);
-    attrValue = [input->textView.textStorage attribute:key atIndex:index effectiveRange:&attrRange];
+    attrValue = [input->textView.textStorage attribute:key
+                                               atIndex:index
+                                        effectiveRange:&attrRange];
   }
   return condition(attrValue, detectionRange);
 }
 
-+ (BOOL)detectMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
++ (BOOL)detectMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+             withInput:(EnrichedTextInputView *_Nonnull)input
+               inRange:(NSRange)range
+         withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                     NSRange range))condition {
   __block NSInteger totalLength = 0;
-  for(NSString* key in keys) {
-    [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-      ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        if(condition(value, range)) {
-          totalLength += range.length;
-        }
-      }
-    ];
+  for (NSString *key in keys) {
+    [input->textView.textStorage
+        enumerateAttribute:key
+                   inRange:range
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  if (condition(value, range)) {
+                    totalLength += range.length;
+                  }
+                }];
   }
   return totalLength == range.length;
 }
 
-+ (BOOL)any
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
++ (BOOL)any:(NSAttributedStringKey _Nonnull)key
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition {
   __block BOOL found = NO;
-  [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-    ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      if(condition(value, range)) {
-        found = YES;
-        *stop = YES;
-      }
-    }
-  ];
+  [input->textView.textStorage
+      enumerateAttribute:key
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                if (condition(value, range)) {
+                  found = YES;
+                  *stop = YES;
+                }
+              }];
   return found;
 }
 
-+ (BOOL)anyMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
++ (BOOL)anyMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+          withInput:(EnrichedTextInputView *_Nonnull)input
+            inRange:(NSRange)range
+      withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                  NSRange range))condition {
   __block BOOL found = NO;
-  for(NSString *key in keys) {
-    [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-      ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        if(condition(value, range)) {
-          found = YES;
-          *stop = YES;
-        }
-      }
-    ];
-    if(found) {
+  for (NSString *key in keys) {
+    [input->textView.textStorage
+        enumerateAttribute:key
+                   inRange:range
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  if (condition(value, range)) {
+                    found = YES;
+                    *stop = YES;
+                  }
+                }];
+    if (found) {
       return YES;
     }
   }
   return NO;
 }
 
-+ (NSArray<StylePair *> *_Nullable)all
-  :(NSAttributedStringKey _Nonnull)key
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
-  __block NSMutableArray<StylePair *> *occurences = [[NSMutableArray<StylePair *> alloc] init];
-  [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-    ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-      if(condition(value, range)) {
-        StylePair *pair = [[StylePair alloc] init];
-        pair.rangeValue = [NSValue valueWithRange:range];
-        pair.styleValue = value;
-        [occurences addObject:pair];
-      }
-    }
-  ];
++ (NSArray<StylePair *> *_Nullable)all:(NSAttributedStringKey _Nonnull)key
+                             withInput:(EnrichedTextInputView *_Nonnull)input
+                               inRange:(NSRange)range
+                         withCondition:
+                             (BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                           NSRange range))
+                                 condition {
+  __block NSMutableArray<StylePair *> *occurences =
+      [[NSMutableArray<StylePair *> alloc] init];
+  [input->textView.textStorage
+      enumerateAttribute:key
+                 inRange:range
+                 options:0
+              usingBlock:^(id _Nullable value, NSRange range,
+                           BOOL *_Nonnull stop) {
+                if (condition(value, range)) {
+                  StylePair *pair = [[StylePair alloc] init];
+                  pair.rangeValue = [NSValue valueWithRange:range];
+                  pair.styleValue = value;
+                  [occurences addObject:pair];
+                }
+              }];
   return occurences;
 }
 
-+ (NSArray<StylePair *> *_Nullable)allMultiple
-  :(NSArray<NSAttributedStringKey> *_Nonnull)keys
-  withInput:(EnrichedTextInputView* _Nonnull)input
-  inRange:(NSRange)range
-  withCondition:(BOOL (NS_NOESCAPE ^_Nonnull)(id _Nullable value, NSRange range))condition
-{
-  __block NSMutableArray<StylePair *> *occurences = [[NSMutableArray<StylePair *> alloc] init];
-  for(NSString *key in keys) {
-    [input->textView.textStorage enumerateAttribute:key inRange:range options:0 usingBlock:
-      ^(id  _Nullable value, NSRange range, BOOL * _Nonnull stop) {
-        if(condition(value, range)) {
-          StylePair *pair = [[StylePair alloc] init];
-          pair.rangeValue = [NSValue valueWithRange:range];
-          pair.styleValue = value;
-          [occurences addObject:pair];
-        }
-      }
-    ];
++ (NSArray<StylePair *> *_Nullable)
+      allMultiple:(NSArray<NSAttributedStringKey> *_Nonnull)keys
+        withInput:(EnrichedTextInputView *_Nonnull)input
+          inRange:(NSRange)range
+    withCondition:(BOOL(NS_NOESCAPE ^ _Nonnull)(id _Nullable value,
+                                                NSRange range))condition {
+  __block NSMutableArray<StylePair *> *occurences =
+      [[NSMutableArray<StylePair *> alloc] init];
+  for (NSString *key in keys) {
+    [input->textView.textStorage
+        enumerateAttribute:key
+                   inRange:range
+                   options:0
+                usingBlock:^(id _Nullable value, NSRange range,
+                             BOOL *_Nonnull stop) {
+                  if (condition(value, range)) {
+                    StylePair *pair = [[StylePair alloc] init];
+                    pair.rangeValue = [NSValue valueWithRange:range];
+                    pair.styleValue = value;
+                    [occurences addObject:pair];
+                  }
+                }];
   }
   return occurences;
 }
 
++ (NSArray *_Nonnull)getRangesWithout:(NSArray<NSNumber *> *_Nonnull)types
+                            withInput:(EnrichedTextInputView *_Nonnull)input
+                              inRange:(NSRange)range {
+  NSMutableArray<id> *activeStyleObjects = [[NSMutableArray alloc] init];
+  for (NSNumber *type in types) {
+    id<BaseStyleProtocol> styleClass = input->stylesDict[type];
+    [activeStyleObjects addObject:styleClass];
+  }
+
+  if (activeStyleObjects.count == 0) {
+    return @[ [NSValue valueWithRange:range] ];
+  }
+
+  NSMutableArray<NSValue *> *newRanges = [[NSMutableArray alloc] init];
+  NSUInteger lastRangeLocation = range.location;
+  NSUInteger endLocation = range.location + range.length;
+
+  for (NSUInteger i = range.location; i < endLocation; i++) {
+    NSRange currentRange = NSMakeRange(i, 1);
+    BOOL forbiddenStyleFound = NO;
+
+    for (id style in activeStyleObjects) {
+      if ([style detectStyle:currentRange]) {
+        forbiddenStyleFound = YES;
+        break;
+      }
+    }
+
+    if (forbiddenStyleFound) {
+      if (i > lastRangeLocation) {
+        NSRange cleanRange =
+            NSMakeRange(lastRangeLocation, i - lastRangeLocation);
+        [newRanges addObject:[NSValue valueWithRange:cleanRange]];
+      }
+      lastRangeLocation = i + 1;
+    }
+  }
+
+  if (lastRangeLocation < endLocation) {
+    NSRange remainingRange =
+        NSMakeRange(lastRangeLocation, endLocation - lastRangeLocation);
+    [newRanges addObject:[NSValue valueWithRange:remainingRange]];
+  }
+
+  return newRanges;
+}
+
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.h b/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.h
index 0a1fd3a..c796479 100644
--- a/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.h
@@ -2,5 +2,10 @@
 #pragma once
 
 @interface ParagraphAttributesUtils : NSObject
-+ (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text input:(id)input;
++ (BOOL)handleBackspaceInRange:(NSRange)range
+               replacementText:(NSString *)text
+                         input:(id)input;
++ (BOOL)handleParagraphStylesMergeOnBackspace:(NSRange)range
+                              replacementText:(NSString *)text
+                                        input:(id)input;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.mm b/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.mm
index 4cf6384..5ac7bb5 100644
--- a/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/ParagraphAttributesUtils.mm
@@ -1,63 +1,174 @@
 #import "ParagraphAttributesUtils.h"
 #import "EnrichedTextInputView.h"
-#import "StyleHeaders.h"
 #import "ParagraphsUtils.h"
+#import "StyleHeaders.h"
 #import "TextInsertionUtils.h"
 
 @implementation ParagraphAttributesUtils
 
-// if the user backspaces the last character in a line, the iOS applies typing attributes from the previous line
-// in the case of some paragraph styles it works especially bad when a list point just appears
-// hence the solution - reset typing attributes
-+ (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text input:(id)input {
+// if the user backspaces the last character in a line, the iOS applies typing
+// attributes from the previous line in the case of some paragraph styles it
+// works especially bad when a list point just appears this method handles that
+// case differently with or without present paragraph styles
++ (BOOL)handleBackspaceInRange:(NSRange)range
+               replacementText:(NSString *)text
+                         input:(id)input {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
-  UnorderedListStyle *ulStyle = typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
-  OrderedListStyle *olStyle = typedInput->stylesDict[@([OrderedListStyle getStyleType])];
-  BlockQuoteStyle *bqStyle = typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
+  UnorderedListStyle *ulStyle =
+      typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
+  OrderedListStyle *olStyle =
+      typedInput->stylesDict[@([OrderedListStyle getStyleType])];
+  BlockQuoteStyle *bqStyle =
+      typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
+  CodeBlockStyle *cbStyle =
+      typedInput->stylesDict[@([CodeBlockStyle getStyleType])];
 
-  if(typedInput == nullptr) {
+  if (typedInput == nullptr) {
     return NO;
   }
 
-  // we make sure it was a backspace (text with 0 length) and it deleted something (range longer than 0)
-  if(text.length > 0 || range.length == 0) {
+  // we make sure it was a backspace (text with 0 length) and it deleted
+  // something (range longer than 0)
+  if (text.length > 0 || range.length == 0) {
     return NO;
   }
 
   // find a non-newline range of the paragraph
-  NSRange paragraphRange = [typedInput->textView.textStorage.string paragraphRangeForRange:range];
+  NSRange paragraphRange =
+      [typedInput->textView.textStorage.string paragraphRangeForRange:range];
 
-  NSArray *paragraphs = [ParagraphsUtils getNonNewlineRangesIn:typedInput->textView range:paragraphRange];
-  if(paragraphs.count == 0) {
+  NSArray *paragraphs =
+      [ParagraphsUtils getNonNewlineRangesIn:typedInput->textView
+                                       range:paragraphRange];
+  if (paragraphs.count == 0) {
     return NO;
   }
 
   NSRange nonNewlineRange = [(NSValue *)paragraphs.firstObject rangeValue];
 
-  // if the backspace removes the whole content of a paragraph (possibly more but has to start where the paragraph starts), we remove the typing attributes
-  if(range.location == nonNewlineRange.location && range.length >= nonNewlineRange.length) {
-    // for lists and quotes we want to remove the characters but keep attribtues so that a zero width space appears here
-    // so we do the removing manually and reapply attributes
-    if([ulStyle detectStyle:nonNewlineRange]) {
-      [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:typedInput withSelection:YES];
-      [ulStyle addAttributes:NSMakeRange(range.location, 0)];
-      return YES;
+  // the backspace removes the whole content of a paragraph (possibly more but
+  // has to start where the paragraph starts)
+  if (range.location == nonNewlineRange.location &&
+      range.length >= nonNewlineRange.length) {
+
+    // for lists, quotes and codeblocks present we do the following:
+    // - manually do the removing
+    // - reset typing attribtues so that the previous line styles don't get
+    // applied
+    // - reapply the paragraph style that was present so that a zero width space
+    // appears here
+    NSArray *handledStyles = @[ ulStyle, olStyle, bqStyle, cbStyle ];
+    for (id<BaseStyleProtocol> style in handledStyles) {
+      if ([style detectStyle:nonNewlineRange]) {
+        [TextInsertionUtils replaceText:text
+                                     at:range
+                   additionalAttributes:nullptr
+                                  input:typedInput
+                          withSelection:YES];
+        typedInput->textView.typingAttributes =
+            typedInput->defaultTypingAttributes;
+        [style addAttributes:NSMakeRange(range.location, 0) withTypingAttr:YES];
+        return YES;
+      }
     }
-    if([olStyle detectStyle:nonNewlineRange]) {
-      [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:typedInput withSelection:YES];
-      [olStyle addAttributes:NSMakeRange(range.location, 0)];
-      return YES;
+
+    // otherwise (no paragraph styles present), we just do the replacement
+    // manually and reset typing attribtues
+    [TextInsertionUtils replaceText:text
+                                 at:range
+               additionalAttributes:nullptr
+                              input:typedInput
+                      withSelection:YES];
+    typedInput->textView.typingAttributes = typedInput->defaultTypingAttributes;
+    return YES;
+  }
+
+  return NO;
+}
+
+/**
+ * Handles the specific case of backspacing a newline character, which results
+ * in merging two paragraphs.
+ *
+ * THE PROBLEM:
+ * When merging a bottom paragraph (Source) into a top paragraph (Destination),
+ * the bottom paragraph normally brings all its attributes with it. If the top
+ * paragraph is a restrictive style (like a CodeBlock), and the bottom paragraph
+ * contains a conflicting style (like an H1 Header), a standard merge would
+ * create an invalid state (e.g., a CodeBlock that is also a Header).
+ *
+ * THE SOLUTION:
+ * 1. Identifies the dominant style of the paragraph ABOVE the deleted newline
+ * (`leftParagraphStyle`).
+ * 2. Checks the paragraph BELOW the newline (`rightRange`) for any styles that
+ * conflict with or are blocked by the top style.
+ * 3. Explicitly removes those forbidden styles from the bottom paragraph
+ * *before* the merge occurs.
+ * 4. Performs the merge (deletes the newline).
+ *
+ * @return YES if the newline backspace was handled and sanitized; NO otherwise.
+ */
++ (BOOL)handleParagraphStylesMergeOnBackspace:(NSRange)range
+                              replacementText:(NSString *)text
+                                        input:(id)input {
+  EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
+  if (typedInput == nullptr) {
+    return NO;
+  }
+
+  if (text.length == 0) {
+    NSRange leftRange = [typedInput->textView.textStorage.string
+        paragraphRangeForRange:NSMakeRange(range.location, 0)];
+
+    id<BaseStyleProtocol> leftParagraphStyle = nullptr;
+    for (NSNumber *key in typedInput->stylesDict) {
+      id<BaseStyleProtocol> style = typedInput->stylesDict[key];
+      if ([[style class] isParagraphStyle] && [style detectStyle:leftRange]) {
+        leftParagraphStyle = style;
+      }
     }
-    if([bqStyle detectStyle:nonNewlineRange]) {
-      [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:typedInput withSelection:YES];
-      [bqStyle addAttributes:NSMakeRange(range.location, 0)];
-      return YES;
+
+    if (leftParagraphStyle == nullptr) {
+      return NO;
     }
 
-    // do the replacement manually
-    [TextInsertionUtils replaceText:text at:range additionalAttributes:nullptr input:typedInput withSelection:YES];
-    // reset typing attribtues
-    typedInput->textView.typingAttributes = typedInput->defaultTypingAttributes;
+    // index out of bounds
+    NSUInteger rightRangeStart = range.location + range.length;
+    if (rightRangeStart >= typedInput->textView.textStorage.string.length) {
+      return NO;
+    }
+
+    NSRange rightRange = [typedInput->textView.textStorage.string
+        paragraphRangeForRange:NSMakeRange(rightRangeStart, 1)];
+
+    StyleType type = [[leftParagraphStyle class] getStyleType];
+
+    NSArray *conflictingStyles = [typedInput
+        getPresentStyleTypesFrom:typedInput->conflictingStyles[@(type)]
+                           range:rightRange];
+    NSArray *blockingStyles =
+        [typedInput getPresentStyleTypesFrom:typedInput->blockingStyles[@(type)]
+                                       range:rightRange];
+    NSArray *allToBeRemoved =
+        [conflictingStyles arrayByAddingObjectsFromArray:blockingStyles];
+
+    for (NSNumber *style in allToBeRemoved) {
+      id<BaseStyleProtocol> styleClass = typedInput->stylesDict[style];
+
+      // for ranges, we need to remove each occurence
+      NSArray<StylePair *> *allOccurences =
+          [styleClass findAllOccurences:rightRange];
+
+      for (StylePair *pair in allOccurences) {
+        [styleClass removeAttributes:[pair.rangeValue rangeValue]];
+      }
+    }
+
+    [TextInsertionUtils replaceText:text
+                                 at:range
+               additionalAttributes:nullptr
+                              input:typedInput
+                      withSelection:YES];
     return YES;
   }
 
diff --git a/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.h b/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.h
index af93aee..a6a1cfa 100644
--- a/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.h
@@ -2,6 +2,7 @@
 #import <UIKit/UIKit.h>
 
 @interface ParagraphsUtils : NSObject
-+ (NSArray *)getSeparateParagraphsRangesIn:(UITextView *)textView range:(NSRange)range;
++ (NSArray *)getSeparateParagraphsRangesIn:(UITextView *)textView
+                                     range:(NSRange)range;
 + (NSArray *)getNonNewlineRangesIn:(UITextView *)textView range:(NSRange)range;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.mm b/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.mm
index fed04a3..aa3c116 100644
--- a/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/ParagraphsUtils.mm
@@ -2,30 +2,37 @@
 
 @implementation ParagraphsUtils
 
-+ (NSArray *)getSeparateParagraphsRangesIn:(UITextView *)textView range:(NSRange)range {
++ (NSArray *)getSeparateParagraphsRangesIn:(UITextView *)textView
+                                     range:(NSRange)range {
   // just in case, get full paragraphs range
-  NSRange fullRange = [textView.textStorage.string paragraphRangeForRange:range];
+  NSRange fullRange =
+      [textView.textStorage.string paragraphRangeForRange:range];
 
   // we are in an empty paragraph
-  if(fullRange.length == 0) {
-    return @[[NSValue valueWithRange:fullRange]];
+  if (fullRange.length == 0) {
+    return @[ [NSValue valueWithRange:fullRange] ];
   }
 
   NSMutableArray *results = [[NSMutableArray alloc] init];
 
   NSInteger lastStart = fullRange.location;
-  for(int i = fullRange.location; i < fullRange.location + fullRange.length; i++) {
+  for (int i = fullRange.location; i < fullRange.location + fullRange.length;
+       i++) {
     unichar currentChar = [textView.textStorage.string characterAtIndex:i];
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:currentChar]) {
-      NSRange paragraphRange = [textView.textStorage.string paragraphRangeForRange:NSMakeRange(lastStart, i - lastStart)];
-      [results addObject: [NSValue valueWithRange:paragraphRange]];
-      lastStart = i+1;
+    if ([[NSCharacterSet newlineCharacterSet] characterIsMember:currentChar]) {
+      NSRange paragraphRange = [textView.textStorage.string
+          paragraphRangeForRange:NSMakeRange(lastStart, i - lastStart)];
+      [results addObject:[NSValue valueWithRange:paragraphRange]];
+      lastStart = i + 1;
     }
   }
 
-  if(lastStart < fullRange.location + fullRange.length) {
-    NSRange paragraphRange = [textView.textStorage.string paragraphRangeForRange:NSMakeRange(lastStart, fullRange.location + fullRange.length - lastStart)];
-    [results addObject: [NSValue valueWithRange:paragraphRange]];
+  if (lastStart < fullRange.location + fullRange.length) {
+    NSRange paragraphRange = [textView.textStorage.string
+        paragraphRangeForRange:NSMakeRange(lastStart, fullRange.location +
+                                                          fullRange.length -
+                                                          lastStart)];
+    [results addObject:[NSValue valueWithRange:paragraphRange]];
   }
 
   return results;
@@ -35,17 +42,24 @@
   NSMutableArray *nonNewlineRanges = [[NSMutableArray alloc] init];
   int lastRangeLocation = range.location;
 
-  for(int i = range.location; i < range.location + range.length; i++) {
+  for (int i = range.location; i < range.location + range.length; i++) {
     unichar currentChar = [textView.textStorage.string characterAtIndex:i];
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:currentChar]) {
-      if(i - lastRangeLocation > 0) {
-        [nonNewlineRanges addObject:[NSValue valueWithRange:NSMakeRange(lastRangeLocation, i - lastRangeLocation)]];
+    if ([[NSCharacterSet newlineCharacterSet] characterIsMember:currentChar]) {
+      if (i - lastRangeLocation > 0) {
+        [nonNewlineRanges
+            addObject:[NSValue
+                          valueWithRange:NSMakeRange(lastRangeLocation,
+                                                     i - lastRangeLocation)]];
       }
-      lastRangeLocation = i+1;
+      lastRangeLocation = i + 1;
     }
   }
-  if(lastRangeLocation < range.location + range.length) {
-    [nonNewlineRanges addObject:[NSValue valueWithRange:NSMakeRange(lastRangeLocation, range.location + range.length - lastRangeLocation)]];
+  if (lastRangeLocation < range.location + range.length) {
+    [nonNewlineRanges
+        addObject:[NSValue
+                      valueWithRange:NSMakeRange(lastRangeLocation,
+                                                 range.location + range.length -
+                                                     lastRangeLocation)]];
   }
 
   return nonNewlineRanges;
diff --git a/node_modules/react-native-enriched/ios/utils/StringExtension.h b/node_modules/react-native-enriched/ios/utils/StringExtension.h
index f13d65d..365ae8a 100644
--- a/node_modules/react-native-enriched/ios/utils/StringExtension.h
+++ b/node_modules/react-native-enriched/ios/utils/StringExtension.h
@@ -1,5 +1,5 @@
-#import <UIKit/UIKit.h>
 #include "string"
+#import <UIKit/UIKit.h>
 #pragma once
 
 @interface NSString (StringExtension)
diff --git a/node_modules/react-native-enriched/ios/utils/StringExtension.mm b/node_modules/react-native-enriched/ios/utils/StringExtension.mm
index 95519de..a4ad69e 100644
--- a/node_modules/react-native-enriched/ios/utils/StringExtension.mm
+++ b/node_modules/react-native-enriched/ios/utils/StringExtension.mm
@@ -13,36 +13,39 @@
 + (NSString *)stringByEscapingHtml:(NSString *)html {
   NSMutableString *escaped = [html mutableCopy];
   NSDictionary *escapeMap = @{
-    @"&": @"&amp;",
-    @"<": @"&lt;",
-    @">": @"&gt;",
+    @"&" : @"&amp;",
+    @"<" : @"&lt;",
+    @">" : @"&gt;",
   };
 
-  for(NSString *key in escapeMap) {
-    [escaped replaceOccurrencesOfString:key withString:escapeMap[key] options:NSLiteralSearch range:NSMakeRange(0, escaped.length)];
+  for (NSString *key in escapeMap) {
+    [escaped replaceOccurrencesOfString:key
+                             withString:escapeMap[key]
+                                options:NSLiteralSearch
+                                  range:NSMakeRange(0, escaped.length)];
   }
   return escaped;
 }
 
 + (NSDictionary *)getEscapedCharactersInfoFrom:(NSString *)text {
   NSDictionary *unescapeMap = @{
-    @"&amp;": @"&",
-    @"&lt;": @"<",
-    @"&gt;": @">",
+    @"&amp;" : @"&",
+    @"&lt;" : @"<",
+    @"&gt;" : @">",
   };
 
   NSMutableDictionary *results = [[NSMutableDictionary alloc] init];
 
-  for(NSString *key in unescapeMap) {
+  for (NSString *key in unescapeMap) {
     NSRange searchRange = NSMakeRange(0, text.length);
     NSRange foundRange;
 
-    while(searchRange.location < text.length) {
+    while (searchRange.location < text.length) {
       foundRange = [text rangeOfString:key options:0 range:searchRange];
-      if(foundRange.location == NSNotFound) {
+      if (foundRange.location == NSNotFound) {
         break;
       }
-      results[@(foundRange.location)] = @[key, unescapeMap[key]];
+      results[@(foundRange.location)] = @[ key, unescapeMap[key] ];
       searchRange.location = foundRange.location + foundRange.length;
       searchRange.length = text.length - searchRange.location;
     }
diff --git a/node_modules/react-native-enriched/ios/utils/StyleHeaders.h b/node_modules/react-native-enriched/ios/utils/StyleHeaders.h
index 1142a4a..6384f38 100644
--- a/node_modules/react-native-enriched/ios/utils/StyleHeaders.h
+++ b/node_modules/react-native-enriched/ios/utils/StyleHeaders.h
@@ -1,5 +1,6 @@
 #pragma once
 #import "BaseStyleProtocol.h"
+#import "ImageData.h"
 #import "LinkData.h"
 #import "MentionParams.h"
 
@@ -20,29 +21,37 @@
 @end
 
 @interface LinkStyle : NSObject <BaseStyleProtocol>
-- (void)addLink:(NSString*)text url:(NSString*)url range:(NSRange)range manual:(BOOL)manual;
+- (void)addLink:(NSString *)text
+              url:(NSString *)url
+            range:(NSRange)range
+           manual:(BOOL)manual
+    withSelection:(BOOL)withSelection;
 - (LinkData *)getLinkDataAt:(NSUInteger)location;
 - (NSRange)getFullLinkRangeAt:(NSUInteger)location;
 - (void)manageLinkTypingAttributes;
 - (void)handleAutomaticLinks:(NSString *)word inRange:(NSRange)wordRange;
 - (void)handleManualLinks:(NSString *)word inRange:(NSRange)wordRange;
-- (BOOL)handleLeadingLinkReplacement:(NSRange)range replacementText:(NSString *)text;
+- (BOOL)handleLeadingLinkReplacement:(NSRange)range
+                     replacementText:(NSString *)text;
 @end
 
-@interface MentionStyle : NSObject<BaseStyleProtocol>
-- (void)addMention:(NSString *)indicator text:(NSString *)text attributes:(NSString *)attributes;
+@interface MentionStyle : NSObject <BaseStyleProtocol>
+- (void)addMention:(NSString *)indicator
+              text:(NSString *)text
+        attributes:(NSString *)attributes;
 - (void)addMentionAtRange:(NSRange)range params:(MentionParams *)params;
 - (void)startMentionWithIndicator:(NSString *)indicator;
 - (void)handleExistingMentions;
 - (void)manageMentionEditing;
 - (void)manageMentionTypingAttributes;
-- (BOOL)handleLeadingMentionReplacement:(NSRange)range replacementText:(NSString *)text;
+- (BOOL)handleLeadingMentionReplacement:(NSRange)range
+                        replacementText:(NSString *)text;
 - (MentionParams *)getMentionParamsAt:(NSUInteger)location;
 - (NSRange)getFullMentionRangeAt:(NSUInteger)location;
 - (NSValue *)getActiveMentionRange;
 @end
 
-@interface HeadingStyleBase : NSObject<BaseStyleProtocol> {
+@interface HeadingStyleBase : NSObject <BaseStyleProtocol> {
   id input;
 }
 - (CGFloat)getHeadingFontSize;
@@ -60,17 +69,32 @@
 @interface H3Style : HeadingStyleBase
 @end
 
-@interface UnorderedListStyle : NSObject<BaseStyleProtocol>
+@interface UnorderedListStyle : NSObject <BaseStyleProtocol>
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text;
-- (BOOL)tryHandlingListShorcutInRange:(NSRange)range replacementText:(NSString *)text;
+- (BOOL)tryHandlingListShorcutInRange:(NSRange)range
+                      replacementText:(NSString *)text;
 @end
 
-@interface OrderedListStyle : NSObject<BaseStyleProtocol>
+@interface OrderedListStyle : NSObject <BaseStyleProtocol>
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text;
-- (BOOL)tryHandlingListShorcutInRange:(NSRange)range replacementText:(NSString *)text;
+- (BOOL)tryHandlingListShorcutInRange:(NSRange)range
+                      replacementText:(NSString *)text;
 @end
 
-@interface BlockQuoteStyle : NSObject<BaseStyleProtocol>
+@interface BlockQuoteStyle : NSObject <BaseStyleProtocol>
 - (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text;
 - (void)manageBlockquoteColor;
 @end
+
+@interface CodeBlockStyle : NSObject <BaseStyleProtocol>
+- (void)manageCodeBlockFontAndColor;
+- (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text;
+@end
+
+@interface ImageStyle : NSObject <BaseStyleProtocol>
+- (void)addImage:(NSString *)uri width:(CGFloat)width height:(CGFloat)height;
+- (void)addImageAtRange:(NSRange)range
+              imageData:(ImageData *)imageData
+          withSelection:(BOOL)withSelection;
+- (ImageData *)getImageDataAt:(NSUInteger)location;
+@end
diff --git a/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.h b/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.h
index 2d48ce1..1012f38 100644
--- a/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.h
@@ -1,6 +1,17 @@
 #import <UIKit/UIKit.h>
 
 @interface TextInsertionUtils : NSObject
-+ (void)insertText:(NSString*)text at:(NSInteger)index additionalAttributes:(NSDictionary<NSAttributedStringKey, id>*)additionalAttrs input:(id)input withSelection:(BOOL)withSelection;
-+ (void)replaceText:(NSString*)text at:(NSRange)range additionalAttributes:(NSDictionary<NSAttributedStringKey, id>*)additionalAttrs input:(id)input withSelection:(BOOL)withSelection;;
++ (void)insertText:(NSString *)text
+                      at:(NSInteger)index
+    additionalAttributes:
+        (NSDictionary<NSAttributedStringKey, id> *)additionalAttrs
+                   input:(id)input
+           withSelection:(BOOL)withSelection;
++ (void)replaceText:(NSString *)text
+                      at:(NSRange)range
+    additionalAttributes:
+        (NSDictionary<NSAttributedStringKey, id> *)additionalAttrs
+                   input:(id)input
+           withSelection:(BOOL)withSelection;
+;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.mm b/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.mm
index ac5f62f..6afa0b8 100644
--- a/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/TextInsertionUtils.mm
@@ -1,24 +1,33 @@
 #import "TextInsertionUtils.h"
-#import "UIView+React.h"
 #import "EnrichedTextInputView.h"
+#import "UIView+React.h"
 
 @implementation TextInsertionUtils
-+ (void)insertText:(NSString*)text at:(NSInteger)index additionalAttributes:(NSDictionary<NSAttributedStringKey, id>*)additionalAttrs input:(id)input withSelection:(BOOL)withSelection {
++ (void)insertText:(NSString *)text
+                      at:(NSInteger)index
+    additionalAttributes:
+        (NSDictionary<NSAttributedStringKey, id> *)additionalAttrs
+                   input:(id)input
+           withSelection:(BOOL)withSelection {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   UITextView *textView = typedInput->textView;
 
-  NSMutableDictionary<NSAttributedStringKey, id> *copiedAttrs = [textView.typingAttributes mutableCopy];
-  if(additionalAttrs != nullptr) {
-    [copiedAttrs addEntriesFromDictionary: additionalAttrs];
+  NSMutableDictionary<NSAttributedStringKey, id> *copiedAttrs =
+      [textView.typingAttributes mutableCopy];
+  if (additionalAttrs != nullptr) {
+    [copiedAttrs addEntriesFromDictionary:additionalAttrs];
   }
 
-  NSAttributedString *newAttrStr = [[NSAttributedString alloc] initWithString:text attributes:copiedAttrs];
+  NSAttributedString *newAttrStr =
+      [[NSAttributedString alloc] initWithString:text attributes:copiedAttrs];
   [textView.textStorage insertAttributedString:newAttrStr atIndex:index];
 
-  if(withSelection) {
-    if(![textView isFirstResponder]) {
+  if (withSelection) {
+    if (![textView isFirstResponder]) {
       [textView reactFocus];
     }
     textView.selectedRange = NSMakeRange(index + text.length, 0);
@@ -26,19 +35,28 @@
   typedInput->recentlyChangedRange = NSMakeRange(index, text.length);
 }
 
-+ (void)replaceText:(NSString*)text at:(NSRange)range additionalAttributes:(NSDictionary<NSAttributedStringKey, id>*)additionalAttrs input:(id)input withSelection:(BOOL)withSelection {
++ (void)replaceText:(NSString *)text
+                      at:(NSRange)range
+    additionalAttributes:
+        (NSDictionary<NSAttributedStringKey, id> *)additionalAttrs
+                   input:(id)input
+           withSelection:(BOOL)withSelection {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   UITextView *textView = typedInput->textView;
 
   [textView.textStorage replaceCharactersInRange:range withString:text];
-  if(additionalAttrs != nullptr) {
-    [textView.textStorage addAttributes:additionalAttrs range:NSMakeRange(range.location, [text length])];
+  if (additionalAttrs != nullptr) {
+    [textView.textStorage
+        addAttributes:additionalAttrs
+                range:NSMakeRange(range.location, [text length])];
   }
 
-  if(withSelection) {
-    if(![textView isFirstResponder]) {
+  if (withSelection) {
+    if (![textView isFirstResponder]) {
       [textView reactFocus];
     }
     textView.selectedRange = NSMakeRange(range.location + text.length, 0);
diff --git a/node_modules/react-native-enriched/ios/utils/WordsUtils.h b/node_modules/react-native-enriched/ios/utils/WordsUtils.h
index 6fe870d..c442d11 100644
--- a/node_modules/react-native-enriched/ios/utils/WordsUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/WordsUtils.h
@@ -1,6 +1,7 @@
 #import <UIKit/UIKit.h>
 
 @interface WordsUtils : NSObject
-+ (NSArray<NSDictionary *> *)getAffectedWordsFromText:(NSString *)text modificationRange:(NSRange)range;
++ (NSArray<NSDictionary *> *)getAffectedWordsFromText:(NSString *)text
+                                    modificationRange:(NSRange)range;
 + (NSDictionary *)getCurrentWord:(NSString *)text range:(NSRange)range;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/WordsUtils.mm b/node_modules/react-native-enriched/ios/utils/WordsUtils.mm
index 166d379..b08c6c8 100644
--- a/node_modules/react-native-enriched/ios/utils/WordsUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/WordsUtils.mm
@@ -2,8 +2,9 @@
 
 @implementation WordsUtils
 
-+ (NSArray<NSDictionary *> *)getAffectedWordsFromText:(NSString *)text modificationRange:(NSRange)range {
-  if(text.length == 0) {
++ (NSArray<NSDictionary *> *)getAffectedWordsFromText:(NSString *)text
+                                    modificationRange:(NSRange)range {
+  if (text.length == 0) {
     return [[NSArray alloc] init];
   }
 
@@ -12,7 +13,8 @@
   if (leftIt > 0) {
     while (leftIt >= 0) {
       unichar charAtIndex = [text characterAtIndex:leftIt];
-      if ([[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:charAtIndex]) {
+      if ([[NSCharacterSet whitespaceAndNewlineCharacterSet]
+              characterIsMember:charAtIndex]) {
         leftIt += 1;
         break;
       }
@@ -26,7 +28,8 @@
   if (rightIt < text.length - 1) {
     while (rightIt <= text.length - 1) {
       unichar charAtIndex = [text characterAtIndex:rightIt];
-      if ([[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:charAtIndex]) {
+      if ([[NSCharacterSet whitespaceAndNewlineCharacterSet]
+              characterIsMember:charAtIndex]) {
         rightIt -= 1;
         break;
       }
@@ -35,22 +38,25 @@
   }
   rightIt = MIN(NSInteger(text.length - 1), rightIt);
 
-  if(leftIt > rightIt) {
+  if (leftIt > rightIt) {
     return [[NSArray alloc] init];
   }
 
-  NSMutableArray<NSDictionary *> *separatedWords = [[NSMutableArray<NSDictionary *> alloc] init];
+  NSMutableArray<NSDictionary *> *separatedWords =
+      [[NSMutableArray<NSDictionary *> alloc] init];
   NSMutableString *currentWord = [[NSMutableString alloc] init];
   NSInteger currentRangeStart = leftIt;
   NSInteger currentIdx = leftIt;
 
   while (currentIdx <= rightIt) {
     unichar charAtIndex = [text characterAtIndex:currentIdx];
-    if ([[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:charAtIndex]) {
+    if ([[NSCharacterSet whitespaceAndNewlineCharacterSet]
+            characterIsMember:charAtIndex]) {
       if (currentWord.length > 0) {
         [separatedWords addObject:@{
-          @"word": [currentWord copy],
-          @"range": [NSValue valueWithRange:NSMakeRange(currentRangeStart, currentWord.length)]
+          @"word" : [currentWord copy],
+          @"range" : [NSValue
+              valueWithRange:NSMakeRange(currentRangeStart, currentWord.length)]
         }];
         [currentWord setString:@""];
       }
@@ -63,8 +69,10 @@
 
   if (currentWord.length > 0) {
     [separatedWords addObject:@{
-      @"word": [currentWord copy],
-      @"range": [NSValue valueWithRange:NSMakeRange(currentRangeStart, rightIt - currentRangeStart + 1)]
+      @"word" : [currentWord copy],
+      @"range" :
+          [NSValue valueWithRange:NSMakeRange(currentRangeStart,
+                                              rightIt - currentRangeStart + 1)]
     }];
   }
 
@@ -73,12 +81,14 @@
 
 + (NSDictionary *)getCurrentWord:(NSString *)text range:(NSRange)range {
   // we just get current word at the cursor
-  if(range.length > 0) {
+  if (range.length > 0) {
     return nullptr;
   }
 
-  NSArray<NSDictionary *> *words = [WordsUtils getAffectedWordsFromText:text modificationRange:range];
-  if(words != nullptr && [words count] == 1 && [words firstObject] != nullptr) {
+  NSArray<NSDictionary *> *words = [WordsUtils getAffectedWordsFromText:text
+                                                      modificationRange:range];
+  if (words != nullptr && [words count] == 1 &&
+      [words firstObject] != nullptr) {
     return [words firstObject];
   }
 
diff --git a/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.h b/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.h
index 27befa3..7678749 100644
--- a/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.h
+++ b/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.h
@@ -3,5 +3,7 @@
 
 @interface ZeroWidthSpaceUtils : NSObject
 + (void)handleZeroWidthSpacesInInput:(id)input;
-+ (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text input:(id)input;
++ (BOOL)handleBackspaceInRange:(NSRange)range
+               replacementText:(NSString *)text
+                         input:(id)input;
 @end
diff --git a/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.mm b/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.mm
index 63f76a4..6ead73c 100644
--- a/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.mm
+++ b/node_modules/react-native-enriched/ios/utils/ZeroWidthSpaceUtils.mm
@@ -7,7 +7,9 @@
 @implementation ZeroWidthSpaceUtils
 + (void)handleZeroWidthSpacesInInput:(id)input {
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
-  if(typedInput == nullptr) { return; }
+  if (typedInput == nullptr) {
+    return;
+  }
 
   [self removeSpacesIfNeededinInput:typedInput];
   [self addSpacesIfNeededinInput:typedInput];
@@ -17,34 +19,45 @@
   NSMutableArray *indexesToBeRemoved = [[NSMutableArray alloc] init];
   NSRange preRemoveSelection = input->textView.selectedRange;
 
-  for(int i = 0; i < input->textView.textStorage.string.length; i++) {
+  for (int i = 0; i < input->textView.textStorage.string.length; i++) {
     unichar character = [input->textView.textStorage.string characterAtIndex:i];
-    if(character == 0x200B) {
+    if (character == 0x200B) {
       NSRange characterRange = NSMakeRange(i, 1);
 
-      NSRange paragraphRange = [input->textView.textStorage.string paragraphRangeForRange:characterRange];
-      // having paragraph longer than 1 character means someone most likely added something and we probably can remove the space
+      NSRange paragraphRange = [input->textView.textStorage.string
+          paragraphRangeForRange:characterRange];
+      // having paragraph longer than 1 character means someone most likely
+      // added something and we probably can remove the space
       BOOL removeSpace = paragraphRange.length > 1;
       // exception; 2 characters paragraph with zero width space + newline
       // here, we still need zero width space to keep the empty list items
-      if(paragraphRange.length == 2 &&
-         paragraphRange.location == i &&
-         [[NSCharacterSet newlineCharacterSet] characterIsMember:[input->textView.textStorage.string characterAtIndex:i+1]]
-      ) {
+      if (paragraphRange.length == 2 && paragraphRange.location == i &&
+          [[NSCharacterSet newlineCharacterSet]
+              characterIsMember:[input->textView.textStorage.string
+                                    characterAtIndex:i + 1]]) {
         removeSpace = NO;
       }
 
-      if(removeSpace) {
+      if (removeSpace) {
         [indexesToBeRemoved addObject:@(characterRange.location)];
         continue;
       }
 
-      UnorderedListStyle *ulStyle = input->stylesDict[@([UnorderedListStyle getStyleType])];
-      OrderedListStyle *olStyle = input->stylesDict[@([OrderedListStyle getStyleType])];
-      BlockQuoteStyle *bqStyle = input->stylesDict[@([BlockQuoteStyle getStyleType])];
-      
-      // zero width spaces with no lists/blockquote styles on them get removed
-      if(![ulStyle detectStyle:characterRange] && ![olStyle detectStyle:characterRange] && ![bqStyle detectStyle:characterRange]) {
+      UnorderedListStyle *ulStyle =
+          input->stylesDict[@([UnorderedListStyle getStyleType])];
+      OrderedListStyle *olStyle =
+          input->stylesDict[@([OrderedListStyle getStyleType])];
+      BlockQuoteStyle *bqStyle =
+          input->stylesDict[@([BlockQuoteStyle getStyleType])];
+      CodeBlockStyle *cbStyle =
+          input->stylesDict[@([CodeBlockStyle getStyleType])];
+
+      // zero width spaces with no lists/blockquotes/codeblocks on them get
+      // removed
+      if (![ulStyle detectStyle:characterRange] &&
+          ![olStyle detectStyle:characterRange] &&
+          ![bqStyle detectStyle:characterRange] &&
+          ![cbStyle detectStyle:characterRange]) {
         [indexesToBeRemoved addObject:@(characterRange.location)];
       }
     }
@@ -54,40 +67,55 @@
   NSInteger offset = 0;
   NSInteger postRemoveLocationOffset = 0;
   NSInteger postRemoveLengthOffset = 0;
-  for(NSNumber *index in indexesToBeRemoved) {
+  for (NSNumber *index in indexesToBeRemoved) {
     NSRange replaceRange = NSMakeRange([index integerValue] + offset, 1);
-    [TextInsertionUtils replaceText:@"" at:replaceRange additionalAttributes:nullptr input:input withSelection:NO];
+    [TextInsertionUtils replaceText:@""
+                                 at:replaceRange
+               additionalAttributes:nullptr
+                              input:input
+                      withSelection:NO];
     offset -= 1;
-    if([index integerValue] < preRemoveSelection.location) {
+    if ([index integerValue] < preRemoveSelection.location) {
       postRemoveLocationOffset -= 1;
     }
-    if([index integerValue] >= preRemoveSelection.location && [index integerValue] < NSMaxRange(preRemoveSelection)) {
+    if ([index integerValue] >= preRemoveSelection.location &&
+        [index integerValue] < NSMaxRange(preRemoveSelection)) {
       postRemoveLengthOffset -= 1;
     }
   }
 
   // fix the selection if needed
-  if([input->textView isFirstResponder]) {
-    input->textView.selectedRange = NSMakeRange(preRemoveSelection.location + postRemoveLocationOffset, preRemoveSelection.length + postRemoveLengthOffset);
+  if ([input->textView isFirstResponder]) {
+    input->textView.selectedRange =
+        NSMakeRange(preRemoveSelection.location + postRemoveLocationOffset,
+                    preRemoveSelection.length + postRemoveLengthOffset);
   }
 }
 
 + (void)addSpacesIfNeededinInput:(EnrichedTextInputView *)input {
-  UnorderedListStyle *ulStyle = input->stylesDict[@([UnorderedListStyle getStyleType])];
-  OrderedListStyle *olStyle = input->stylesDict[@([OrderedListStyle getStyleType])];
-  BlockQuoteStyle *bqStyle = input->stylesDict[@([BlockQuoteStyle getStyleType])];
+  UnorderedListStyle *ulStyle =
+      input->stylesDict[@([UnorderedListStyle getStyleType])];
+  OrderedListStyle *olStyle =
+      input->stylesDict[@([OrderedListStyle getStyleType])];
+  BlockQuoteStyle *bqStyle =
+      input->stylesDict[@([BlockQuoteStyle getStyleType])];
+  CodeBlockStyle *cbStyle = input->stylesDict[@([CodeBlockStyle getStyleType])];
   NSMutableArray *indexesToBeInserted = [[NSMutableArray alloc] init];
   NSRange preAddSelection = input->textView.selectedRange;
 
-  for(int i = 0; i < input->textView.textStorage.string.length; i++) {
+  for (int i = 0; i < input->textView.textStorage.string.length; i++) {
     unichar character = [input->textView.textStorage.string characterAtIndex:i];
 
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:character]) {
+    if ([[NSCharacterSet newlineCharacterSet] characterIsMember:character]) {
       NSRange characterRange = NSMakeRange(i, 1);
-      NSRange paragraphRange = [input->textView.textStorage.string paragraphRangeForRange:characterRange];
-      
-      if(paragraphRange.length == 1) {
-        if([ulStyle detectStyle:characterRange] || [olStyle detectStyle:characterRange] || [bqStyle detectStyle:characterRange]) {
+      NSRange paragraphRange = [input->textView.textStorage.string
+          paragraphRangeForRange:characterRange];
+
+      if (paragraphRange.length == 1) {
+        if ([ulStyle detectStyle:characterRange] ||
+            [olStyle detectStyle:characterRange] ||
+            [bqStyle detectStyle:characterRange] ||
+            [cbStyle detectStyle:characterRange]) {
           // we have an empty list or quote item with no space: add it!
           [indexesToBeInserted addObject:@(paragraphRange.location)];
         }
@@ -99,66 +127,116 @@
   NSInteger offset = 0;
   NSInteger postAddLocationOffset = 0;
   NSInteger postAddLengthOffset = 0;
-  for(NSNumber *index in indexesToBeInserted) {
+  for (NSNumber *index in indexesToBeInserted) {
     NSRange replaceRange = NSMakeRange([index integerValue] + offset, 1);
-    [TextInsertionUtils replaceText:@"\u200B\n" at:replaceRange additionalAttributes:nullptr input:input withSelection:NO];
+    [TextInsertionUtils replaceText:@"\u200B\n"
+                                 at:replaceRange
+               additionalAttributes:nullptr
+                              input:input
+                      withSelection:NO];
     offset += 1;
-    if([index integerValue] < preAddSelection.location) {
+    if ([index integerValue] < preAddSelection.location) {
       postAddLocationOffset += 1;
     }
-    if([index integerValue] >= preAddSelection.location && [index integerValue] < NSMaxRange(preAddSelection)) {
+    if ([index integerValue] >= preAddSelection.location &&
+        [index integerValue] < NSMaxRange(preAddSelection)) {
       postAddLengthOffset += 1;
     }
   }
 
   // additional check for last index of the input
   NSRange lastRange = NSMakeRange(input->textView.textStorage.string.length, 0);
-  NSRange lastParagraphRange = [input->textView.textStorage.string paragraphRangeForRange:lastRange];
-  if(lastParagraphRange.length == 0 && ([ulStyle detectStyle:lastRange] || [olStyle detectStyle:lastRange] || [bqStyle detectStyle:lastRange])) {
-    [TextInsertionUtils insertText:@"\u200B" at:lastRange.location additionalAttributes:nullptr input:input withSelection:NO];
+  NSRange lastParagraphRange =
+      [input->textView.textStorage.string paragraphRangeForRange:lastRange];
+  if (lastParagraphRange.length == 0 &&
+      ([ulStyle detectStyle:lastRange] || [olStyle detectStyle:lastRange] ||
+       [bqStyle detectStyle:lastRange] || [cbStyle detectStyle:lastRange])) {
+    [TextInsertionUtils insertText:@"\u200B"
+                                at:lastRange.location
+              additionalAttributes:nullptr
+                             input:input
+                     withSelection:NO];
   }
 
   // fix the selection if needed
-  if([input->textView isFirstResponder]) {
-    input->textView.selectedRange = NSMakeRange(preAddSelection.location + postAddLocationOffset, preAddSelection.length + postAddLengthOffset);
+  if ([input->textView isFirstResponder]) {
+    input->textView.selectedRange =
+        NSMakeRange(preAddSelection.location + postAddLocationOffset,
+                    preAddSelection.length + postAddLengthOffset);
   }
 }
 
-+ (BOOL)handleBackspaceInRange:(NSRange)range replacementText:(NSString *)text input:(id)input {
-  if(range.length != 1 || ![text isEqualToString:@""]) { return NO; }
++ (BOOL)handleBackspaceInRange:(NSRange)range
+               replacementText:(NSString *)text
+                         input:(id)input {
+  if (range.length != 1 || ![text isEqualToString:@""]) {
+    return NO;
+  }
   EnrichedTextInputView *typedInput = (EnrichedTextInputView *)input;
-  if(typedInput == nullptr) { return NO; }
+  if (typedInput == nullptr) {
+    return NO;
+  }
 
-  unichar character = [typedInput->textView.textStorage.string characterAtIndex:range.location];
+  unichar character =
+      [typedInput->textView.textStorage.string characterAtIndex:range.location];
   // zero-width space got backspaced
-  if(character == 0x200B) {
+  if (character == 0x200B) {
     // in such case: remove the whole line without the endline if there is one
 
-    NSRange paragraphRange = [typedInput->textView.textStorage.string paragraphRangeForRange:range];
+    NSRange paragraphRange =
+        [typedInput->textView.textStorage.string paragraphRangeForRange:range];
     NSRange removalRange = paragraphRange;
     // if whole paragraph gets removed then 0 length for style removal
     NSRange styleRemovalRange = NSMakeRange(paragraphRange.location, 0);
 
-    if([[NSCharacterSet newlineCharacterSet] characterIsMember:[typedInput->textView.textStorage.string characterAtIndex:NSMaxRange(paragraphRange) - 1]]) {
+    if ([[NSCharacterSet newlineCharacterSet]
+            characterIsMember:[typedInput->textView.textStorage.string
+                                  characterAtIndex:NSMaxRange(paragraphRange) -
+                                                   1]]) {
       // if endline is there, don't remove it
-      removalRange = NSMakeRange(paragraphRange.location, paragraphRange.length - 1);
+      removalRange =
+          NSMakeRange(paragraphRange.location, paragraphRange.length - 1);
       // if endline is left then 1 length for style removal
       styleRemovalRange = NSMakeRange(paragraphRange.location, 1);
     }
 
-    [TextInsertionUtils replaceText:@"" at:removalRange additionalAttributes:nullptr input:typedInput withSelection:YES];
-    
     // and then remove associated styling
 
-    UnorderedListStyle *ulStyle = typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
-    OrderedListStyle *olStyle = typedInput->stylesDict[@([OrderedListStyle getStyleType])];
-    BlockQuoteStyle *bqStyle = typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
+    UnorderedListStyle *ulStyle =
+        typedInput->stylesDict[@([UnorderedListStyle getStyleType])];
+    OrderedListStyle *olStyle =
+        typedInput->stylesDict[@([OrderedListStyle getStyleType])];
+    BlockQuoteStyle *bqStyle =
+        typedInput->stylesDict[@([BlockQuoteStyle getStyleType])];
+    CodeBlockStyle *cbStyle =
+        typedInput->stylesDict[@([CodeBlockStyle getStyleType])];
+
+    if ([cbStyle detectStyle:removalRange]) {
+      // code blocks are being handled differently; we want to remove previous
+      // newline if there is a one
+      if (range.location > 0) {
+        removalRange =
+            NSMakeRange(removalRange.location - 1, removalRange.length + 1);
+      }
+      [TextInsertionUtils replaceText:@""
+                                   at:removalRange
+                 additionalAttributes:nullptr
+                                input:typedInput
+                        withSelection:YES];
+      return YES;
+    }
+
+    [TextInsertionUtils replaceText:@""
+                                 at:removalRange
+               additionalAttributes:nullptr
+                              input:typedInput
+                      withSelection:YES];
 
-    if([ulStyle detectStyle:styleRemovalRange]) {
+    if ([ulStyle detectStyle:styleRemovalRange]) {
       [ulStyle removeAttributes:styleRemovalRange];
-    } else if([olStyle detectStyle:styleRemovalRange]) {
+    } else if ([olStyle detectStyle:styleRemovalRange]) {
       [olStyle removeAttributes:styleRemovalRange];
-    } else if([bqStyle detectStyle:styleRemovalRange]) {
+    } else if ([bqStyle detectStyle:styleRemovalRange]) {
       [bqStyle removeAttributes:styleRemovalRange];
     }
 
@@ -166,5 +244,5 @@
   }
   return NO;
 }
-@end
 
+@end
diff --git a/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js b/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js
index 7245788..cc36fe2 100644
--- a/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js
+++ b/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js
@@ -1,6 +1,6 @@
 "use strict";
 
-import { useImperativeHandle, useMemo, useRef } from 'react';
+import { useEffect, useImperativeHandle, useMemo, useRef } from 'react';
 import EnrichedTextInputNativeComponent, { Commands } from './EnrichedTextInputNativeComponent';
 import { normalizeHtmlStyle } from "./normalizeHtmlStyle.js";
 import { jsx as _jsx } from "react/jsx-runtime";
@@ -42,6 +42,19 @@ export const EnrichedTextInput = ({
   ...rest
 }) => {
   const nativeRef = useRef(null);
+  const nextHtmlRequestId = useRef(1);
+  const pendingHtmlRequests = useRef(new Map());
+  useEffect(() => {
+    const pendingRequests = pendingHtmlRequests.current;
+    return () => {
+      pendingRequests.forEach(({
+        reject
+      }) => {
+        reject(new Error('Component unmounted'));
+      });
+      pendingRequests.clear();
+    };
+  }, []);
   const normalizedHtmlStyle = useMemo(() => normalizeHtmlStyle(htmlStyle, mentionIndicators), [htmlStyle, mentionIndicators]);
   useImperativeHandle(ref, () => ({
     measureInWindow: callback => {
@@ -65,6 +78,16 @@ export const EnrichedTextInput = ({
     setValue: value => {
       Commands.setValue(nullthrows(nativeRef.current), value);
     },
+    getHTML: () => {
+      return new Promise((resolve, reject) => {
+        const requestId = nextHtmlRequestId.current++;
+        pendingHtmlRequests.current.set(requestId, {
+          resolve,
+          reject
+        });
+        Commands.requestHTML(nullthrows(nativeRef.current), requestId);
+      });
+    },
     toggleBold: () => {
       Commands.toggleBold(nullthrows(nativeRef.current));
     },
@@ -104,8 +127,8 @@ export const EnrichedTextInput = ({
     setLink: (start, end, text, url) => {
       Commands.addLink(nullthrows(nativeRef.current), start, end, text, url);
     },
-    setImage: uri => {
-      Commands.addImage(nullthrows(nativeRef.current), uri);
+    setImage: (uri, width, height) => {
+      Commands.addImage(nullthrows(nativeRef.current), uri, width, height);
     },
     setMention: (indicator, text, attributes) => {
       // Codegen does not support objects as Commands parameters, so we stringify attributes
@@ -162,6 +185,20 @@ export const EnrichedTextInput = ({
       attributes
     });
   };
+  const handleRequestHtmlResult = e => {
+    const {
+      requestId,
+      html
+    } = e.nativeEvent;
+    const pending = pendingHtmlRequests.current.get(requestId);
+    if (!pending) return;
+    if (html === null || typeof html !== 'string') {
+      pending.reject(new Error('Failed to parse HTML'));
+    } else {
+      pending.resolve(html);
+    }
+    pendingHtmlRequests.current.delete(requestId);
+  };
   return /*#__PURE__*/_jsx(EnrichedTextInputNativeComponent, {
     ref: nativeRef,
     mentionIndicators: mentionIndicators,
@@ -185,6 +222,7 @@ export const EnrichedTextInput = ({
     onMentionDetected: handleMentionDetected,
     onMention: handleMentionEvent,
     onChangeSelection: onChangeSelection,
+    onRequestHtmlResult: handleRequestHtmlResult,
     androidExperimentalSynchronousEvents: androidExperimentalSynchronousEvents,
     scrollEnabled: scrollEnabled,
     ...rest
diff --git a/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js.map b/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js.map
index f86c56d..c573118 100644
--- a/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js.map
+++ b/node_modules/react-native-enriched/lib/module/EnrichedTextInput.js.map
@@ -1 +1 @@
-{"version":3,"names":["useImperativeHandle","useMemo","useRef","EnrichedTextInputNativeComponent","Commands","normalizeHtmlStyle","jsx","_jsx","nullthrows","value","Error","warnAboutMissconfiguredMentions","indicator","console","warn","EnrichedTextInput","ref","autoFocus","editable","mentionIndicators","defaultValue","placeholder","placeholderTextColor","cursorColor","selectionColor","style","autoCapitalize","htmlStyle","onFocus","onBlur","onChangeText","onChangeHtml","onChangeState","onLinkDetected","onMentionDetected","onStartMention","onChangeMention","onEndMention","onChangeSelection","androidExperimentalSynchronousEvents","scrollEnabled","rest","nativeRef","normalizedHtmlStyle","measureInWindow","callback","current","measure","measureLayout","relativeToNativeComponentRef","onSuccess","onFail","setNativeProps","nativeProps","focus","blur","setValue","toggleBold","toggleItalic","toggleUnderline","toggleStrikeThrough","toggleInlineCode","toggleH1","toggleH2","toggleH3","toggleCodeBlock","toggleBlockQuote","toggleOrderedList","toggleUnorderedList","setLink","start","end","text","url","addLink","setImage","uri","addImage","setMention","attributes","parsedAttributes","JSON","stringify","addMention","startMention","includes","handleMentionEvent","e","mentionText","nativeEvent","mentionIndicator","handleLinkDetected","handleMentionDetected","payload","parse","onInputFocus","onInputBlur","isOnChangeHtmlSet","undefined","onMention"],"sourceRoot":"../../src","sources":["EnrichedTextInput.tsx"],"mappings":"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","ignoreList":[]}
+{"version":3,"names":["useEffect","useImperativeHandle","useMemo","useRef","EnrichedTextInputNativeComponent","Commands","normalizeHtmlStyle","jsx","_jsx","nullthrows","value","Error","warnAboutMissconfiguredMentions","indicator","console","warn","EnrichedTextInput","ref","autoFocus","editable","mentionIndicators","defaultValue","placeholder","placeholderTextColor","cursorColor","selectionColor","style","autoCapitalize","htmlStyle","onFocus","onBlur","onChangeText","onChangeHtml","onChangeState","onLinkDetected","onMentionDetected","onStartMention","onChangeMention","onEndMention","onChangeSelection","androidExperimentalSynchronousEvents","scrollEnabled","rest","nativeRef","nextHtmlRequestId","pendingHtmlRequests","Map","pendingRequests","current","forEach","reject","clear","normalizedHtmlStyle","measureInWindow","callback","measure","measureLayout","relativeToNativeComponentRef","onSuccess","onFail","setNativeProps","nativeProps","focus","blur","setValue","getHTML","Promise","resolve","requestId","set","requestHTML","toggleBold","toggleItalic","toggleUnderline","toggleStrikeThrough","toggleInlineCode","toggleH1","toggleH2","toggleH3","toggleCodeBlock","toggleBlockQuote","toggleOrderedList","toggleUnorderedList","setLink","start","end","text","url","addLink","setImage","uri","width","height","addImage","setMention","attributes","parsedAttributes","JSON","stringify","addMention","startMention","includes","handleMentionEvent","e","mentionText","nativeEvent","mentionIndicator","handleLinkDetected","handleMentionDetected","payload","parse","handleRequestHtmlResult","html","pending","get","delete","onInputFocus","onInputBlur","isOnChangeHtmlSet","undefined","onMention","onRequestHtmlResult"],"sourceRoot":"../../src","sources":["EnrichedTextInput.tsx"],"mappings":"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","ignoreList":[]}
diff --git a/node_modules/react-native-enriched/lib/module/EnrichedTextInputNativeComponent.ts b/node_modules/react-native-enriched/lib/module/EnrichedTextInputNativeComponent.ts
index e0b9432..5bd119c 100644
--- a/node_modules/react-native-enriched/lib/module/EnrichedTextInputNativeComponent.ts
+++ b/node_modules/react-native-enriched/lib/module/EnrichedTextInputNativeComponent.ts
@@ -64,6 +64,11 @@ export interface OnChangeSelectionEvent {
   text: string;
 }
 
+export interface OnRequestHtmlResultEvent {
+  requestId: Int32;
+  html: UnsafeMixed;
+}
+
 export interface MentionStyleProperties {
   color?: ColorValue;
   backgroundColor?: ColorValue;
@@ -105,10 +110,6 @@ export interface HtmlStyleInternal {
   // This is a workaround for the fact that codegen does not support Records.
   // On native Android side this will become a ReadableMap, on native iOS we can work with a folly::dynamic object.
   mention?: UnsafeMixed;
-  img?: {
-    width?: Float;
-    height?: Float;
-  };
   ol?: {
     gapWidth?: Float;
     marginLeft?: Float;
@@ -147,6 +148,7 @@ export interface NativeProps extends ViewProps {
   onMentionDetected?: DirectEventHandler<OnMentionDetectedInternal>;
   onMention?: DirectEventHandler<OnMentionEvent>;
   onChangeSelection?: DirectEventHandler<OnChangeSelectionEvent>;
+  onRequestHtmlResult?: DirectEventHandler<OnRequestHtmlResultEvent>;
 
   // Style related props - used for generating proper setters in component's manager
   // These should not be passed as regular props
@@ -191,7 +193,12 @@ interface NativeCommands {
     text: string,
     url: string
   ) => void;
-  addImage: (viewRef: React.ElementRef<ComponentType>, uri: string) => void;
+  addImage: (
+    viewRef: React.ElementRef<ComponentType>,
+    uri: string,
+    width: Float,
+    height: Float
+  ) => void;
   startMention: (
     viewRef: React.ElementRef<ComponentType>,
     indicator: string
@@ -202,6 +209,10 @@ interface NativeCommands {
     text: string,
     payload: string
   ) => void;
+  requestHTML: (
+    viewRef: React.ElementRef<ComponentType>,
+    requestId: Int32
+  ) => void;
 }
 
 export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
@@ -228,6 +239,7 @@ export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
     'addImage',
     'startMention',
     'addMention',
+    'requestHTML',
   ],
 });
 
diff --git a/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js b/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js
index 203ee1b..e66d2a3 100644
--- a/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js
+++ b/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js
@@ -38,10 +38,6 @@ const defaultStyle = {
     backgroundColor: 'yellow',
     textDecorationLine: 'underline'
   },
-  img: {
-    width: 80,
-    height: 80
-  },
   ol: {
     gapWidth: 16,
     marginLeft: 16,
diff --git a/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js.map b/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js.map
index 840c587..9100ad5 100644
--- a/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js.map
+++ b/node_modules/react-native-enriched/lib/module/normalizeHtmlStyle.js.map
@@ -1 +1 @@
-{"version":3,"names":["processColor","defaultStyle","h1","fontSize","bold","h2","h3","blockquote","borderColor","borderWidth","gapWidth","color","undefined","codeblock","borderRadius","backgroundColor","code","a","textDecorationLine","mention","img","width","height","ol","marginLeft","markerFontWeight","markerColor","ul","bulletColor","bulletSize","isMentionStyleRecord","mentionStyle","Array","isArray","keys","Object","length","every","key","convertToHtmlStyleInternal","style","mentionIndicators","mentionStyles","forEach","indicator","default","String","olStyles","assignDefaultValues","merged","parseStyle","name","value","endsWith","parseColors","finalStyle","tagName","tagStyle","entries","tagStyles","styleName","styleValue","normalizeHtmlStyle","converted","withDefaults"],"sourceRoot":"../../src","sources":["normalizeHtmlStyle.ts"],"mappings":"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","ignoreList":[]}
+{"version":3,"names":["processColor","defaultStyle","h1","fontSize","bold","h2","h3","blockquote","borderColor","borderWidth","gapWidth","color","undefined","codeblock","borderRadius","backgroundColor","code","a","textDecorationLine","mention","ol","marginLeft","markerFontWeight","markerColor","ul","bulletColor","bulletSize","isMentionStyleRecord","mentionStyle","Array","isArray","keys","Object","length","every","key","convertToHtmlStyleInternal","style","mentionIndicators","mentionStyles","forEach","indicator","default","String","olStyles","assignDefaultValues","merged","parseStyle","name","value","endsWith","parseColors","finalStyle","tagName","tagStyle","entries","tagStyles","styleName","styleValue","normalizeHtmlStyle","converted","withDefaults"],"sourceRoot":"../../src","sources":["normalizeHtmlStyle.ts"],"mappings":"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","ignoreList":[]}
diff --git a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts
index 1c3af37..face251 100644
--- a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts
+++ b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts
@@ -5,6 +5,7 @@ export interface EnrichedTextInputInstance extends NativeMethods {
     focus: () => void;
     blur: () => void;
     setValue: (value: string) => void;
+    getHTML: () => Promise<string>;
     toggleBold: () => void;
     toggleItalic: () => void;
     toggleUnderline: () => void;
@@ -18,7 +19,7 @@ export interface EnrichedTextInputInstance extends NativeMethods {
     toggleOrderedList: () => void;
     toggleUnorderedList: () => void;
     setLink: (start: number, end: number, text: string, url: string) => void;
-    setImage: (src: string) => void;
+    setImage: (src: string, width: number, height: number) => void;
     startMention: (indicator: string) => void;
     setMention: (indicator: string, text: string, attributes?: Record<string, string>) => void;
 }
@@ -59,10 +60,6 @@ export interface HtmlStyle {
         textDecorationLine?: 'underline' | 'none';
     };
     mention?: Record<string, MentionStyleProperties> | MentionStyleProperties;
-    img?: {
-        width?: number;
-        height?: number;
-    };
     ol?: {
         gapWidth?: number;
         marginLeft?: number;
diff --git a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts.map b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts.map
index ccea61e..c8bc39f 100644
--- a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts.map
+++ b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInput.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"EnrichedTextInput.d.ts","sourceRoot":"","sources":["../../../src/EnrichedTextInput.tsx"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"EnrichedTextInput.d.ts","sourceRoot":"","sources":["../../../src/EnrichedTextInput.tsx"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts
index 224c9d2..59928fc 100644
--- a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts
+++ b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts
@@ -49,6 +49,10 @@ export interface OnChangeSelectionEvent {
     end: Int32;
     text: string;
 }
+export interface OnRequestHtmlResultEvent {
+    requestId: Int32;
+    html: UnsafeMixed;
+}
 export interface MentionStyleProperties {
     color?: ColorValue;
     backgroundColor?: ColorValue;
@@ -87,10 +91,6 @@ export interface HtmlStyleInternal {
         textDecorationLine?: string;
     };
     mention?: UnsafeMixed;
-    img?: {
-        width?: Float;
-        height?: Float;
-    };
     ol?: {
         gapWidth?: Float;
         marginLeft?: Float;
@@ -125,6 +125,7 @@ export interface NativeProps extends ViewProps {
     onMentionDetected?: DirectEventHandler<OnMentionDetectedInternal>;
     onMention?: DirectEventHandler<OnMentionEvent>;
     onChangeSelection?: DirectEventHandler<OnChangeSelectionEvent>;
+    onRequestHtmlResult?: DirectEventHandler<OnRequestHtmlResultEvent>;
     color?: ColorValue;
     fontSize?: Float;
     fontFamily?: string;
@@ -151,9 +152,10 @@ interface NativeCommands {
     toggleOrderedList: (viewRef: React.ElementRef<ComponentType>) => void;
     toggleUnorderedList: (viewRef: React.ElementRef<ComponentType>) => void;
     addLink: (viewRef: React.ElementRef<ComponentType>, start: Int32, end: Int32, text: string, url: string) => void;
-    addImage: (viewRef: React.ElementRef<ComponentType>, uri: string) => void;
+    addImage: (viewRef: React.ElementRef<ComponentType>, uri: string, width: Float, height: Float) => void;
     startMention: (viewRef: React.ElementRef<ComponentType>, indicator: string) => void;
     addMention: (viewRef: React.ElementRef<ComponentType>, indicator: string, text: string, payload: string) => void;
+    requestHTML: (viewRef: React.ElementRef<ComponentType>, requestId: Int32) => void;
 }
 export declare const Commands: NativeCommands;
 declare const _default: HostComponent<NativeProps>;
diff --git a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts.map b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts.map
index 90b47e7..78d78d1 100644
--- a/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts.map
+++ b/node_modules/react-native-enriched/lib/typescript/src/EnrichedTextInputNativeComponent.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"EnrichedTextInputNativeComponent.d.ts","sourceRoot":"","sources":["../../../src/EnrichedTextInputNativeComponent.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"EnrichedTextInputNativeComponent.d.ts","sourceRoot":"","sources":["../../../src/EnrichedTextInputNativeComponent.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EACV,kBAAkB,EAClB,KAAK,EACL,KAAK,EACL,WAAW,EACZ,MAAM,2CAA2C,CAAC;AACnD,OAAO,KAAK,EAAE,UAAU,EAAE,aAAa,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AACzE,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,MAAM,WAAW,iBAAiB;IAChC,KAAK,EAAE,MAAM,CAAC;CACf;AAED,MAAM,WAAW,iBAAiB;IAChC,KAAK,EAAE,MAAM,CAAC;CACf;AAED,MAAM,WAAW,kBAAkB;IACjC,MAAM,EAAE,OAAO,CAAC;IAChB,QAAQ,EAAE,OAAO,CAAC;IAClB,WAAW,EAAE,OAAO,CAAC;IACrB,eAAe,EAAE,OAAO,CAAC;IACzB,YAAY,EAAE,OAAO,CAAC;IACtB,IAAI,EAAE,OAAO,CAAC;IACd,IAAI,EAAE,OAAO,CAAC;IACd,IAAI,EAAE,OAAO,CAAC;IACd,WAAW,EAAE,OAAO,CAAC;IACrB,YAAY,EAAE,OAAO,CAAC;IACtB,aAAa,EAAE,OAAO,CAAC;IACvB,eAAe,EAAE,OAAO,CAAC;IACzB,MAAM,EAAE,OAAO,CAAC;IAChB,OAAO,EAAE,OAAO,CAAC;IACjB,SAAS,EAAE,OAAO,CAAC;CACpB;AAED,MAAM,WAAW,cAAc;IAC7B,IAAI,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;IACZ,KAAK,EAAE,KAAK,CAAC;IACb,GAAG,EAAE,KAAK,CAAC;CACZ;AAED,MAAM,WAAW,yBAAyB;IACxC,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;CACjB;AAED,MAAM,WAAW,iBAAiB;IAChC,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACpC;AAED,MAAM,WAAW,cAAc;IAC7B,SAAS,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,WAAW,CAAC;CACnB;AAED,MAAM,WAAW,sBAAsB;IACrC,KAAK,EAAE,KAAK,CAAC;IACb,GAAG,EAAE,KAAK,CAAC;IACX,IAAI,EAAE,MAAM,CAAC;CACd;AAED,MAAM,WAAW,wBAAwB;IACvC,SAAS,EAAE,KAAK,CAAC;IACjB,IAAI,EAAE,WAAW,CAAC;CACnB;AAED,MAAM,WAAW,sBAAsB;IACrC,KAAK,CAAC,EAAE,UAAU,CAAC;IACnB,eAAe,CAAC,EAAE,UAAU,CAAC;IAC7B,kBAAkB,CAAC,EAAE,WAAW,GAAG,MAAM,CAAC;CAC3C;AAED,MAAM,WAAW,iBAAiB;IAChC,EAAE,CAAC,EAAE;QACH,QAAQ,CAAC,EAAE,KAAK,CAAC;QACjB,IAAI,CAAC,EAAE,OAAO,CAAC;KAChB,CAAC;IACF,EAAE,CAAC,EAAE;QACH,QAAQ,CAAC,EAAE,KAAK,CAAC;QACjB,IAAI,CAAC,EAAE,OAAO,CAAC;KAChB,CAAC;IACF,EAAE,CAAC,EAAE;QACH,QAAQ,CAAC,EAAE,KAAK,CAAC;QACjB,IAAI,CAAC,EAAE,OAAO,CAAC;KAChB,CAAC;IACF,UAAU,CAAC,EAAE;QACX,WAAW,CAAC,EAAE,UAAU,CAAC;QACzB,WAAW,CAAC,EAAE,KAAK,CAAC;QACpB,QAAQ,CAAC,EAAE,KAAK,CAAC;QACjB,KAAK,CAAC,EAAE,UAAU,CAAC;KACpB,CAAC;IACF,SAAS,CAAC,EAAE;QACV,KAAK,CAAC,EAAE,UAAU,CAAC;QACnB,YAAY,CAAC,EAAE,KAAK,CAAC;QACrB,eAAe,CAAC,EAAE,UAAU,CAAC;KAC9B,CAAC;IACF,IAAI,CAAC,EAAE;QACL,KAAK,CAAC,EAAE,UAAU,CAAC;QACnB,eAAe,CAAC,EAAE,UAAU,CAAC;KAC9B,CAAC;IACF,CAAC,CAAC,EAAE;QACF,KAAK,CAAC,EAAE,UAAU,CAAC;QACnB,kBAAkB,CAAC,EAAE,MAAM,CAAC;KAC7B,CAAC;IAGF,OAAO,CAAC,EAAE,WAAW,CAAC;IACtB,EAAE,CAAC,EAAE;QACH,QAAQ,CAAC,EAAE,KAAK,CAAC;QACjB,UAAU,CAAC,EAAE,KAAK,CAAC;QACnB,gBAAgB,CAAC,EAAE,MAAM,CAAC;QAC1B,WAAW,CAAC,EAAE,UAAU,CAAC;KAC1B,CAAC;IACF,EAAE,CAAC,EAAE;QACH,WAAW,CAAC,EAAE,UAAU,CAAC;QACzB,UAAU,CAAC,EAAE,KAAK,CAAC;QACnB,UAAU,CAAC,EAAE,KAAK,CAAC;QACnB,QAAQ,CAAC,EAAE,KAAK,CAAC;KAClB,CAAC;CACH;AAED,MAAM,WAAW,WAAY,SAAQ,SAAS;IAE5C,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB,QAAQ,CAAC,EAAE,OAAO,CAAC;IACnB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,oBAAoB,CAAC,EAAE,UAAU,CAAC;IAClC,iBAAiB,EAAE,MAAM,EAAE,CAAC;IAC5B,WAAW,CAAC,EAAE,UAAU,CAAC;IACzB,cAAc,CAAC,EAAE,UAAU,CAAC;IAC5B,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,SAAS,CAAC,EAAE,iBAAiB,CAAC;IAC9B,aAAa,CAAC,EAAE,OAAO,CAAC;IAGxB,YAAY,CAAC,EAAE,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACxC,WAAW,CAAC,EAAE,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACvC,YAAY,CAAC,EAAE,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;IACrD,YAAY,CAAC,EAAE,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;IACrD,aAAa,CAAC,EAAE,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;IACvD,cAAc,CAAC,EAAE,kBAAkB,CAAC,cAAc,CAAC,CAAC;IACpD,iBAAiB,CAAC,EAAE,kBAAkB,CAAC,yBAAyB,CAAC,CAAC;IAClE,SAAS,CAAC,EAAE,kBAAkB,CAAC,cAAc,CAAC,CAAC;IAC/C,iBAAiB,CAAC,EAAE,kBAAkB,CAAC,sBAAsB,CAAC,CAAC;IAC/D,mBAAmB,CAAC,EAAE,kBAAkB,CAAC,wBAAwB,CAAC,CAAC;IAInE,KAAK,CAAC,EAAE,UAAU,CAAC;IACnB,QAAQ,CAAC,EAAE,KAAK,CAAC;IACjB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,SAAS,CAAC,EAAE,MAAM,CAAC;IAGnB,iBAAiB,EAAE,OAAO,CAAC;IAG3B,oCAAoC,EAAE,OAAO,CAAC;CAC/C;AAED,KAAK,aAAa,GAAG,aAAa,CAAC,WAAW,CAAC,CAAC;AAEhD,UAAU,cAAc;IAEtB,KAAK,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IAC1D,IAAI,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACzD,QAAQ,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC;IAG3E,UAAU,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IAC/D,YAAY,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACjE,eAAe,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACpE,mBAAmB,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACxE,gBAAgB,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACrE,QAAQ,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IAC7D,QAAQ,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IAC7D,QAAQ,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IAC7D,eAAe,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACpE,gBAAgB,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACrE,iBAAiB,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACtE,mBAAmB,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC;IACxE,OAAO,EAAE,CACP,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EACxC,KAAK,EAAE,KAAK,EACZ,GAAG,EAAE,KAAK,EACV,IAAI,EAAE,MAAM,EACZ,GAAG,EAAE,MAAM,KACR,IAAI,CAAC;IACV,QAAQ,EAAE,CACR,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EACxC,GAAG,EAAE,MAAM,EACX,KAAK,EAAE,KAAK,EACZ,MAAM,EAAE,KAAK,KACV,IAAI,CAAC;IACV,YAAY,EAAE,CACZ,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EACxC,SAAS,EAAE,MAAM,KACd,IAAI,CAAC;IACV,UAAU,EAAE,CACV,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EACxC,SAAS,EAAE,MAAM,EACjB,IAAI,EAAE,MAAM,EACZ,OAAO,EAAE,MAAM,KACZ,IAAI,CAAC;IACV,WAAW,EAAE,CACX,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,EACxC,SAAS,EAAE,KAAK,KACb,IAAI,CAAC;CACX;AAED,eAAO,MAAM,QAAQ,EAAE,cA0BrB,CAAC;wBAIG,aAAa,CAAC,WAAW,CAAC;AAFhC,wBAEiC"}
\ No newline at end of file
diff --git a/node_modules/react-native-enriched/lib/typescript/src/normalizeHtmlStyle.d.ts.map b/node_modules/react-native-enriched/lib/typescript/src/normalizeHtmlStyle.d.ts.map
index 2c1b7a5..aa3980f 100644
--- a/node_modules/react-native-enriched/lib/typescript/src/normalizeHtmlStyle.d.ts.map
+++ b/node_modules/react-native-enriched/lib/typescript/src/normalizeHtmlStyle.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"normalizeHtmlStyle.d.ts","sourceRoot":"","sources":["../../../src/normalizeHtmlStyle.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAErD,OAAO,KAAK,EAEV,iBAAiB,EAClB,MAAM,oCAAoC,CAAC;AA+K5C,eAAO,MAAM,kBAAkB,GAC7B,OAAO,SAAS,EAChB,mBAAmB,MAAM,EAAE,KAC1B,iBAIF,CAAC"}
\ No newline at end of file
+{"version":3,"file":"normalizeHtmlStyle.d.ts","sourceRoot":"","sources":["../../../src/normalizeHtmlStyle.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAErD,OAAO,KAAK,EAEV,iBAAiB,EAClB,MAAM,oCAAoC,CAAC;AA2K5C,eAAO,MAAM,kBAAkB,GAC7B,OAAO,SAAS,EAChB,mBAAmB,MAAM,EAAE,KAC1B,iBAIF,CAAC"}
\ No newline at end of file
diff --git a/node_modules/react-native-enriched/src/EnrichedTextInput.tsx b/node_modules/react-native-enriched/src/EnrichedTextInput.tsx
index 07f2d2f..22cc1f3 100644
--- a/node_modules/react-native-enriched/src/EnrichedTextInput.tsx
+++ b/node_modules/react-native-enriched/src/EnrichedTextInput.tsx
@@ -1,6 +1,7 @@
 import {
   type Component,
   type RefObject,
+  useEffect,
   useImperativeHandle,
   useMemo,
   useRef,
@@ -16,6 +17,7 @@ import EnrichedTextInputNativeComponent, {
   type OnMentionEvent,
   type OnMentionDetected,
   type OnMentionDetectedInternal,
+  type OnRequestHtmlResultEvent,
   type MentionStyleProperties,
 } from './EnrichedTextInputNativeComponent';
 import type {
@@ -37,6 +39,7 @@ export interface EnrichedTextInputInstance extends NativeMethods {
   focus: () => void;
   blur: () => void;
   setValue: (value: string) => void;
+  getHTML: () => Promise<string>;
 
   // Text formatting commands
   toggleBold: () => void;
@@ -52,7 +55,7 @@ export interface EnrichedTextInputInstance extends NativeMethods {
   toggleOrderedList: () => void;
   toggleUnorderedList: () => void;
   setLink: (start: number, end: number, text: string, url: string) => void;
-  setImage: (src: string) => void;
+  setImage: (src: string, width: number, height: number) => void;
   startMention: (indicator: string) => void;
   setMention: (
     indicator: string,
@@ -99,10 +102,6 @@ export interface HtmlStyle {
     textDecorationLine?: 'underline' | 'none';
   };
   mention?: Record<string, MentionStyleProperties> | MentionStyleProperties;
-  img?: {
-    width?: number;
-    height?: number;
-  };
   ol?: {
     gapWidth?: number;
     marginLeft?: number;
@@ -168,6 +167,11 @@ const warnAboutMissconfiguredMentions = (indicator: string) => {
 
 type ComponentType = (Component<NativeProps, {}, any> & NativeMethods) | null;
 
+type HtmlRequest = {
+  resolve: (html: string) => void;
+  reject: (error: Error) => void;
+};
+
 export const EnrichedTextInput = ({
   ref,
   autoFocus,
@@ -198,6 +202,19 @@ export const EnrichedTextInput = ({
 }: EnrichedTextInputProps) => {
   const nativeRef = useRef<ComponentType | null>(null);
 
+  const nextHtmlRequestId = useRef(1);
+  const pendingHtmlRequests = useRef(new Map<number, HtmlRequest>());
+
+  useEffect(() => {
+    const pendingRequests = pendingHtmlRequests.current;
+    return () => {
+      pendingRequests.forEach(({ reject }) => {
+        reject(new Error('Component unmounted'));
+      });
+      pendingRequests.clear();
+    };
+  }, []);
+
   const normalizedHtmlStyle = useMemo(
     () => normalizeHtmlStyle(htmlStyle, mentionIndicators),
     [htmlStyle, mentionIndicators]
@@ -233,6 +250,13 @@ export const EnrichedTextInput = ({
     setValue: (value: string) => {
       Commands.setValue(nullthrows(nativeRef.current), value);
     },
+    getHTML: () => {
+      return new Promise<string>((resolve, reject) => {
+        const requestId = nextHtmlRequestId.current++;
+        pendingHtmlRequests.current.set(requestId, { resolve, reject });
+        Commands.requestHTML(nullthrows(nativeRef.current), requestId);
+      });
+    },
     toggleBold: () => {
       Commands.toggleBold(nullthrows(nativeRef.current));
     },
@@ -272,8 +296,8 @@ export const EnrichedTextInput = ({
     setLink: (start: number, end: number, text: string, url: string) => {
       Commands.addLink(nullthrows(nativeRef.current), start, end, text, url);
     },
-    setImage: (uri: string) => {
-      Commands.addImage(nullthrows(nativeRef.current), uri);
+    setImage: (uri: string, width: number, height: number) => {
+      Commands.addImage(nullthrows(nativeRef.current), uri, width, height);
     },
     setMention: (
       indicator: string,
@@ -327,6 +351,22 @@ export const EnrichedTextInput = ({
     onMentionDetected?.({ text, indicator, attributes });
   };
 
+  const handleRequestHtmlResult = (
+    e: NativeSyntheticEvent<OnRequestHtmlResultEvent>
+  ) => {
+    const { requestId, html } = e.nativeEvent;
+    const pending = pendingHtmlRequests.current.get(requestId);
+    if (!pending) return;
+
+    if (html === null || typeof html !== 'string') {
+      pending.reject(new Error('Failed to parse HTML'));
+    } else {
+      pending.resolve(html);
+    }
+
+    pendingHtmlRequests.current.delete(requestId);
+  };
+
   return (
     <EnrichedTextInputNativeComponent
       ref={nativeRef}
@@ -351,6 +391,7 @@ export const EnrichedTextInput = ({
       onMentionDetected={handleMentionDetected}
       onMention={handleMentionEvent}
       onChangeSelection={onChangeSelection}
+      onRequestHtmlResult={handleRequestHtmlResult}
       androidExperimentalSynchronousEvents={
         androidExperimentalSynchronousEvents
       }
diff --git a/node_modules/react-native-enriched/src/EnrichedTextInputNativeComponent.ts b/node_modules/react-native-enriched/src/EnrichedTextInputNativeComponent.ts
index e0b9432..5bd119c 100644
--- a/node_modules/react-native-enriched/src/EnrichedTextInputNativeComponent.ts
+++ b/node_modules/react-native-enriched/src/EnrichedTextInputNativeComponent.ts
@@ -64,6 +64,11 @@ export interface OnChangeSelectionEvent {
   text: string;
 }
 
+export interface OnRequestHtmlResultEvent {
+  requestId: Int32;
+  html: UnsafeMixed;
+}
+
 export interface MentionStyleProperties {
   color?: ColorValue;
   backgroundColor?: ColorValue;
@@ -105,10 +110,6 @@ export interface HtmlStyleInternal {
   // This is a workaround for the fact that codegen does not support Records.
   // On native Android side this will become a ReadableMap, on native iOS we can work with a folly::dynamic object.
   mention?: UnsafeMixed;
-  img?: {
-    width?: Float;
-    height?: Float;
-  };
   ol?: {
     gapWidth?: Float;
     marginLeft?: Float;
@@ -147,6 +148,7 @@ export interface NativeProps extends ViewProps {
   onMentionDetected?: DirectEventHandler<OnMentionDetectedInternal>;
   onMention?: DirectEventHandler<OnMentionEvent>;
   onChangeSelection?: DirectEventHandler<OnChangeSelectionEvent>;
+  onRequestHtmlResult?: DirectEventHandler<OnRequestHtmlResultEvent>;
 
   // Style related props - used for generating proper setters in component's manager
   // These should not be passed as regular props
@@ -191,7 +193,12 @@ interface NativeCommands {
     text: string,
     url: string
   ) => void;
-  addImage: (viewRef: React.ElementRef<ComponentType>, uri: string) => void;
+  addImage: (
+    viewRef: React.ElementRef<ComponentType>,
+    uri: string,
+    width: Float,
+    height: Float
+  ) => void;
   startMention: (
     viewRef: React.ElementRef<ComponentType>,
     indicator: string
@@ -202,6 +209,10 @@ interface NativeCommands {
     text: string,
     payload: string
   ) => void;
+  requestHTML: (
+    viewRef: React.ElementRef<ComponentType>,
+    requestId: Int32
+  ) => void;
 }
 
 export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
@@ -228,6 +239,7 @@ export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
     'addImage',
     'startMention',
     'addMention',
+    'requestHTML',
   ],
 });
 
diff --git a/node_modules/react-native-enriched/src/normalizeHtmlStyle.ts b/node_modules/react-native-enriched/src/normalizeHtmlStyle.ts
index 96a7053..245ed2e 100644
--- a/node_modules/react-native-enriched/src/normalizeHtmlStyle.ts
+++ b/node_modules/react-native-enriched/src/normalizeHtmlStyle.ts
@@ -42,10 +42,6 @@ const defaultStyle: Required<HtmlStyle> = {
     backgroundColor: 'yellow',
     textDecorationLine: 'underline',
   },
-  img: {
-    width: 80,
-    height: 80,
-  },
   ol: {
     gapWidth: 16,
     marginLeft: 16,
